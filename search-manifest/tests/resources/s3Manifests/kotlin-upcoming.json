{
  "url": "http://mongodb.com/docs/drivers/kotlin/coroutine/upcoming",
  "includeInGlobalSearch": false,
  "documents": [
    {
      "slug": "api-documentation",
      "title": "API Documentation",
      "headings": [],
      "paragraphs": "BSON kotlinx.serialization  -\nclasses for encoding and decoding between Kotlin data classes and the BSON data\nformat using  kotlinx.serialization . Core  - classes that\ncontain essential driver functionality. Kotlin Coroutine Driver  -\nclasses for the current driver API using coroutines. Kotlin Sync Driver  -\nclasses for the current synchronous driver API.",
      "code": [],
      "preview": null,
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "compatibility",
      "title": "Compatibility",
      "headings": [
        "MongoDB Compatibility",
        "Compatibility Table Legend",
        "Language Compatibility"
      ],
      "paragraphs": "The following compatibility table specifies the recommended version or versions\nof the MongoDB Kotlin Driver for use with a specific version of MongoDB. The first column lists the driver version. MongoDB ensures compatibility between the MongoDB Server and the drivers\nfor three years after the server version's end of life (EOL) date. To learn\nmore about the MongoDB release and EOL dates, see\n MongoDB Software Lifecycle Schedules . Icon Explanation \u2713 All features are supported. \u229b The Driver version will work with the MongoDB version, but not all\nnew MongoDB features are supported. No mark The Driver version is not tested with the MongoDB version. Kotlin Driver Version MongoDB 8.0 MongoDB 7.0 MongoDB 6.0 MongoDB 5.0 MongoDB 4.4 MongoDB 4.2 MongoDB 4.0 MongoDB 3.6 MongoDB 3.4 MongoDB 3.2 MongoDB 3.0 MongoDB 2.6 5.2 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 5.1 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 5.0 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.11 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 4.10 \u229b \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 The following compatibility table specifies the recommended version or versions\nof the MongoDB Kotlin Driver for use with a specific version of Kotlin. The first column lists the driver version. For more information on how to read the compatibility tables, see our guide on\n MongoDB Compatibility Tables . Kotlin Driver Version Kotlin 1.8 5.1 \u2713 5.0 \u2713 4.11 \u2713 4.10 \u2713",
      "code": [],
      "preview": "The following compatibility table specifies the recommended version or versions\nof the MongoDB Kotlin Driver for use with a specific version of MongoDB.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "connection-troubleshooting",
      "title": "Connection Troubleshooting",
      "headings": [
        "Connection Error",
        "Check Connection String",
        "Configure Firewall",
        "Authentication Error",
        "Check Connection String",
        "Verify User Is in Authentication Database",
        "Error Sending Message",
        "Check Connection String",
        "Verify User Is in Authentication Database",
        "Configure Firewall",
        "Check the Number of Connections",
        "Timeout Error",
        "Set maxConnectionTimeoutMS",
        "Set maxConnectionLifeTime and maxConnectionIdleTime",
        "Check the Number of Connections",
        "Additional Tips",
        "Get Log Information for TLS/SSL"
      ],
      "paragraphs": "This page offers potential solutions to issues you might see when\nconnecting to a MongoDB instance or replica set while using the\nMongoDB Kotlin Driver. This page lists only connection issues. If you are having any other issues\nwith MongoDB, consider the following resources: The  Frequently Asked Questions (FAQ)  for the Kotlin driver The  Issues & Help  topic for information about\nreporting bugs, contributing to the driver, and additional resources The  MongoDB Community Forums  for\nquestions, discussions, or general technical support The following error message is a general message indicating that the driver\ncannot connect to a server on the specified hostname or port: If you receive this error, try the following methods to resolve the issue. Verify that the hostname and port number in the connection string are both\naccurate. In the sample error message, the hostname is  127.0.0.1  and the\nport is  27017 . The default port value for a MongoDB instance is\n 27017 , but you can configure MongoDB to communicate on another port. Assuming that your MongoDB deployment uses the default port, verify that your\nfirewall has port  27017  open. If your deployment is using a different port,\nverify that port is open in your firewall. Do not open ports in your firewall unless you are sure that is the port used\nby your MongoDB instance. The Kotlin driver can fail to connect to a MongoDB instance if\nthe authorization is not configured correctly. This often results in an error\nmessage similar to the following: If you receive this error, try the following methods to resolve the issue. An invalid connection string is the most common cause of authentication\nissues when attempting to connect to MongoDB. If your connection string contains a username and password, ensure that they\nare in the correct format. If your MongoDB deployment is on MongoDB Atlas, you can check your connection\nstring by using the  Atlas Connection Example .\nMake sure to replace the connection string in the example with yours. When connecting to a replica set, you should include all of the hosts\nin the replica set in your connection string. Separate each of the hosts\nin the connection string with a comma. This enables the driver to establish a\nconnection if one of the hosts is unreachable. For more information about using connection strings with the Kotlin driver,\nsee  Connection URI  in the Connection Guide. If the username or password includes any of the following characters, they\nmust be  percent encoded : To successfully authenticate a connection by using a username and password,\nthe username must be defined in the authentication database. The default\nauthentication database is the  admin  database. To use a different database\nfor authentication, specify the  authSource  in the connection string. The\nfollowing example instructs the driver to use  users  as the authentication\ndatabase: When you send a request through the driver and it is unable to send the command,\nit often displays the following general error message: If you receive this error, try the following methods to resolve the issue. Verify that the connection string in\nyour app is accurate. This is described under  Connection Error \nand  Authentication Error . The user needs to be recognized in your\nauthentication database. This is described under  Authentication\nError . The firewall needs to have an open port for communicating with the MongoDB\ninstance. This is described under  Connection Error . Each  MongoClient  instance supports a maximum number of concurrent open\nconnections in its connection pool. The configuration parameter  maxPoolSize \ndefines this value and is set to  100  by default. If there are already a\nnumber of open connections equal to  maxPoolSize , the server waits until\na connection becomes available. If this wait time exceeds the  maxIdleTimeMS \nvalue, the driver responds with an error. Sometimes when you send messages through the driver to the server, the messages\ntake a while to respond. When this happens, you might receive an error message\nsimilar to one of the following error messages: If you receive one of these errors, try the following methods to resolve the\nissue. The  maxConnectionTimeoutMS  option indicates the amount of time the\nKotlin driver waits for a connection before timing out. The default\nvalue is  10000 . You can increase this value or set it to  0  if\nyou want the driver to never timeout. Consider setting  maxConnectionLifeTime  and\n maxConnectionIdleTime . These parameters configure how long a connection\ncan be maintained with a MongoDB instance. For more information about these\nparameters, see  Connection Pool Settings . You might have too many open connections. The solution to this is described\nunder  Error Sending Message . While not related to a specific error message, this section includes\nadditional information that can be useful when attempting to troubleshoot\nconnection issues. When using TLS/SSL, you can use the  -Djavax.net.debug=all  system property\nto view additional log statements. This can help when attempting to debug any\nconnection issues. See  the Oracle guide to debugging TLS/SSL connections \nfor more information.",
      "code": [
        {
          "lang": "none",
          "value": "Error: couldn't connect to server 127.0.0.1:27017"
        },
        {
          "lang": "none",
          "value": "Command failed with error 18 (AuthenticationFailed): 'Authentication failed.' on server localhost:27017."
        },
        {
          "lang": "none",
          "value": ": / ? # [ ] @"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient =\nMongoClient.create(\"mongodb://<db_username>:<db_password>@<hostname>:<port>/?authSource=users\")"
        },
        {
          "lang": "none",
          "value": "com.mongodb.MongoSocketWriteException: Exception sending message"
        },
        {
          "lang": "none",
          "value": "Timed out after 30000 ms while waiting for a server that matches ReadPreferenceServerSelector{readPreference=primary}."
        },
        {
          "lang": "none",
          "value": "No server chosen by ReadPreferenceServerSelector{readPreference=primary} from cluster description"
        }
      ],
      "preview": "This page offers potential solutions to issues you might see when\nconnecting to a MongoDB instance or replica set while using the\nMongoDB Kotlin Driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "faq",
      "title": "FAQ",
      "headings": [
        "Why Am I Having Problems Connecting to a MongoDB Instance?",
        "How is the Kotlin Driver Different from KMongo?",
        "What is the Difference Between the Kotlin Driver and the Kotlin SDK?",
        "How Does Connection Pooling Work in the Kotlin Driver?"
      ],
      "paragraphs": "On this page, you can find frequently asked questions and their corresponding answers. If you can't find an answer to your question on this page, see the\n Issues & Help  page for information on how to report issues. If you have trouble connecting to a MongoDB deployment, see\nthe  Connection Troubleshooting Guide \nfor possible solutions. The Kotlin driver is the official MongoDB driver for Kotlin. It is\ndeveloped by the MongoDB team and provides a native API for Kotlin\napplications to connect to MongoDB and work with data. It is implemented\nby wrapping the  MongoDB Java driver . The Kotlin driver was developed in collaboration with the creator of KMongo,\nJulien Buret, to give users an officially-supported driver. The official Kotlin driver and KMongo have generally similar APIs.\nNotable similarities between the Kotlin driver and KMongo include: Although the official Kotlin driver and KMongo are similar, there are some\nkey differences: For more detailed information, see  Migrate from KMongo . KMongo  is a popular community-developed library\nfor working with MongoDB from Kotlin applications.\nIt is a wrapper around the Java driver that was created prior to the creation of\nthe official Kotlin driver to serve the needs of the Kotlin community. As of July 2023, KMongo has been marked as deprecated. Support for synchronous and coroutine-based operations Support using data classes to represent MongoDB documents Support KotlinX serialization Support for MongoDB CRUD APIs and aggregation The official driver does  not  have built-in support for  reactor ,\n rxjava2 ,  Jackson ,\nor  GSON . The official driver does  not  support MongoDB shell commands. The official driver supports type-safe queries with the Builders API,\nwhereas KMongo uses infix functions and property references for\ntype-safe queries. MongoDB supports both mobile and server-side development in Kotlin. If\nyou are developing a mobile application for Android or Kotlin\nMultiplatform (KMP), you can use the  MongoDB\nAtlas Device Kotlin SDK  to access Atlas App Services and\nto manage your Realm data. The Kotlin driver supports server-side development by providing a\ncomplete library for building idiomatic Kotlin applications. You can\nlearn how to develop asynchronous applications in this documentation for\nthe Kotlin Coroutine Driver, or you can view the  Kotlin Sync\nDriver documentation  to learn more about synchronous\nprogramming. Every  MongoClient  instance has a built-in connection pool for each server\nin your MongoDB topology. Connection pools open sockets on demand to\nsupport concurrent MongoDB operations in your multi-threaded application. The maximum size of each connection pool is set by the  maxPoolSize  option, which\ndefaults to  100 . If the number of in-use connections to a server reaches\nthe value of  maxPoolSize , the next request to that server will wait\nuntil a connection becomes available. Each  MongoClient  instance opens two additional sockets per server in your\nMongoDB topology for monitoring the server's state. For example, a client connected to a 3-node replica set opens 6\nmonitoring sockets. It also opens as many sockets as needed to support\nan application's threads on each server, up to\nthe value of  maxPoolSize . If  maxPoolSize  is  100  and the\napplication only uses the primary (the default), then only the primary\nconnection pool grows and there can be at most  106  total connections. If the\napplication uses a  read preference  to query the\nsecondary nodes, their pools also grow and there can be  306  total connections. Additionally, connection pools are rate-limited such that each connection pool\ncan only create, at maximum, the value of  maxConnecting  connections\nin parallel at any time. Any additional thread stops waiting in the\nfollowing cases: You can set the minimum number of concurrent connections to\neach server with the  minPoolSize  option, which defaults to  0 .\nThe connection pool will be initialized with this number of sockets. If\nsockets are closed due to any network errors, causing the total number\nof sockets (both in use and idle) to drop below the minimum, more\nsockets are opened until the minimum is reached. You can set the maximum number of milliseconds that a connection can\nremain idle in the pool before being removed and replaced with\nthe  maxIdleTimeMS  option, which defaults to  0  (no limit). The following default configuration for a  MongoClient  works for most\napplications: Create a client once for each process, and reuse it for all\noperations. It is a common mistake to create a new client for each\nrequest, which is very inefficient. To support high numbers of concurrent MongoDB operations\nwithin one process, you can increase  maxPoolSize . Once the pool\nreaches its maximum size, additional threads wait for sockets\nto become available. The driver does not limit the number of threads that\ncan wait for sockets to become available, and it is the application's\nresponsibility to limit the size of its pool to bound queuing\nduring a load spike. Threads wait for the amount of time specified in\nthe  waitQueueTimeoutMS  option, which defaults to  120000  (120 seconds). A thread that waits more than the length of time defined by\n waitQueueTimeoutMS  for a socket raises a connection error. Use this\noption if it is more important to bound the duration of operations\nduring a load spike than it is to complete every operation. When  MongoClient.close()  is called by any thread, the driver\ncloses all idle sockets and closes all sockets that are in\nuse as they are returned to the pool. To learn more about connecting to MongoDB, see the  Connection\nGuide . One of the existing threads finishes creating a connection, or\nan existing connection is checked back into the pool. The driver's ability to reuse existing connections improves due to\nrate-limits on connection creation.",
      "code": [
        {
          "lang": "kotlin",
          "value": "val client = MongoClient(\"<connection string>\")"
        }
      ],
      "preview": "On this page, you can find frequently asked questions and their corresponding answers.",
      "tags": "troubleshooting, question, support",
      "facets": {
        "genre": ["reference"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/aggregation-expression-operations",
      "title": "Aggregation Expression Operations",
      "headings": [
        "Overview",
        "How to Use Operations",
        "Constructor Methods",
        "Operations",
        "Arithmetic Operations",
        "Array Operations",
        "Boolean Operations",
        "Comparison Operations",
        "Conditional Operations",
        "Convenience Operations",
        "Conversion Operations",
        "Date Operations",
        "Document Operations",
        "Map Operations",
        "String Operations",
        "Type-Checking Operations"
      ],
      "paragraphs": "In this guide, you can learn how to use the MongoDB Kotlin Driver to construct\nexpressions for use in aggregation pipelines. You can perform\nexpression operations with discoverable, typesafe Java methods rather\nthan BSON documents. Because these methods follow the fluent interface\npattern, you can chain aggregation operations together to create code\nthat is both more compact and more naturally readable. The operations in this guide use methods from the\n com.mongodb.client.model.mql  package.\nThese methods provide an idiomatic way to use the Query API,\nthe mechanism by which the driver interacts with a MongoDB deployment. To learn more\nabout the Query API, see the  Server manual documentation . The examples in this guide assume that you include the following imports\nin your code: To access document fields in an expression, you need to reference the\ncurrent document being processed by the aggregation pipeline. Use the\n current()  method to refer to this document. To access the value of a\nfield, you must use the appropriately typed method, such as\n getString()  or  getDate() . When you specify the type for a field,\nyou ensure that the driver provides only those methods which are\ncompatible with that type. The following code shows how to reference a\nstring field called  name : To specify a value in an operation, pass it to the  of()  constructor method to\nconvert it to a valid type. The following code shows how to reference a\nvalue of  1.0 : To create an operation, chain a method to your field or value reference.\nYou can build more complex operations by chaining additional methods. The following example creates an operation to find patients in New\nMexico who have visited the doctor\u2019s office at least once. The operation\nperforms the following actions: The  and()  method links these operations so that the pipeline stage\nmatches only documents that meet both criteria. While some aggregation stages, such as  group() , accept operations\ndirectly, other stages expect that you first include your operation in a\nmethod such as  computed()  or  expr() . These methods, which take\nvalues of type  TExpression , allow you to use your expressions in\ncertain aggregations. To complete your aggregation pipeline stage, include your expression\nin an aggregates builder method. The following list provides examples of\nhow to include your expression in common aggregates builder methods: To learn more about these methods, see the\n Aggregation guide . The examples use the  listOf()  method to create a list of\naggregation stages. This list is passed to the  aggregate()  method of\n MongoCollection . Checks if the size of the  visitDates  array is greater than  0 \nby using the  gt()  method Checks if the  state  field value is \u201cNew Mexico\u201d by using the\n eq()  method match(expr(<expression>)) project(fields(computed(\"<field name>\", <expression>))) group(<expression>) You can use these constructor methods to define values for use in Kotlin aggregation\nexpressions. Refer to any of the sections in  Operations  for examples using these methods. Method Description current() References the current document being processed by the aggregation pipeline. currentAsMap() References the current document being processed by the aggregation pipeline as a map value. Returns an  MqlValue  type corresponding to the provided primitive. ofArray() Returns an array of  MqlValue  types corresponding to the provided array of primitives. ofEntry() Returns an entry value. ofMap() Returns an empty map value. ofNull() Returns the null value as exists in the Query API. When you provide a value to one of these methods, the driver treats\nit literally. For example,  of(\"$x\")  represents the string value\n \"$x\" , rather than a field named  x . The following sections provide information and examples for\naggregation expression operations available in the driver.\nThe operations are categorized by purpose and functionality. Each section has a table that describes aggregation methods\navailable in the driver and corresponding expression operators in the\nQuery API. The method names link to API documentation and the\naggregation pipeline operator names link to descriptions and examples in\nthe Server manual documentation. While each method is effectively\nequivalent to the corresponding Query API expression, they may differ in\nexpected parameters and implementation. The driver generates a Query API expression that may be different\nfrom the Query API expression provided in each example. However,\nboth expressions will produce the same aggregation result. The driver does not provide methods for all aggregation pipeline operators in\nthe Query API. If you need to use an unsupported operation in an\naggregation, you must define the entire expression using the BSON  Document \ntype. To learn more about the  Document  type, see  Documents . You can perform an arithmetic operation on a value of type  MqlInteger  or\n MqlNumber  using the methods described in this section. Suppose you have weather data for a specific year that includes the\nprecipitation measurement (in inches) for each day. You want find the average\nprecipitation, in millimeters, for each month. The  multiply()  operator multiplies the  precipitation  field by\n 25.4  to convert the value to millimeters. The  avg()  accumulator method\nreturns the average as the  avgPrecipMM  field. The  group()  method\ngroups the values by month given in each document's  date  field. The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in the\nQuery API: Method Aggregation Pipeline Operator $abs $add divide() $divide $multiply round() $round $subtract You can perform an array operation on a value of type  MqlArray \nusing the methods described in this section. Suppose you have a collection of movies, each of which contains an array\nof nested documents for upcoming showtimes. Each nested document\ncontains an array that represents the total number of seats in the\ntheater, where the first array entry is the number of premium seats and\nthe second entry is the number of regular seats. Each nested document\nalso contains the number of tickets that have already been bought for\nthe showtime. A document in this collection might resemble the\nfollowing: The  filter()  method displays only the results matching the provided\npredicate. In this case, the predicate uses  sum()  to calculate the\ntotal number of seats and compares that value to the number of  ticketsBought \nwith  lt() . The  project()  method stores these filtered results as a new\n availableShowtimes  array. The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in\nthe Query API: Method Aggregation Pipeline Operator all() $allElementsTrue any() $anyElementTrue concat() $concatArrays concatArrays() $concatArrays contains() $in distinct() $setUnion elementAt() $arrayElemAt filter() $filter first() $first joinStrings() $concat last() $last map() $map max() $max maxN() $maxN min() $min minN() $minN multiply() $multiply size() $size slice() $slice sum() $sum union() $setUnion unionArrays() $setUnion You must specify the type of the array that you retrieve with the\n getArray()  method if you need to work with the values of the\narray as their specific type. In this example, we specify that the  seats  array contains values\nof type  MqlDocument  so that we can extract nested fields from\neach array entry. To improve readability, the previous example assigns intermediary values to\nthe  totalSeats  and  isAvailable  variables. If you don't pull\nout these intermediary values into variables, the code still produces\nequivalent results. You can perform a boolean operation on a value of type  MqlBoolean \nusing the methods described in this section. Suppose you want to classify very low or high weather temperature\nreadings (in degrees Fahrenheit) as extreme. The  or()  operator checks to see if temperatures are extreme by comparing\nthe  temperature  field to predefined values with  lt()  and  gt() .\nThe  project()  method records this result in the  extremeTemp  field. The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in\nthe Query API: Method Aggregation Pipeline Operator and() $and not() $not or() $or You can perform a comparison operation on a value of type  MqlValue \nusing the methods described in this section. The following example shows a pipeline that matches all the documents\nwhere the  location  field has the value  \"California\" : The following code provides an equivalent aggregation pipeline in\nthe Query API: The  cond()  method is similar to the ternary operator in Java and you\nshould use it for simple branches based on a boolean value. You should use\nthe  switchOn()  methods for more complex comparisons such as performing\npattern matching on the value type or other arbitrary checks on the value. Method Aggregation Pipeline Operator eq() $eq gt() $gt gte() $gte lt() $lt lte() $lte $max $min ne() $ne You can perform a conditional operation using the methods described in\nthis section. Suppose you have a collection of customers with their membership information.\nOriginally, customers were either members or not. Over time, membership levels\nwere introduced and used the same field. The information stored in this field\ncan be one of a few different types, and you want to create a standardized value\nindicating their membership level. The  switchOn()  method checks each clause in order. If the value matches the\ntype indicated by the clause, that clause determines the string value\ncorresponding to the membership level. If the original value is a string, it\nrepresents the membership level and that value is used. If the data type is a\nboolean, it returns either  Gold  or  Guest  for the membership level. If\nthe data type is an array, it returns the most recent string in the array which\nmatches the most recent membership level. If the  member  field is an\nunknown type, the  switchOn()  method provides a default value of  Guest . The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in\nthe Query API: Method Aggregation Pipeline Operator cond() $cond switchOn() $switch You can apply custom functions to values of type\n MqlValue  using the methods described in this section. To improve readability and allow for code reuse, you can move redundant\ncode into static methods. However, it is not possible to directly chain\nstatic methods in Kotlin. The  passTo()  method lets you chain values\ninto custom static methods. Suppose you need to determine how a class is performing against some\nbenchmarks. You want to find the average final grade for each class and\ncompare it against the benchmark values. The following custom method  gradeAverage()  takes an array of documents and\nthe name of an integer field shared across those documents. It calculates the\naverage of that field across all the documents in the provided array and\ndetermines the average of that field across all the elements in\nthe provided array. The  evaluate()  method compares a provided value to\ntwo provided range limits and generates a response string based on\nhow the values compare: The  passArrayTo()  method takes all of the students and calculates the\naverage score by using the  gradeAverage()  method. Then, the\n passNumberTo()  method uses the  evaluate()  method to determine how the\nclasses are performing. This example stores the result as the  evaluation \nfield using the  project()  method. The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in\nthe Query API: Method Aggregation Pipeline Operator passTo() No corresponding operator One advantage of using the  passTo()  method is that you can reuse\nyour custom methods for other aggregations. You could\nuse the  gradeAverage()  method to find the average of grades for\ngroups of students filtered by, for example, entry year or district, not just their\nclass. You could use the  evaluate()  method to evaluate, for\nexample, an individual student's performance, or an entire school's or\ndistrict's performance. You can perform a conversion operation to convert between certain  MqlValue \ntypes using the methods described in this section. Suppose you want to have a collection of student data that includes\ntheir graduation years, which are stored as strings. You want to\ncalculate the year of their five-year reunion and store this value in a\nnew field. The  parseInteger()  method converts the  graduationYear  to an integer\nso that  add()  can calculate the reunion year. The  addFields()  method\nstores this result as a new  reunionYear  field. The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in\nthe Query API: Method Aggregation Pipeline Operator asDocument() No corresponding operator asMap() No corresponding operator asString() for MqlDate $dateToString asString() for MqlValue $toString millisecondsAsDate() $toDate parseDate() $dateFromString parseInteger() $toInt You can perform a date operation on a value of type  MqlDate \nusing the methods described in this section. Suppose you have data about package deliveries and need to match\ndeliveries that occurred on any Monday in the  \"America/New_York\"  time\nzone. If the  deliveryDate  field contains any string values representing\nvalid dates, such as  \"2018-01-15T16:00:00Z\"  or  \"Jan 15, 2018, 12:00\nPM EST\" , you can use the  parseDate()  method to convert the strings\ninto date types. The  dayOfWeek()  method determines which day of the week it is and converts\nit to a number based on which day is a Monday according to the\n \"America/New_York\"  parameter. The  eq()  method compares this value to\n 2 , which corresponds to Monday based on the provided timezone parameter. The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in\nthe Query API: Method Aggregation Pipeline Operator dayOfMonth() $dayOfMonth dayOfWeek() $dayOfWeek dayOfYear() $dayOfYear hour() $hour millisecond() $millisecond minute() $minute month() $month second() $second week() $week year() $year You can perform a document operation on a value of type  MqlDocument \nusing the methods described in this section. Suppose you have a collection of legacy customer data which includes\naddresses as child documents under the  mailing.address  field. You want\nto find all the customers who currently live in Washington state. A\ndocument in this collection might resemble the following: The  getDocument()  method retrieves the  mailing.address  field as a\ndocument so the nested  state  field can be retrieved with the\n getString()  method. The  eq()  method checks if the value of the\n state  field is  \"WA\" . The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in\nthe Query API: Method Aggregation Pipeline Operator $getField hasField() No corresponding operator merge() $mergeObjects setField() $setField unsetField() $unsetField You can perform a map operation on a value of either type  MqlMap  or\n MqlEntry  using the methods described in this section. Suppose you have a collection of inventory data where each document represents\nan individual item you're responsible for supplying. Each document contains a\nfield that is a map of all your warehouses and how many copies they currently\nhave in their inventory of the item. You want to determine the total number of\ncopies of items you have across all of your warehouses. A document in this\ncollection might resemble the following: The  entries()  method returns the map entries in the  warehouses \nfield as an array. The  sum()  method calculates the total value of items\nbased on the values in the array retrieved with the  getValue()  method.\nThis example stores the result as the new  totalInventory  field using the\n project()  method. The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in\nthe Query API: You should represent data as a map if the data maps\narbitrary keys such as dates or item IDs to values. Method Aggregation Pipeline Operator entries() $objectToArray get() No corresponding operator getKey() No corresponding operator getValue() No corresponding operator has() No corresponding operator merge() No corresponding operator set() No corresponding operator setKey() No corresponding operator setValue() No corresponding operator unset() No corresponding operator You can perform a string operation on a value of type  MqlString \nusing the methods described in this section. Suppose you need to generate lowercase usernames for employees of a\ncompany from the employees' last names and employee IDs. The  append()  method combines the  lastName  and  employeeID  fields into\na single username, while the  toLower()  method makes the entire username\nlowercase. This example stores the result as a new  username  field using\nthe  project()  method. The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in\nthe Query API: Method Aggregation Pipeline Operator append() $concat length() $strLenCP lengthBytes() $strLenBytes substr() $substrCP substrBytes() $substrBytes toLower() $toLower toUpper() $toUpper You can perform a type-check operation on a value of type  MqlValue \nusing the methods described in this section. These methods do not return boolean values. Instead, you provide a default value\nthat matches the type specified by the method. If the checked value\nmatches the method type, the checked value is returned. Otherwise, the supplied\ndefault value is returned. If you want to program branching logic based on the\ndata type, see  switchOn() . Suppose you have a collection of rating data. An early version of the review\nschema allowed users to submit negative reviews without a star rating. You want\nconvert any of these negative reviews without a star rating to have the minimum\nvalue of 1 star. The  isNumberOr()  method returns either the value of  rating , or\na value of  1  if  rating  is not a number or is null. The\n project()  method returns this value as a new  numericalRating  field. The following code shows the pipeline for this aggregation: The following code provides an equivalent aggregation pipeline in\nthe Query API: Method Aggregation Pipeline Operator isArrayOr() No corresponding operator isBooleanOr() No corresponding operator isDateOr() No corresponding operator isDocumentOr() No corresponding operator isIntegerOr() No corresponding operator isMapOr() No corresponding operator isNumberOr() No corresponding operator isStringOr() No corresponding operator",
      "code": [
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Aggregates\nimport com.mongodb.client.model.Accumulators\nimport com.mongodb.client.model.Projections\nimport com.mongodb.client.model.Filters\nimport com.mongodb.client.model.mql.MqlValues"
        },
        {
          "lang": "kotlin",
          "value": "current().getString(\"name\")"
        },
        {
          "lang": "kotlin",
          "value": "of(1.0)"
        },
        {
          "lang": "kotlin",
          "value": "current()\n    .getArray(\"visitDates\")\n    .size()\n    .gt(of(0))\n    .and(current()\n        .getString(\"state\")\n        .eq(of(\"New Mexico\")))"
        },
        {
          "lang": "javascript",
          "value": "[ { $group: {\n    _id: { $month: \"$date\" },\n    avgPrecipMM: {\n        $avg: { $multiply: [\"$precipitation\", 25.4] } }\n} } ]"
        },
        {
          "lang": "kotlin",
          "value": "val month = current().getDate(\"date\").month(of(\"UTC\"))\nval precip = current().getInteger(\"precipitation\")\n\nlistOf(\n    Aggregates.group(\n        month,\n        Accumulators.avg(\"avgPrecipMM\", precip.multiply(25.4))\n))\n"
        },
        {
          "lang": "json",
          "value": "{\n  \"_id\": ...,\n  \"movie\": \"Hamlet\",\n  \"showtimes\": [\n    {\n      \"date\": \"May 14, 2023, 12:00 PM\",\n      \"seats\": [ 20, 80 ],\n      \"ticketsBought\": 100\n    },\n    {\n      \"date\": \"May 20, 2023, 08:00 PM\",\n      \"seats\": [ 10, 40 ],\n      \"ticketsBought\": 34\n    }]\n}"
        },
        {
          "lang": "javascript",
          "value": "[ { $project: {\n    availableShowtimes: {\n        $filter: {\n            input: \"$showtimes\",\n            as: \"showtime\",\n            cond: { $lt: [ \"$$showtime.ticketsBought\", { $sum: \"$$showtime.seats\" } ] }\n    } }\n} } ]"
        },
        {
          "lang": "kotlin",
          "value": "val showtimes = current().getArray<MqlDocument>(\"showtimes\")\n\nlistOf(\n    Aggregates.project(\n        Projections.fields(\n            Projections.computed(\"availableShowtimes\", showtimes\n                .filter { showtime ->\n                    val seats = showtime.getArray<MqlInteger>(\"seats\")\n                    val totalSeats = seats.sum { n -> n }\n                    val ticketsBought = showtime.getInteger(\"ticketsBought\")\n                    val isAvailable = ticketsBought.lt(totalSeats)\n                    isAvailable\n                })\n)))\n"
        },
        {
          "lang": "javascript",
          "value": "[ { $project: {\n    extremeTemp: { $or: [ { $lt: [\"$temperature\", 10] },\n                          { $gt: [\"$temperature\", 95] } ] }\n} } ]"
        },
        {
          "lang": "kotlin",
          "value": "val temperature = current().getInteger(\"temperature\")\n\nlistOf(\n    Aggregates.project(\n        Projections.fields(\n            Projections.computed(\"extremeTemp\", temperature\n                .lt(of(10))\n                .or(temperature.gt(of(95))))\n)))\n"
        },
        {
          "lang": "javascript",
          "value": "[ { $match: { location: { $eq: \"California\" } } } ]"
        },
        {
          "lang": "kotlin",
          "value": "val location = current().getString(\"location\")\n\nlistOf(\n    Aggregates.match(\n        Filters.expr(location.eq(of(\"California\")))\n))\n"
        },
        {
          "lang": "javascript",
          "value": "[ { $project: {\n    membershipLevel: {\n        $switch: {\n          branches: [\n            { case: { $eq: [ { $type: \"$member\" }, \"string\" ] }, then: \"$member\" },\n            { case: { $eq: [ { $type: \"$member\" }, \"bool\" ] }, then: { $cond: {\n                                                                           if: \"$member\",\n                                                                           then: \"Gold\",\n                                                                           else: \"Guest\" } } },\n            { case: { $eq: [ { $type: \"$member\" }, \"array\" ] }, then: { $last: \"$member\" } }\n          ],\n          default: \"Guest\" } }\n} } ]"
        },
        {
          "lang": "kotlin",
          "value": "val member = current().getField(\"member\")\n\nlistOf(\n    Aggregates.project(\n        Projections.fields(\n            Projections.computed(\"membershipLevel\",\n                member.switchOn{field -> field\n                    .isString{s-> s}\n                    .isBoolean{b -> b.cond(of(\"Gold\"), of(\"Guest\"))}\n                    .isArray { a -> a.last()}\n                    .defaults{ d -> of(\"Guest\")}})\n)))\n"
        },
        {
          "lang": "javascript",
          "value": "[ { $project: {\n    evaluation: { $switch: {\n        branches: [\n            { case: { $lte: [ { $avg: \"$students.finalGrade\" }, 70 ] },\n              then: \"Needs improvement\"\n            },\n            { case: { $lte: [ { $avg: \"$students.finalGrade\" }, 85 ] },\n              then: \"Meets expectations\"\n            }\n        ],\n        default: \"Exceeds expectations\" } }\n} } ]"
        },
        {
          "lang": "kotlin",
          "value": "fun gradeAverage(students: MqlArray<MqlDocument>, fieldName: String): MqlNumber {\n    val sum = students.sum{ student -> student.getInteger(fieldName) }\n    val avg = sum.divide(students.size())\n    return avg\n}\n\nfun evaluate(grade: MqlNumber, cutoff1: MqlNumber, cutoff2: MqlNumber): MqlString {\n    val message = grade.switchOn{ on -> on\n        .lte(cutoff1) { g -> of(\"Needs improvement\") }\n        .lte(cutoff2) { g -> of(\"Meets expectations\") }\n        .defaults{g -> of(\"Exceeds expectations\")}}\n    return message\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val students = current().getArray<MqlDocument>(\"students\")\n\nlistOf(\n    Aggregates.project(\n        Projections.fields(\n            Projections.computed(\"evaluation\", students\n                .passArrayTo { s -> gradeAverage(s, \"finalGrade\") }\n                .passNumberTo { grade -> evaluate(grade, of(70), of(85)) })\n)))\n"
        },
        {
          "lang": "javascript",
          "value": "[ { $addFields: {\n    reunionYear: {\n        $add: [ { $toInt: \"$graduationYear\" }, 5 ] }\n} } ]"
        },
        {
          "lang": "kotlin",
          "value": "val graduationYear = current().getString(\"graduationYear\")\n\nlistOf(\n    Aggregates.addFields(\n        Field(\"reunionYear\",\n            graduationYear\n                .parseInteger()\n                .add(5))\n))\n"
        },
        {
          "lang": "javascript",
          "value": "[ { $match: {\n    $expr: {\n        $eq: [ {\n            $dayOfWeek: {\n                date: { $dateFromString: { dateString: \"$deliveryDate\" } },\n                timezone: \"America/New_York\" }},\n            2\n        ] }\n} } ]"
        },
        {
          "lang": "kotlin",
          "value": "val deliveryDate = current().getString(\"deliveryDate\")\n\nlistOf(\n    Aggregates.match(\n        Filters.expr(deliveryDate\n            .parseDate()\n            .dayOfWeek(of(\"America/New_York\"))\n            .eq(of(2))\n)))\n"
        },
        {
          "lang": "json",
          "value": "{\n  \"_id\": ...,\n  \"customer.name\": \"Mary Kenneth Keller\",\n  \"mailing.address\":\n  {\n    \"street\": \"601 Mongo Drive\",\n    \"city\": \"Vasqueztown\",\n    \"state\": \"CO\",\n    \"zip\": 27017\n  }\n}"
        },
        {
          "lang": "javascript",
          "value": "[\n    { $match: {\n        $expr: {\n            $eq: [{\n                $getField: {\n                    input: { $getField: { input: \"$$CURRENT\", field: \"mailing.address\"}},\n                    field: \"state\" }},\n                \"WA\" ]\n}}}]"
        },
        {
          "lang": "kotlin",
          "value": "val address = current().getDocument(\"mailing.address\")\n\nlistOf(\n    Aggregates.match(\n        Filters.expr(address\n            .getString(\"state\")\n            .eq(of(\"WA\"))\n)))\n"
        },
        {
          "lang": "json",
          "value": "{\n  \"_id\": ...,\n  \"item\": \"notebook\"\n  \"warehouses\": [\n    { \"Atlanta\", 50 },\n    { \"Chicago\", 0 },\n    { \"Portland\", 120 },\n    { \"Dallas\", 6 }\n  ]\n}"
        },
        {
          "lang": "javascript",
          "value": "[ { $project: {\n    totalInventory: {\n        $sum: {\n          $getField: { $objectToArray: \"$warehouses\" },\n        } }\n} } ]"
        },
        {
          "lang": "kotlin",
          "value": "val warehouses = current().getMap<MqlNumber>(\"warehouses\")\n\nlistOf(\n    Aggregates.project(\n        Projections.fields(\n            Projections.computed(\"totalInventory\", warehouses\n                .entries()\n                .sum { v -> v.getValue() })\n)))\n"
        },
        {
          "lang": "javascript",
          "value": "[ { $project: {\n    username: {\n        $toLower: { $concat: [\"$lastName\", \"$employeeID\"] } }\n} } ]"
        },
        {
          "lang": "kotlin",
          "value": "val lastName = current().getString(\"lastName\")\nval employeeID = current().getString(\"employeeID\")\n\nlistOf(\n    Aggregates.project(\n        Projections.fields(\n            Projections.computed(\"username\", lastName\n                .append(employeeID)\n                .toLower())\n)))\n"
        },
        {
          "lang": "javascript",
          "value": "[ { $project: {\n    numericalRating: {\n        $cond: { if: { $isNumber: \"$rating\" },\n                 then: \"$rating\",\n                 else: 1\n        } }\n} } ]"
        },
        {
          "lang": "kotlin",
          "value": "val rating = current().getField(\"rating\")\n\nlistOf(\n    Aggregates.project(\n        Projections.fields(\n            Projections.computed(\"numericalRating\", rating\n                .isNumberOr(of(1)))\n)))\n"
        }
      ],
      "preview": "In this guide, you can learn how to use the MongoDB Kotlin Driver to construct\nexpressions for use in aggregation pipelines. You can perform\nexpression operations with discoverable, typesafe Java methods rather\nthan BSON documents. Because these methods follow the fluent interface\npattern, you can chain aggregation operations together to create code\nthat is both more compact and more naturally readable.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/aggregation",
      "title": "Aggregation",
      "headings": [
        "Overview",
        "Aggregation and Find Operations Compared",
        "Useful References",
        "Example Data",
        "Basic Aggregation",
        "Explain Aggregation",
        "Aggregation Expressions"
      ],
      "paragraphs": "In this guide, you can learn how to use  aggregation operations  in the MongoDB Kotlin driver. Aggregation operations process data in your MongoDB collections and return computed results. MongoDB's Aggregation\npipeline, part of the Query API, is modeled on the concept of data processing pipelines. Documents enter a multi-staged pipeline that\ntransforms the documents into an aggregated result. Another way to think of aggregation is like a car factory. Within the car factory is an assembly line, along which\nare assembly stations with specialized tools to do a specific job, like drills and welders. Raw parts enter the factory,\nwhich are then transformed and assembled into a finished product. The  aggregation pipeline  is the assembly line,  aggregation stages  are the assembly stations, and\n operator expressions  are the specialized tools. Using  find  operations, you can: Using  aggregation  operations, you can: Aggregation operations have some  limitations  you must keep in mind: select  what  documents to return select  what  fields to return sort the results perform all  find  operations rename fields calculate fields summarize data group values Returned documents must not violate the  BSON document size limit \nof 16 megabytes. Pipeline stages have a memory limit of 100 megabytes by default. If required,\nyou may exceed this limit by using the\n allowDiskUse \nmethod. The  $graphLookup  stage has a strict memory limit of 100 megabytes\nand will ignore  allowDiskUse . Aggregation pipeline Aggregation stages Operator expressions Aggregation Builders The examples use a collection of the following data in MongoDB: The data in the collection is modeled by the following  Restaurant  data class: To perform an aggregation, pass a list of aggregation stages to the\n MongoCollection.aggregate()  method. The Kotlin driver provides the\n Aggregates \nhelper class that contains builders for aggregation stages. In the following example, the aggregation pipeline: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Uses a  $match  stage to filter for documents whose\n categories  array field contains the element  Bakery . The example uses\n Aggregates.match  to build the  $match  stage. Uses a  $group  stage to group the matching documents by the  stars \nfield, accumulating a count of documents for each distinct value of  stars . You can build the expressions used in this example using the  aggregation builders . MongoCollection.aggregate() Aggregates.match To view information about how MongoDB executes your operation, use the\n explain()  method of the  AggregateFlow  class. The  explain() \nmethod returns  execution plans  and performance statistics. An execution\nplan is a potential way MongoDB can complete an operation.\nThe  explain()  method provides both the winning plan (the plan MongoDB\nexecuted) and rejected plans. In the following example, we print the JSON representation of the\nwinning plans for aggregation stages that produce execution plans: For more information about the topics mentioned in this section, see the\nfollowing resources: You can specify the level of detail of your explanation by passing a\nverbosity level to the  explain()  method. The following table shows all verbosity levels for explanations and\ntheir intended use cases: Verbosity Level Use Case ALL_PLANS_EXECUTIONS You want to know which plan MongoDB will choose to run your query. EXECUTION_STATS You want to know if your query is performing well. QUERY_PLANNER You have a problem with your query and you want as much information\nas possible to diagnose the issue. Explain Output  Server Manual Entry Query Plans  Server Manual Entry ExplainVerbosity  API Documentation explain()  API Documentation AggregateFlow  API Documentation The Kotlin driver provides builders for accumulator expressions for use with\n $group . You must declare all other expressions in JSON format or\ncompatible document format. In the following example, the aggregation pipeline uses a\n $project  stage and various  Projections  to return the  name \nfield and the calculated field  firstCategory  whose value is the\nfirst element in the  categories  field. For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: The syntax in either of the following examples will define an  $arrayElemAt \nexpression. The  $  in front of \"categories\" tells MongoDB that this is a  field path ,\nusing the \"categories\" field from the input document. Accumulators $group $project Projections",
      "code": [
        {
          "lang": "json",
          "value": "[\n   {\"name\": \"Sun Bakery Trattoria\", \"contact\": {\"phone\": \"386-555-0189\", \"email\": \"SunBakeryTrattoria@example.org\", \"location\": [-74.0056649, 40.7452371]}, \"stars\": 4, \"categories\": [\"Pizza\", \"Pasta\", \"Italian\", \"Coffee\", \"Sandwiches\"]},\n   {\"name\": \"Blue Bagels Grill\", \"contact\": {\"phone\": \"786-555-0102\", \"email\": \"BlueBagelsGrill@example.com\", \"location\": [-73.92506, 40.8275556]}, \"stars\": 3, \"categories\": [\"Bagels\", \"Cookies\", \"Sandwiches\"]},\n   {\"name\": \"XYZ Bagels Restaurant\", \"contact\": {\"phone\": \"435-555-0190\", \"email\": \"XYZBagelsRestaurant@example.net\", \"location\": [-74.0707363, 40.59321569999999]}, \"stars\": 4, \"categories\": [\"Bagels\", \"Sandwiches\", \"Coffee\"]},\n   {\"name\": \"Hot Bakery Cafe\", \"contact\": {\"phone\": \"264-555-0171\", \"email\": \"HotBakeryCafe@example.net\", \"location\": [-73.96485799999999, 40.761899]}, \"stars\": 4, \"categories\": [\"Bakery\", \"Cafe\", \"Coffee\", \"Dessert\"]},\n   {\"name\": \"Green Feast Pizzeria\", \"contact\": {\"phone\": \"840-555-0102\", \"email\": \"GreenFeastPizzeria@example.com\", \"location\": [-74.1220973, 40.6129407]}, \"stars\": 2, \"categories\": [\"Pizza\", \"Italian\"]},\n   {\"name\": \"ZZZ Pasta Buffet\", \"contact\": {\"phone\": \"769-555-0152\", \"email\": \"ZZZPastaBuffet@example.com\", \"location\": [-73.9446421, 40.7253944]}, \"stars\": 0, \"categories\": [\"Pasta\", \"Italian\", \"Buffet\", \"Cafeteria\"]},\n   {\"name\": \"XYZ Coffee Bar\", \"contact\": {\"phone\": \"644-555-0193\", \"email\": \"XYZCoffeeBar@example.net\", \"location\": [-74.0166091, 40.6284767]}, \"stars\": 5, \"categories\": [\"Coffee\", \"Cafe\", \"Bakery\", \"Chocolates\"]},\n   {\"name\": \"456 Steak Restaurant\", \"contact\": {\"phone\": \"990-555-0165\", \"email\": \"456SteakRestaurant@example.com\", \"location\": [-73.9365108, 40.8497077]}, \"stars\": 0, \"categories\": [\"Steak\", \"Seafood\"]},\n   {\"name\": \"456 Cookies Shop\", \"contact\": {\"phone\": \"604-555-0149\", \"email\": \"456CookiesShop@example.org\", \"location\": [-73.8850023, 40.7494272]}, \"stars\": 4, \"categories\": [\"Bakery\", \"Cookies\", \"Cake\", \"Coffee\"]},\n   {\"name\": \"XYZ Steak Buffet\", \"contact\": {\"phone\": \"229-555-0197\", \"email\": \"XYZSteakBuffet@example.org\", \"location\": [-73.9799932, 40.7660886]}, \"stars\": 3, \"categories\": [\"Steak\", \"Salad\", \"Chinese\"]}\n]"
        },
        {
          "lang": "kotlin",
          "value": "data class Restaurant(\n    val name: String,\n    val contact: Contact,\n    val stars: Int,\n    val categories: List<String>\n) {\n    data class Contact(\n        val phone: String,\n        val email: String,\n        val location: List<Double>\n    )\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(@BsonId val id: Int, val count: Int)\n\nval resultsFlow = collection.aggregate<Results>(\n    listOf(\n        Aggregates.match(Filters.eq(Restaurant::categories.name, \"Bakery\")),\n        Aggregates.group(\"\\$${Restaurant::stars.name}\",\n            Accumulators.sum(\"count\", 1))\n    )\n)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": null,
          "value": "Results(id=4, count=2)\nResults(id=5, count=1)"
        },
        {
          "lang": "kotlin",
          "value": "data class Results (val name: String, val count: Int)\n\nval explanation = collection.aggregate<Results>(\n    listOf(\n        Aggregates.match(Filters.eq(Restaurant::categories.name, \"bakery\")),\n        Aggregates.group(\"\\$${Restaurant::stars.name}\", Accumulators.sum(\"count\", 1))\n    )\n).explain(ExplainVerbosity.EXECUTION_STATS)\n\n// Prettyprint the output\nprintln(explanation.toJson(JsonWriterSettings.builder().indent(true).build()))\n"
        },
        {
          "lang": "javascript",
          "value": "{\n   \"explainVersion\": \"2\",\n   \"queryPlanner\": {\n      // ...\n   },\n   \"command\": {\n      // ...\n   },\n   // ...\n}"
        },
        {
          "lang": "kotlin",
          "value": "Document(\"\\$arrayElemAt\", listOf(\"\\$categories\", 0))\n// is equivalent to\nDocument.parse(\"{ \\$arrayElemAt: ['\\$categories', 0] }\")\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(val name: String, val firstCategory: String)\n\nval resultsFlow = collection.aggregate<Results>(\n    listOf(\n        Aggregates.project(\n            Projections.fields(\n                Projections.excludeId(),\n                Projections.include(\"name\"),\n                Projections.computed(\n                    \"firstCategory\",\n                    Document(\"\\$arrayElemAt\", listOf(\"\\$categories\", 0))\n                )\n            )\n        )\n    )\n)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(name=Sun Bakery Trattoria, firstCategory=Pizza)\nResults(name=Blue Bagels Grill, firstCategory=Bagels)\nResults(name=XYZ Bagels Restaurant, firstCategory=Bagels)\nResults(name=Hot Bakery Cafe, firstCategory=Bakery)\nResults(name=Green Feast Pizzeria, firstCategory=Pizza)\nResults(name=ZZZ Pasta Buffet, firstCategory=Pasta)\nResults(name=XYZ Coffee Bar, firstCategory=Coffee)\nResults(name=456 Steak Restaurant, firstCategory=Steak)\nResults(name=456 Cookies Shop, firstCategory=Bakery)\nResults(name=XYZ Steak Buffet, firstCategory=Steak)"
        }
      ],
      "preview": "In this guide, you can learn how to use aggregation operations in the MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/auth",
      "title": "Authentication Mechanisms",
      "headings": [
        "Overview",
        "Specify an Authentication Mechanism",
        "Mechanisms",
        "Default",
        "SCRAM-SHA-256",
        "SCRAM-SHA-1",
        "MONGODB-CR",
        "MONGODB-AWS",
        "AWS SDK",
        "Specify Your Credentials in the Environment",
        "Specify Your Credentials in a MongoCredential",
        "X.509"
      ],
      "paragraphs": "In this guide, you can learn how to authenticate with MongoDB using each\n authentication mechanism  available in the MongoDB Community Edition.\nAuthentication mechanisms are processes by which the driver and server\nconfirm identity and establish trust to ensure security. The mechanisms that you can use with the latest version of MongoDB Community\nEdition are as follows: To authenticate using  Kerberos  or  LDAP , see the\n Enterprise Authentication Mechanisms guide . For more information on establishing a connection to your MongoDB cluster,\nread our  Connection Guide . Default SCRAM-SHA-256 SCRAM-SHA-1 MONGODB-CR MONGODB-AWS X.509 You can specify your authentication mechanism and credentials when connecting\nto MongoDB using either of the following: A  connection string  (also known as a  connection URI ) specifies how to\nconnect and authenticate to your MongoDB cluster. To authenticate using a connection string, include your settings in your\nconnection string and pass it to the  MongoClient.create()  method to\ninstantiate your  MongoClient . The  Connection String \ntab in each section provides the syntax for authenticating using a\n connection string . Alternatively, you can use the  MongoCredential  class to specify your\nauthentication details. The  MongoCredential  class contains static factory\nmethods that construct instances containing your authentication mechanism and\ncredentials. When you use the  MongoCredential  helper class, you need\nto use the  MongoClientSettings.Builder  class to configure your\nconnection settings when constructing your  MongoClient .  The\n MongoCredential  tab in each section provides the syntax for\nauthenticating using a  MongoCredential . For more information on these classes and methods, refer to the following API\ndocumentation: A connection string A  MongoCredential  factory method MongoClient.create() MongoClient MongoClientSettings.Builder MongoCredential The default authentication mechanism setting uses one of the following\nauthentication mechanisms depending on what your MongoDB server supports: Server versions 3.6 and earlier use  MONGODB-CR  as the default\nmechanism. Newer versions of the server use one of the mechanisms for\nwhich they advertise support. The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: For more information on the challenge-response (CR) and salted\nchallenge-response authentication mechanisms (SCRAM) that MongoDB supports,\nsee the  SCRAM  section of the Server manual. SCRAM-SHA-256 SCRAM-SHA-1 MONGODB-CR db_username  - your MongoDB database username db_password  - your MongoDB database user's password hostname  - network address of your MongoDB server, accessible by your client port  - port number of your MongoDB server authenticationDb  - MongoDB database that contains your user's\nauthentication data. If you omit this parameter, the driver uses the\ndefault value  admin . To specify the default authentication mechanism using a connection\nstring, omit the mechanism. Your code to instantiate a  MongoClient \nshould resemble the following: To specify the default authentication mechanism using the\n MongoCredential  class, use the  createCredential()  method. Your\ncode to instantiate a  MongoClient  should resemble the following: SCRAM-SHA-256  is a salted challenge-response authentication mechanism\n(SCRAM) that uses your username and password, encrypted with the  SHA-256 \nalgorithm, to authenticate your user. The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: SCRAM-SHA-256  is the default authentication method for MongoDB starting\nin MongoDB 4.0. db_username  - your MongoDB database username. db_password  - your MongoDB database user's password. hostname  - network address of your MongoDB server, accessible by your client. port  - port number of your MongoDB server. authenticationDb  - MongoDB database that contains your user's\nauthentication data. If you omit this parameter, the driver uses the\ndefault value  admin . To specify the  SCRAM-SHA-256  authentication mechanism using a\nconnection string, assign the  authMechanism  parameter the value\n SCRAM-SHA-256  in your connection string. Your code to instantiate\na  MongoClient  should resemble the following: To specify the default authentication mechanism using the\n MongoCredential  class, use the\n createScramSha256Credential() \nmethod. Your code to instantiate a  MongoClient  should resemble the following: SCRAM-SHA-1  is a salted challenge-response mechanism (SCRAM) that uses your\nusername and password, encrypted with the  SHA-1  algorithm, to authenticate\nyour user. The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: SCRAM-SHA-1  is the default authentication method for MongoDB versions\n3.0, 3.2, 3.4, and 3.6. db_username  - your MongoDB database username. db_password  - your MongoDB database user's password. hostname  - network address of your MongoDB server, accessible by your client. port  - port number of your MongoDB server. authenticationDb  - MongoDB database that contains your user's\nauthentication data. If you omit this parameter, the driver uses the\ndefault value  admin . To specify the  SCRAM-SHA-1  authentication mechanism using a\nconnection string, assign the  authMechanism  parameter the value\n SCRAM-SHA-1  in your connection string. Your code to instantiate\na  MongoClient  should resemble the following: To specify the default authentication mechanism using the\n MongoCredential  class, use the\n createScramSha1Credential() \nmethod. Your code to instantiate a  MongoClient  should resemble the following: MONGODB-CR  is a challenge-response authentication mechanism that uses your\nusername and password to authenticate your user. This authentication\nmechanism was deprecated starting in MongoDB 3.6 and is no longer\nsupported as of MongoDB 4.0. You cannot specify this method explicitly; refer to the fallback provided\nby the  default authentication mechanism  to\nconnect using  MONGODB-CR . The  MONGODB-AWS  authentication mechanism uses your Amazon Web Services\nIdentity and Access Management (AWS IAM) credentials to authenticate your\nuser. To learn more about configuring MongoDB Atlas, see the\n Set Up Passwordless Authentication with AWS IAM Roles \nguide. To instruct the driver to use this authentication mechanism, you can specify\n MONGODB-AWS  either as a parameter in the connection string or by using\nthe  MongoCredential.createAwsCredential()  factory method. Learn how to specify this authentication mechanism and the various ways to\nprovide your AWS IAM credentials in the next sections. These sections contain code examples that use the following placeholders: The MONGODB-AWS authentication mechanism is available for MongoDB\ndeployments on MongoDB Atlas. awsKeyId  - value of your AWS access key ID awsSecretKey  - value of your AWS secret access key atlasUri  - network address of your MongoDB Atlas deployment hostname  - hostname of your MongoDB Atlas deployment port  - port of your MongoDB Atlas deployment awsSessionToken  - value of your AWS session token You can use one of the AWS SDK for Java v1 or v2 to specify your credentials.\nThis method offers the following features: To use the AWS SDK for Java for  MONGODB-AWS  authentication, you must\nperform the following: To specify the authentication mechanism by using a  MongoCredential ,\nuse the  MongoCredential.createAwsCredential()  factory method\nand add the  MongoCredential  instance to your  MongoClient  as shown\nin the following example: To specify the authentication mechanism in the connection string, add\nit as a parameter as shown in the following example: To add the AWS SDK as a dependency to your project, see the following\nAWS documentation for the version you need: To supply your credentials, see the following AWS documentation for the\nversion you need: Multiple options for obtaining credentials Credential caching which helps your application avoid rate limiting Credential provider management for use with the  Elastic Kubernetes Service . Specify the authentication mechanism Add the SDK as a dependency to your project Supply your credentials using one of the methods in the credential\nprovider chain For the  AWS SDK for Java v2 , see the  Setting Up \nguide. For the  AWS SDK for Java v1 , see the  Getting Started \nguide. For the AWS SDK for Java v2, the Java driver currently tests using the\n software.amazon.awssdk:auth:2.18.9  dependency. For the AWS SDK for Java v1, the Java driver currently tests using the\n com.amazonaws:aws-java-sdk-core:1.12.337  dependency. To learn more about the  AWS SDK for Java v2  class the driver uses to\nget the credentials, see the  DefaultCredentialsProvider \nAPI documentation. Learn how to supply your credentials to this class from the\n Use the default credential provider chain \nsection. To learn more about the  AWS SDK for Java v1  class the driver uses to\nget the credentials, see the  DefaultAWSCredentialsProviderChain \nAPI documentation. Learn how to supply your credentials to this class from the\n Using the Default Credential Provider Chain \nsection. If you include both v1 and v2 of the AWS SDK for Java in your project,\nyou must use the v2 methods to supply your credentials. You can provide your AWS IAM credentials by instructing the driver to\nuse the  MONGODB-AWS  authentication mechanism and by setting the\nappropriate environment variables. To use the environment variables to supply your credentials, you must perform\nthe following: You can specify the authentication mechanism by using a  MongoCredential \nor on the connection string. To specify the authentication mechanism by using a  MongoCredential ,\nuse the  MongoCredential.createAwsCredential()  factory method and add the\n MongoCredential  instance to your  MongoClient  as shown in the following\nexample: To specify the authentication mechanism in the connection string, add it as a\nparameter as shown in the following example: The next examples show how to provide your credentials by setting environment\nvariables for the following types of authentication: The following example shows how you can set your  programmatic access keys \nin environment variables by using  bash  or a similar shell: Omit the line containing  AWS_SESSION_TOKEN  if you don't need an AWS\nsession token for that role. To authenticate by using  ECS container credentials , set the ECS\nendpoint relative URI in an environment variable by using  bash  or\na similar shell as shown in the following example: To authenticate using  EC2 container credentials , make sure none of the\naforementioned environment variables are set. The driver obtains the\ncredentials from the default IPv4 EC2 instance metadata endpoint. Specify the authentication mechanism Add the appropriate environment variables Programmatic access keys ECS container credentials EC2 container credentials You can supply your AWS IAM credentials to a  MongoClient  by using a\n MongoCredential  instance. To construct the  MongoCredential  instance\nfor  MONGODB-AWS  authentication,  use the  createAwsCredential() \nfactory method. You can supply only programmatic access keys to the\n MongoCredential.createAwsCredential()  method. If you need to supply ECS\nor EC2 container credentials, use the instructions in\n Specify Your Credentials in the Environment  or  AWS SDK . To use the  MongoCredential  for  MONGODB-AWS  authentication, you\nmust perform the following: To specify the authentication mechanism by using a  MongoCredential ,\nuse the  MongoCredential.createAwsCredential()  factory method\nand add the  MongoCredential  instance to your  MongoClient  as shown\nin the following example: If you need to specify an AWS session token, pass it to the\n withMechanismProperty() \nmethod as shown in the following example: To refresh your credentials, you can declare a  Supplier  lambda expression\nthat returns new credentials as shown in the following example: If you must provide AWS IAM credentials in a connection string, you can add\nit to your  MongoClientSettings  by calling the  applyConnectionString() \nmethod: Specify the authentication mechanism Supply the credentials The  X.509  authentication mechanism uses\n TLS  with X.509 certificates to\nauthenticate your user, identified by the relative distinguished names\n(RDNs) of your client certificate. When you specify the  X.509 \nauthentication mechanism, the server authenticates the connection using\nthe subject name of the client certificate. The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: For additional information on configuring your application to use\ncertificates as well as TLS/SSL options, see our\n TLS/SSL guide . hostname  - network address of your MongoDB server, accessible by your client. port  - port number of your MongoDB server. authenticationDb  - MongoDB database that contains your user's\nauthentication data. If you omit this parameter, the driver uses the\ndefault value  admin . To specify the  X.509  authentication mechanism using a connection\nstring, assign the  authMechanism  parameter the value  MONGODB-X509 \nand enable TLS by assigning the  tls \nparameter a  true  value. Your code to instantiate a  MongoClient \nshould resemble the following: To specify the  X.509  authentication mechanism using the\n MongoCredential  class, use the\n createMongoX509Credential() \nmethod. Also, enable TLS by calling the\n applyToSslSettings() \nmethod and setting the  enabled  property to  true  in the\n SslSettings.Builder \nblock. Your code to instantiate a  MongoClient  should resemble the following:",
      "code": [
        {
          "lang": "kotlin",
          "value": "val mongoClient =\n    MongoClient.create(\"mongodb://<db_username>:<db_password>@<hostname>:<port>/?authSource=<authenticationDb>\")\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createCredential(\n    \"<db_username>\", \"<authenticationDb>\", \"<db_password>\".toCharArray()\n)\nval settings = MongoClientSettings.builder()\n        .applyToClusterSettings { builder: ClusterSettings.Builder ->\n            builder.hosts(\n                listOf(ServerAddress(\"<hostname>\", \"<port>\"))\n            )\n        }\n        .credential(credential)\n        .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient =\n    MongoClient.create(\"mongodb://<db_username>:<db_password>@<hostname>:<port>/?authSource=<authenticationDb>&authMechanism=SCRAM-SHA-256\")\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createScramSha256Credential(\n    \"<db_username>\", \"<authenticationDb>\", \"<db_password>\".toCharArray()\n)\nval settings = MongoClientSettings.builder()\n        .applyToClusterSettings { builder: ClusterSettings.Builder ->\n            builder.hosts(\n                listOf(ServerAddress(\"<hostname>\", \"<port>\"))\n            )\n        }\n        .credential(credential)\n        .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient =\n    MongoClient.create(\"mongodb://<db_username>:<db_password>@<hostname>:<port>/?authSource=<authenticationDb>&authMechanism=SCRAM-SHA-1\")\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createScramSha1Credential(\n    \"<db_username>\", \"<authenticationDb>\", \"<db_password>\".toCharArray()\n)\nval settings = MongoClientSettings.builder()\n        .applyToClusterSettings { builder: ClusterSettings.Builder ->\n            builder.hosts(\n                listOf(ServerAddress(\"<hostname>\", \"<port>\"))\n            )\n        }\n        .credential(credential)\n        .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createAwsCredential(null, null)\n\nval settings = MongoClientSettings.builder()\n    .applyToClusterSettings { builder: ClusterSettings.Builder ->\n        builder.hosts(\n            listOf(ServerAddress(\"<atlasUri>\"))\n        )\n    }\n    .credential(credential)\n    .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient =\n    MongoClient.create(\"mongodb://<atlasUri>?authMechanism=MONGODB-AWS\")\n"
        },
        {
          "lang": "bash",
          "value": "export AWS_ACCESS_KEY_ID=<awsKeyId>\nexport AWS_SECRET_ACCESS_KEY=<awsSecretKey>\nexport AWS_SESSION_TOKEN=<awsSessionToken>"
        },
        {
          "lang": "bash",
          "value": "export AWS_CONTAINER_CREDENTIALS_RELATIVE_URI=<your ECS endpoint>"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createAwsCredential(null, null)\n\nval settings = MongoClientSettings.builder()\n    .applyToClusterSettings { builder: ClusterSettings.Builder ->\n        builder.hosts(\n            listOf(ServerAddress(\"<atlasUri>\"))\n        )\n    }\n    .credential(credential)\n    .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient =\n    MongoClient.create(\"mongodb://<atlasUri>?authMechanism=MONGODB-AWS\")\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createAwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\".toCharArray())\n\nval settings = MongoClientSettings.builder()\n        .applyToClusterSettings { builder: ClusterSettings.Builder ->\n            builder.hosts(\n                listOf(ServerAddress(\"<atlasUri>\"))\n            )\n        }\n        .credential(credential)\n        .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createAwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\".toCharArray())\n    .withMechanismProperty(\"AWS_SESSION_TOKEN\", \"<awsSessionToken>\")\n\nval settings = MongoClientSettings.builder()\n        .applyToClusterSettings { builder: ClusterSettings.Builder ->\n            builder.hosts(\n                listOf(ServerAddress(\"<atlasUri>\"))\n            )\n        }\n        .credential(credential)\n        .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val awsFreshCredentialSupplier: Supplier<AwsCredential> = Supplier {\n    // Add your code here to fetch new credentials\n\n    // Return the new credentials\n    AwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\", \"<awsSessionToken>\")\n}\n\nval credential = MongoCredential.createAwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\".toCharArray())\n    .withMechanismProperty(MongoCredential.AWS_CREDENTIAL_PROVIDER_KEY, awsFreshCredentialSupplier)\n\nval settings = MongoClientSettings.builder()\n    .applyToClusterSettings { builder ->\n        builder.hosts(listOf(ServerAddress(\"<hostname>\", \"<port>\")))\n    }\n    .credential(credential)\n    .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createAwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\".toCharArray())\nval connectionString = ConnectionString(\"mongodb://<atlasUri>/?authMechanism=MONGODB-AWS&authMechanismProperties=AWS_SESSION_TOKEN:<awsSessionToken>\")\n\nval settings = MongoClientSettings.builder()\n    .applyConnectionString(connectionString)\n    .credential(credential)\n    .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient =\n    MongoClient.create(\"mongodb://<db_username>:<db_password>@<hostname>:<port>/?authSource=<authenticationDb>&authMechanism=MONGODB-X509&tls=true\")\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createMongoX509Credential()\n\nval settings = MongoClientSettings.builder()\n    .applyToClusterSettings { builder ->\n        builder.hosts(listOf(\n            ServerAddress(\"<hostname>\", \"<port>\"))\n        )\n    }\n    .applyToSslSettings { builder ->\n        builder.enabled(true)\n    }\n    .credential(credential)\n    .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        }
      ],
      "preview": "In this guide, you can learn how to authenticate with MongoDB using each\nauthentication mechanism available in the MongoDB Community Edition.\nAuthentication mechanisms are processes by which the driver and server\nconfirm identity and establish trust to ensure security.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/builders/aggregates",
      "title": "Aggregates Builders",
      "headings": [
        "Overview",
        "Match",
        "Project",
        "Projecting Computed Fields",
        "Documents",
        "Sample",
        "Sort",
        "Skip",
        "Limit",
        "Lookup",
        "Left Outer Join",
        "Full Join and Uncorrelated Subqueries",
        "Group",
        "Pick-N Accumulators",
        "MinN",
        "MaxN",
        "FirstN",
        "LastN",
        "Top",
        "TopN",
        "Bottom",
        "BottomN",
        "Unwind",
        "Out",
        "Merge",
        "GraphLookup",
        "SortByCount",
        "ReplaceRoot",
        "AddFields",
        "Count",
        "Bucket",
        "BucketAuto",
        "Facet",
        "SetWindowFields",
        "Densify",
        "Fill",
        "Atlas Full-Text Search",
        "Atlas Search Metadata",
        "Atlas Vector Search"
      ],
      "paragraphs": "In this guide, you can learn how to use the  Aggregates \nclass which provides static factory methods that build  aggregation pipeline\nstages  in the MongoDB Kotlin driver. For a more thorough introduction to Aggregation, see our  Aggregation guide . The examples on this page assume imports for methods of the following classes: Use these methods to construct pipeline stages and specify them in your\naggregation as a list: Many  Aggregation  examples in this guide use the  Atlas sample_mflix.movies dataset . The documents in this collection are\nmodeled by the following  Movie  data class for use with the Kotlin driver: Aggregates Filters Projections Sorts Accumulators Use the  match()  method to create a  $match \npipeline stage that matches incoming documents against the specified\nquery filter, filtering out documents that do not match. The following example creates a pipeline stage that matches all documents\nin the  movies  collection where the\n title  field is equal to \"The Shawshank Redemption\": The filter can be an instance of any class that implements  Bson , but it's\nconvenient to combine with use of the  Filters  class.\nclass. Use the  project()  method to create a  $project \npipeline stage that project specified document fields. Field projection\nin aggregation follows the same rules as  field projection in queries . The following example creates a pipeline stage that includes the  title  and\n plot  fields but excludes the  _id  field: Though the projection can be an instance of any class that implements  Bson ,\nit's convenient to combine with use of  Projections . The  $project  stage can project computed fields as well. The following example creates a pipeline stage that projects the  rated  field\ninto a new field called  rating , effectively renaming the field: Use the  documents()  method to create a\n $documents \npipeline stage that returns literal documents from input values. The following example creates a pipeline stage that creates\nsample documents in the  movies  collection with a  title  field: If you use a  $documents  stage in an aggregation pipeline, it must be the first\nstage in the pipeline. If you use the  documents()  method to provide the input to an aggregation pipeline,\nyou must call the  aggregate()  method on a database instead of on a\ncollection. Use the  sample()  method to create a  $sample \npipeline stage to randomly select documents from input. The following example creates a pipeline stage that randomly selects 5 documents\nfrom the  movies  collection: Use the  sort()  method to create a   $sort \npipeline stage to sort by the specified criteria. The following example creates a pipeline stage that sorts in descending order according\nto the value of the  year  field and then in ascending order according to the\nvalue of the  title  field: Though the sort criteria can be an instance of any class that\nimplements  Bson , it's convenient to combine with use of\n Sorts . Use the  skip()  method to create a  $skip \npipeline stage to skip over the specified number of documents before\npassing documents into the next stage. The following example creates a pipeline stage that skips the first  5  documents\nin the  movies  collection: Use the  $limit  pipeline stage\nto limit the number of documents passed to the next stage. The following example creates a pipeline stage that limits the number of documents\nreturned from the  movies  collection to  4 : Use the  lookup()  method to create a  $lookup \npipeline stage to perform joins and uncorrelated subqueries between two collections. The following example creates a pipeline stage that performs a left outer\njoin between the  movies  and  comments  collections in the sample  mflix \ndatabase: It joins the  _id  field from  movies  to the  movie_id  field in  comments It outputs the results in the  joined_comments  field The following example uses the fictional  orders  and  warehouses  collections.\nThe data is modeled using the following Kotlin data classes: The example creates a pipeline stage that joins the two collections by the item\nand whether the available quantity in  inStock  field is enough to fulfill\nthe  ordered  quantity: Use the  group()  method to create a  $group \npipeline stage to group documents by a specified expression and output a document\nfor each distinct grouping. The following example creates a pipeline stage that groups documents\nin the  orders  collection by the value of the  customerId  field.\nEach group accumulates the sum and average\nof the values of the  ordered  field into the  totalQuantity  and\n averageQuantity  fields: Learn more about accumulator operators from the Server manual section\non  Accumulators . The driver includes the  Accumulators \nclass with static factory methods for each of the supported accumulators. The pick-n accumulators are aggregation accumulation operators that return\nthe top and bottom elements given a specific ordering. Use one of the\nfollowing builders to create an aggregation accumulation operator: Learn which aggregation pipeline stages you can use accumulator operators with\nfrom the Server manual section on\n Accumulators . The pick-n accumulator examples use documents from the  movies  collection\nin the  sample-mflix  database. minN() maxN() firstN() lastN() top() topN() bottom() bottomN() You can only perform aggregation operations with these pick-n accumulators\nwhen running MongoDB v5.2 or later. The  minN()  builder creates the  $minN \naccumulator which returns data from documents that contain the  n  lowest\nvalues of a grouping. The following example demonstrates how to use the  minN()  method to return\nthe lowest three  imdb.rating  values for movies, grouped by  year : See the  minN() API documentation \nfor more information. The  $minN  and  $bottomN  accumulators can perform similar tasks.\nSee\n Comparison of $minN and $bottomN Accumulators \nfor recommended usage of each. The  maxN()  accumulator returns data from documents that contain the  n \nhighest values of a grouping. The following example demonstrates how to use the  maxN()  method to\nreturn the highest two  imdb.rating  values for movies, grouped by  year : See the  maxN() API documentation \nfor more information. The  firstN()  accumulator returns data from the first  n  documents in\neach grouping for the specified sort order. The following example demonstrates how to use the  firstN()  method to\nreturn the first two movie  title  values, based on the order they came\ninto the stage, grouped by  year : See the  firstN() API documentation \nfor more information. The  $firstN  and  $topN  accumulators can perform similar tasks.\nSee\n Comparison of $firstN and $topN Accumulators \nfor recommended usage of each. The  lastN()  accumulator returns data from the last  n  documents in\neach grouping for the specified sort order. The following example demonstrates how to use the  lastN()  method to show\nthe last three movie  title  values, based on the the order they came into\nthe stage, grouped by  year : See the  lastN() API documentation \nfor more information. The  top()  accumulator returns data from the first document in a group\nbased on the specified sort order. The following example demonstrates how to use the  top()  method to return\nthe  title  and  imdb.rating  values for the top rated movies based on the\n imdb.rating , grouped by  year . See the  top() API documentation \nfor more information. The  topN()  accumulator returns data from documents that contain the\nhighest  n  values for the specified field. The following example demonstrates how to use the  topN()  method to return\nthe  title  and  runtime  values of the three longest movies based on the\n runtime  values, grouped by  year . See the  topN() API documentation \nfor more information. The  $firstN  and  $topN  accumulators can perform similar tasks.\nSee\n Comparison of $firstN and $topN Accumulators \nfor recommended usage of each. The  bottom()  accumulator returns data from the last document in a group\nbased on the specified sort order. The following example demonstrates how to use the  bottom()  method to\nreturn the  title  and  runtime  values of the shortest movie based on the\n runtime  value, grouped by  year . See the  bottom() API documentation \nfor more information. The  bottomN()  accumulator returns data from documents that contain the\nlowest  n  values for the specified field. The following example demonstrates how to use the  bottomN()  method to\nreturn the  title  and  imdb.rating  values of the two lowest rated movies\nbased on the  imdb.rating  value, grouped by  year : See the  bottomN() API documentation \nfor more information. The  $minN  and  $bottomN  accumulators can perform similar tasks.\nSee  Comparison of $minN and $bottomN Accumulators \nfor recommended usage of each. Use the  unwind()  method to create an  $unwind \npipeline stage to deconstruct an array field from input documents, creating\nan output document for each array element. The following example creates a document for each element in the  lowestRatedTwoMovies  array: To preserve documents that have missing or  null \nvalues for the array field, or where array is empty: To include the array index (in this example, in a field called  \"position\" ): Use the  out()  method to create an  $out \npipeline stage that writes all documents to the specified collection in\nthe same database. The following example writes the results of the pipeline to the  classic_movies \ncollection: The  $out  stage must be the last stage in any aggregation pipeline. Use the  merge()  method to create a  $merge \npipeline stage that merges all documents into the specified collection. The following example merges the pipeline into the  nineties_movies  collection\nusing the default options: The following example merges the pipeline into the  movie_ratings  collection\nin the  aggregation  database using some non-default options that specify to\nreplace the document if both  year  and  title  match, otherwise insert the\ndocument: The  $merge  stage must be the last stage in any aggregation pipeline. Use the  graphLookup()  method to create a  $graphLookup \npipeline stage that performs a recursive search on a specified collection to match\na specified field in one document to a specified field of another document. The following example uses the  contacts  collection. The data is modeled\nusing the following Kotlin data class: The example computes the reporting graph for users in the\n contact  collection, recursively matching the value in the  friends  field\nto the  name  field: Using  GraphLookupOptions , you can specify the depth to recurse as well as\nthe name of the depth field, if desired. In this example,  $graphLookup  will\nrecurse up to two times, and create a field called  degrees  with the\nrecursion depth information for every document. Using  GraphLookupOptions , you can specify a filter that documents must match\nin order for MongoDB to include them in your search. In this\nexample, only links with \"golf\" in their  hobbies  field will be included: Use the  sortByCount()  method to create a  $sortByCount \npipeline stage that groups documents by a given expression and then sorts\nthese groups by count in descending order. The following example groups documents in the  movies  collection by the\n genres  field and computes the count for each distinct value: The  $sortByCount  stage is identical to a  $group  stage with a\n $sum  accumulator followed by a  $sort  stage. Use the  replaceRoot()  method to create a  $replaceRoot \npipeline stage that replaces each input document with the specified document. The following example uses a fictional  books  collection that contains data\nmodeled using the following Kotlin data class: Each input document is replaced by the nested document in the\n spanishTranslation  field: Use the  addFields()  method to create an  $addFields \npipeline stage that adds new fields to documents. The following example adds two new fields,  watched  and  type , to the\ninput documents in the  movie  collection: Use  $addFields  when you do not want to project field inclusion\nor exclusion. Use the  count()  method to create a  $count \npipeline stage that counts the number of documents that enter the stage, and assigns\nthat value to a specified field name. If you do not specify a field,\n count()  defaults the field name to \"count\". The following example creates a pipeline stage that outputs the count of incoming\ndocuments in a field called \"total\": The  $count  stage is syntactic sugar for: Use the  bucket()  method to create a  $bucket \npipeline stage that automates the bucketing of data around predefined boundary\nvalues. The following examples use data modeled with the following Kotlin data class: This example creates a pipeline stage that groups incoming documents based\non the value of their  screenSize  field, inclusive of the lower boundary\nand exclusive of the upper boundary: Use the  BucketOptions  class to specify a default bucket for values\noutside of the specified boundaries, and to specify additional accumulators. The following example creates a pipeline stage that groups incoming documents based\non the value of their  screenSize  field, counting the number of documents\nthat fall within each bucket, pushing the value of  screenSize  into a\nfield called  matches , and capturing any screen sizes greater than \"70\"\ninto a bucket called \"monster\" for monstrously large screen sizes: The driver includes the  Accumulators \nclass with static factory methods for each of the supported accumulators. Use the  bucketAuto()  method to create a  $bucketAuto \npipeline stage that automatically determines the boundaries of each bucket\nin its attempt to distribute the documents evenly into a specified number of buckets. The following examples use data modeled with the following Kotlin data class: This example creates a pipeline stage that will attempt to create and evenly\ndistribute documents into 5 buckets using the value of their  price  field: Use the  BucketAutoOptions  class to specify a  preferred number \nbased scheme to set boundary values, and specify additional accumulators. The following example creates a pipeline stage that will attempt to create and evenly\ndistribute documents into 5 buckets using the value of their  price  field,\nsetting the bucket boundaries at powers of 2 (2, 4, 8, 16, ...). It also counts\nthe number of documents in each bucket, and calculates their average  price \nin a new field called  avgPrice : The driver includes the  Accumulators \nclass with static factory methods for each of the supported accumulators. Use the  facet()  method to create a  $facet \npipeline stage that allows for the definition of parallel pipelines. The following examples use data modeled with the following Kotlin data class: This example creates a pipeline stage that executes two parallel aggregations: The first aggregation distributes incoming documents into 5 groups according to\ntheir  screenSize  field. The second aggregation counts all manufacturers and returns their count, limited\nto the top 5. Use the  setWindowFields()  method to create a  $setWindowFields \npipeline stage that allows using window operators to perform operations\non a specified span of documents in a collection. The following example uses a fictional  weather  collection using data modeled\nwith the following Kotlin data class: The example creates a pipeline stage that computes the\naccumulated rainfall and the average temperature over the past month for\neach locality from more fine-grained measurements presented in the  rainfall \nand  temperature  fields: The driver includes the  Windows \nclass with static factory methods for building windowed computations. Use the  densify()  method to create a\n $densify \npipeline stage that generates a sequence of documents to span a specified\ninterval. Consider the following documents retrieved from the  Atlas sample weather dataset \nthat contain measurements for a similar  position  field, spaced one hour\napart: These documents are modeled using the following Kotlin data class: Suppose you needed to create a pipeline stage that performs the following\nactions on these documents: The call to the  densify()  aggregation stage builder that accomplishes\nthese actions should resemble the following: The following output highlights the documents generated by the aggregate stage\nwhich contain  ts  values every 15 minutes between the existing documents: See the  densify package API documentation \nfor more information. You can use the  $densify()  aggregation stage only when running\nMongoDB v5.1 or later. Add a document at every 15-minute interval for which a  ts  value does not\nalready exist. Group the documents by the  position  field. Use the  fill()  method to create a\n $fill \npipeline stage that populates  null  and missing field values. Consider the following documents that contain temperature and air pressure\nmeasurements at an hourly interval: These documents are modeled using the following Kotlin data class: Suppose you needed to populate missing temperature and air pressure\ndata points in the documents as follows: The call to the  fill()  aggregation stage builder that accomplishes\nthese actions resembles the following: See the  fill package API documentation \nfor more information. You can use the  $fill()  aggregation stage only when running\nMongoDB v5.3 or later. Populate the  air_pressure  field for hour \"2\" using linear interpolation\nto calculate the value. Set the missing  temperature  value to \"23.6C\" for hour \"3\". Use the  search()  method to create a  $search \npipeline stage that specifies a full-text search of one or more fields. The following example creates a pipeline stage that searches the  title \nfield in the  movies  collection for text that contains the word \"Future\": Learn more about the builders from the\n search package API documentation . This aggregation pipeline operator is only available for collections hosted\non  MongoDB Atlas  clusters running v4.2 or later that are\ncovered by an  Atlas search index .\nLearn more about the required setup and the functionality of this operator\nfrom the  Atlas Search  documentation. Use the  searchMeta()  method to create a\n $searchMeta \npipeline stage which returns only the metadata part of the results from\nAtlas full-text search queries. The following example shows the  count  metadata for an Atlas search\naggregation stage: Learn more about this helper from the\n searchMeta() API documentation . This aggregation pipeline operator is only available\non  MongoDB Atlas  clusters running v4.4.11 and later. For a\ndetailed list of version availability, see the MongoDB Atlas documentation\non  $searchMeta . Use the  vectorSearch()  method to create a  $vectorSearch \npipeline stage that specifies a  semantic search . A semantic search is\na type of search that locates pieces of information that are similar in meaning. To use this feature when performing an aggregation on a collection, you\nmust create a vector search index and index your vector embeddings. To\nlearn how to set up search indexes in MongoDB Atlas, see  How to\nIndex Vector Embeddings for Vector Search  in the Atlas documentation. The example in this section uses data modeled with the following Kotlin data class: This example shows how to build an aggregation pipeline that uses the\n vectorSearch()  method to perform a vector search with the following\nspecifications: To learn more about this helper, see the\n vectorSearch() API documentation . To learn about which versions of MongoDB Atlas support this feature, see\n Limitations \nin the Atlas documentation. Searches  plotEmbedding  field values by using vector embeddings of a\nstring value Uses the  mflix_movies_embedding_index  vector search index Considers up to 2 nearest neighbors Returns 1 document Filters for documents in which the  year  value is at least  2016",
      "code": [
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Aggregates\nimport com.mongodb.client.model.Filters\nimport com.mongodb.client.model.Projections\nimport com.mongodb.client.model.Sorts\nimport com.mongodb.client.model.Accumulators"
        },
        {
          "lang": "kotlin",
          "value": "val matchStage = Aggregates.match(Filters.eq(\"someField\", \"someCriteria\"))\nval sortByCountStage = Aggregates.sortByCount(\"\\$someField\")\nval results = collection.aggregate(\n    listOf(matchStage, sortByCountStage)).toList()\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Movie(\n    val title: String,\n    val year: Int,\n    val genres: List<String>,\n    val rated: String,\n    val plot: String,\n    val runtime: Int,\n    val imdb: IMDB\n){\n    data class IMDB(\n        val rating: Double\n    )\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.match(Filters.eq(Movie::title.name, \"The Shawshank Redemption\"))\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.project(\n    Projections.fields(\n        Projections.include(Movie::title.name, Movie::plot.name),\n        Projections.excludeId())\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.project(\n    Projections.fields(\n        Projections.computed(\"rating\", \"\\$${Movie::rated.name}\"),\n        Projections.excludeId()\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.documents(\n    listOf(\n        Document(Movie::title.name, \"Steel Magnolias\"),\n        Document(Movie::title.name, \"Back to the Future\"),\n        Document(Movie::title.name, \"Jurassic Park\")\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val docsStage = database.aggregate<Document>( // ... )\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.sample(5)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.sort(\n    Sorts.orderBy(\n        Sorts.descending(Movie::year.name),\n        Sorts.ascending(Movie::title.name)\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.skip(5)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.limit(4)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.lookup(\n    \"comments\",\n    \"_id\",\n    \"movie_id\",\n    \"joined_comments\"\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Order(\n    @BsonId val id: Int,\n    val customerId: Int,\n    val item: String,\n    val ordered: Int\n)\ndata class Inventory(\n    @BsonId val id: Int,\n    val stockItem: String,\n    val inStock: Int\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val variables = listOf(\n    Variable(\"order_item\", \"\\$item\"),\n    Variable(\"order_qty\", \"\\$ordered\")\n)\nval pipeline = listOf(\n    Aggregates.match(\n        Filters.expr(\n            Document(\"\\$and\", listOf(\n                Document(\"\\$eq\", listOf(\"$\\$order_item\", \"\\$${Inventory::stockItem.name}\")),\n                Document(\"\\$gte\", listOf(\"\\$${Inventory::inStock.name}\", \"$\\$order_qty\"))\n            ))\n        )\n    ),\n    Aggregates.project(\n        Projections.fields(\n            Projections.exclude(Order::customerId.name, Inventory::stockItem.name),\n            Projections.excludeId()\n        )\n    )\n)\nval innerJoinLookup =\n    Aggregates.lookup(\"warehouses\", variables, pipeline, \"stockData\")\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.group(\"\\$${Order::customerId.name}\",\n    Accumulators.sum(\"totalQuantity\", \"\\$${Order::ordered.name}\"),\n    Accumulators.avg(\"averageQuantity\", \"\\$${Order::ordered.name}\")\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.group(\n    \"\\$${Movie::year.name}\",\n    Accumulators.minN(\n        \"lowestThreeRatings\",\n        \"\\$${Movie::imdb.name}.${Movie.IMDB::rating.name}\",\n        3\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.group(\n    \"\\$${Movie::year.name}\",\n    Accumulators.maxN(\n        \"highestTwoRatings\",\n        \"\\$${Movie::imdb.name}.${Movie.IMDB::rating.name}\",\n        2\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.group(\n    \"\\$${Movie::year.name}\",\n    Accumulators.firstN(\n        \"firstTwoMovies\",\n        \"\\$${Movie::title.name}\",\n        2\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.group(\n    \"\\$${Movie::year.name}\",\n    Accumulators.lastN(\n        \"lastThreeMovies\",\n        \"\\$${Movie::title.name}\",\n        3\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.group(\n    \"\\$${Movie::year.name}\",\n    Accumulators.top(\n        \"topRatedMovie\",\n        Sorts.descending(\"${Movie::imdb.name}.${Movie.IMDB::rating.name}\"),\n        listOf(\"\\$${Movie::title.name}\", \"\\$${Movie::imdb.name}.${Movie.IMDB::rating.name}\")\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.group(\n    \"\\$${Movie::year.name}\",\n    Accumulators.topN(\n        \"longestThreeMovies\",\n        Sorts.descending(Movie::runtime.name),\n        listOf(\"\\$${Movie::title.name}\", \"\\$${Movie::runtime.name}\"),\n        3\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.group(\n    \"\\$${Movie::year.name}\",\n    Accumulators.bottom(\n        \"shortestMovies\",\n        Sorts.descending(Movie::runtime.name),\n        listOf(\"\\$${Movie::title.name}\", \"\\$${Movie::runtime.name}\")\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.group(\n    \"\\$${Movie::year.name}\",\n    Accumulators.bottom(\n        \"lowestRatedTwoMovies\",\n        Sorts.descending(\"${Movie::imdb.name}.${Movie.IMDB::rating.name}\"),\n        listOf(\"\\$${Movie::title.name}\", \"\\$${Movie::imdb.name}.${Movie.IMDB::rating.name}\"),\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.unwind(\"\\$${\"lowestRatedTwoMovies\"}\")\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.unwind(\n    \"\\$${\"lowestRatedTwoMovies\"}\",\n    UnwindOptions().preserveNullAndEmptyArrays(true)\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.unwind(\n    \"\\$${\"lowestRatedTwoMovies\"}\",\n    UnwindOptions().includeArrayIndex(\"position\")\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.out(\"classic_movies\")\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.merge(\"nineties_movies\")\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.merge(\n    MongoNamespace(\"aggregation\", \"movie_ratings\"),\n    MergeOptions().uniqueIdentifier(listOf(\"year\", \"title\"))\n            .whenMatched(MergeOptions.WhenMatched.REPLACE)\n        .whenNotMatched(MergeOptions.WhenNotMatched.INSERT)\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Users(\n    val name: String,\n    val friends: List<String>?,\n    val hobbies: List<String>?\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.graphLookup(\n    \"contacts\",\n    \"\\$${Users::friends.name}\", Users::friends.name, Users::name.name,\n    \"socialNetwork\"\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.graphLookup(\n    \"contacts\",\n    \"\\$${Users::friends.name}\", Users::friends.name, Users::name.name,\n    \"socialNetwork\",\n    GraphLookupOptions().maxDepth(2).depthField(\"degrees\")\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.graphLookup(\n    \"contacts\",\n    \"\\$${Users::friends.name}\", Users::friends.name, Users::name.name, \"socialNetwork\",\n    GraphLookupOptions().maxDepth(1).restrictSearchWithMatch(\n        Filters.eq(Users::hobbies.name, \"golf\")\n    )\n)\n"
        },
        {
          "lang": "json",
          "value": "[\n    { \"$group\": { \"_id\": <expression to group on>, \"count\": { \"$sum\": 1 } } },\n    { \"$sort\": { \"count\": -1 } }\n]"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.sortByCount(\"\\$${Movie::genres.name}\"),\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Libro(val titulo: String)\ndata class Book(val title: String, val spanishTranslation: Libro)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.replaceRoot(\"\\$${Book::spanishTranslation.name}\")\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.addFields(\n    Field(\"watched\", false),\n    Field(\"type\", \"movie\")\n)\n"
        },
        {
          "lang": "json",
          "value": "{ \"$group\":{ \"_id\": 0, \"count\": { \"$sum\" : 1 } } }"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.count(\"total\")\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Screen(\n    val id: String,\n    val screenSize: Int,\n    val manufacturer: String,\n    val price: Double\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.bucket(\"\\$${Screen::screenSize.name}\", listOf(0, 24, 32, 50, 70, 1000))\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.bucket(\"\\$${Screen::screenSize.name}\", listOf(0, 24, 32, 50, 70),\n    BucketOptions()\n        .defaultBucket(\"monster\")\n        .output(\n            Accumulators.sum(\"count\", 1),\n            Accumulators.push(\"matches\", \"\\$${Screen::screenSize.name}\")\n        )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Screen(\n    val id: String,\n    val screenSize: Int,\n    val manufacturer: String,\n    val price: Double\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.bucketAuto(\"\\$${Screen::screenSize.name}\", 5)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.bucketAuto(\n    \"\\$${Screen::price.name}\", 5,\n    BucketAutoOptions()\n        .granularity(BucketGranularity.POWERSOF2)\n        .output(Accumulators.sum(\"count\", 1), Accumulators.avg(\"avgPrice\", \"\\$${Screen::price.name}\"))\n        )\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Screen(\n    val id: String,\n    val screenSize: Int,\n    val manufacturer: String,\n    val price: Double\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.facet(\n    Facet(\n        \"Screen Sizes\",\n        Aggregates.bucketAuto(\n            \"\\$${Screen::screenSize.name}\",\n            5,\n            BucketAutoOptions().output(Accumulators.sum(\"count\", 1))\n        )\n    ),\n    Facet(\n        \"Manufacturer\",\n        Aggregates.sortByCount(\"\\$${Screen::manufacturer.name}\"),\n        Aggregates.limit(5)\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Weather(\n    val localityId: String,\n    val measurementDateTime: LocalDateTime,\n    val rainfall: Double,\n    val temperature: Double\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val pastMonth = Windows.timeRange(-1, MongoTimeUnit.MONTH, Windows.Bound.CURRENT)\n\nval resultsFlow = weatherCollection.aggregate<Document>(\n    listOf(\n       Aggregates.setWindowFields(\"\\$${Weather::localityId.name}\",\n           Sorts.ascending(Weather::measurementDateTime.name),\n           WindowOutputFields.sum(\n               \"monthlyRainfall\",\n               \"\\$${Weather::rainfall.name}\",\n               pastMonth\n           ),\n           WindowOutputFields.avg(\n               \"monthlyAvgTemp\",\n               \"\\$${Weather::temperature.name}\",\n               pastMonth\n           )\n       )\n    )\n"
        },
        {
          "lang": "none",
          "value": "Document{{ _id=5553a..., position=Document{{type=Point, coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 08:00:00 EST 1984, ... }}\nDocument{{ _id=5553b..., position=Document{{type=Point, coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 09:00:00 EST 1984, ... }}"
        },
        {
          "lang": "none",
          "value": "Document{{ _id=5553a..., position=Document{{type=Point, coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 08:00:00 EST 1984, ... }}\nDocument{{ position=Document{{coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 08:15:00 EST 1984 }}\nDocument{{ position=Document{{coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 08:30:00 EST 1984 }}\nDocument{{ position=Document{{coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 08:45:00 EST 1984 }}\nDocument{{ _id=5553b..., position=Document{{type=Point, coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 09:00:00 EST 1984, ... }}"
        },
        {
          "lang": "kotlin",
          "value": "data class Weather(\n    @BsonId val id: ObjectId = ObjectId(),\n    val position: Point,\n    val ts: LocalDateTime\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.densify(\n    \"ts\",\n    DensifyRange.partitionRangeWithStep(15, MongoTimeUnit.MINUTE),\n    DensifyOptions.densifyOptions().partitionByFields(\"Position.coordinates\")\n)\n"
        },
        {
          "lang": "none",
          "value": "Document{{_id=6308a..., hour=1, temperature=23C, air_pressure=29.74}}\nDocument{{_id=6308b..., hour=2, temperature=23.5C}}\nDocument{{_id=6308c..., hour=3, temperature=null, air_pressure=29.76}}"
        },
        {
          "lang": "kotlin",
          "value": "data class Weather(\n    @BsonId val id: ObjectId = ObjectId(),\n    val hour: Int,\n    val temperature: String?,\n    val air_pressure: Double?\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = weatherCollection.aggregate<Weather>(\n    listOf(\n        Aggregates.fill(\n            FillOptions.fillOptions().sortBy(Sorts.ascending(Weather::hour.name)),\n            FillOutputField.value(Weather::temperature.name, \"23.6C\"),\n            FillOutputField.linear(Weather::air_pressure.name)\n        )\n    )\n)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Weather(id=6308a..., hour=1, temperature=23C, air_pressure=29.74)\nWeather(id=6308b..., hour=2, temperature=23.5C, air_pressure=29.75)\nWeather(id=6308b..., hour=3, temperature=23.6C, air_pressure=29.76)"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.search(\n    SearchOperator.text(\n        SearchPath.fieldPath(Movie::title.name), \"Future\"\n    ),\n    SearchOptions.searchOptions().index(\"title\")\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.searchMeta(\n    SearchOperator.near(1985, 2, SearchPath.fieldPath(Movie::year.name)),\n    SearchOptions.searchOptions().index(\"year\")\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "data class MovieAlt(\n    val title: String,\n    val year: Int,\n    val plot: String,\n    val plotEmbedding: List<Double>\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "Aggregates.vectorSearch(\n    SearchPath.fieldPath(MovieAlt::plotEmbedding.name),\n    listOf(-0.0072121937, -0.030757688, -0.012945653),\n    \"mflix_movies_embedding_index\",\n    2.toLong(),\n    1.toLong(),\n    vectorSearchOptions().filter(Filters.gte(MovieAlt::year.name, 2016))\n)\n"
        }
      ],
      "preview": "In this guide, you can learn how to use the Aggregates\nclass which provides static factory methods that build aggregation pipeline\nstages in the MongoDB Kotlin driver.",
      "tags": "code example, data insights, compute, atlas",
      "facets": {
        "genre": ["reference"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/builders/filters",
      "title": "Filters Builders",
      "headings": [
        "Overview",
        "Comparison",
        "Logical",
        "Arrays",
        "Elements",
        "Evaluation",
        "Bitwise",
        "Geospatial"
      ],
      "paragraphs": "In this guide, you can learn how to use  builders  to specify\n filters  for your queries in the MongoDB Kotlin driver. Builders are classes provided by the MongoDB Kotlin driver that help you\nconstruct  BSON  objects. To learn more, see our  guide\non builders . Filters are operations used to limit the results of a query based on\nspecified conditions. Filters are a helpful tool to locate\ninformation that matches search conditions in a collection. You can use filters in the following places: Some examples of results from queries with filters are: This guide shows you how to use builders with examples of the following\ntypes of operators: The  Filters  class provides static factory methods for all the MongoDB query\noperators. Each method returns an instance of the  BSON \ntype, which you can pass to any method that expects a query filter. Most of the  Filter  examples in this guide use the following sample collection  paints : These documents in the  paints  collection are modeled by the following data class for use\nwith the Kotlin driver: As a parameter to the  find()  method In a match stage of an aggregation pipeline As a parameter to the  deleteOne()  or  deleteMany()  method As a parameter to the  updateOne()  or  updateMany()  method Items that cost more than $0 but less than $25. Foods that are both gluten-free and less than 500 calories. A food critic review that mentions \"spicy\". Comparison Logical Arrays Elements Evaluation Bitwise Geospatial For brevity, you may choose to import all methods of the\n Filters \nclass statically: The comparison filters include all operators that compare the value in a\ndocument to a specified value. The  Filters  comparison operator methods include: The following example creates a filter that matches all documents where\nthe value of the  qty  field equals \"5\" in the  paints  collection: The following example creates a filter that matches all documents where\nthe value of the  qty  field is greater than or equal to \"10\" in the\n paints  collection: The following example creates a filter that matches all documents in\nthe  paints  collection because the predicate is empty: Comparison Method Matches eq() values equal to a specified value. gt() values greater than a specified value. gte() values greater than or equal to a specified value. lt() values less than a specified value. lte() values less than or equal to a specified value. ne() values not equal to a specified value. in() any of the values specified in an array. nin() none of the values specified in an array. empty() all the documents. The logical operators perform logical operations based on the conditions of the specified method. The  Filters  logical operator methods include: The following example creates a filter that matches documents where\nthe value of the  qty  field is greater than \"8\" or the value\nof the  color  field equals \"pink\" in the  paints  collection: Logical Method Matches and() documents with the conditions of all the filters. This operator joins filters with a logical  AND . or() documents with the conditions of either filter. This operator joins filters with a logical  OR . not() documents that do not match the filter. nor() documents that fail to match both filters. This operator joins filters with a logical  NOR . The array operators evaluate the array field in a document. The  Filters  array operator methods include: The following example matches documents with a  vendors  array\ncontaining both \"A\" and \"D\" in the  paints  collection: Array Method Matches all() documents if the array field contains every element specified in the query. elemMatch() documents if an element in the array field matches all the specified conditions. size() documents if the array field is a specified number of elements. The elements operators evaluate the nature of a specified field. The  Filters  elements operator methods include: The following example matches documents that have a  qty  field and\nits value does not equal \"5\" or \"8\" in the  paints  collection: Elements Method Matches exists() documents that have the specified field. type() documents if a field is of the specified type. The evaluation operators evaluate the value of any field in a document. The  Filters  evaluation operator methods include: The following example matches documents that have a  color  field\nstarting with the letter \"p\" in the  paints  collection: Evaluation Method Matches mod() documents where a modulo operation on the value of a field contain a specified result. regex() documents where values contain a specified regular expression. text() documents which contain a specified full-text search expression. where() documents which contain a specified JavaScript expression. The bitwise operators convert a number into its binary value to\nevaluate its bits. The  Filters  bitwise operator methods include: The following example matches documents that have a  decimalValue  field\nwith bits set at positions of the corresponding bitmask \"34\" (i.e.\n\"00100010\") in this  binary_numbers  collection: Bitwise Method Matches bitsAllSet() documents where the specified bits of a field are set (i.e. \"1\"). bitsAllClear() documents where the specified bits of a field are clear (i.e. \"0\"). bitsAnySet() documents where at least one of the specified bits of a field are set (i.e. \"1\"). bitsAnyClear() documents where at least one of the specified bits of a field are clear (i.e. \"0\"). The geospatial operators evaluate a specified coordinate and its\nrelation to a shape or location. The  Filters  geospatial operator methods include: The following example creates a filter that matches documents in which\nthe  point  field contains a GeoJSON geometry that falls within\nthe given  Polygon \nin this  stores  collection: Geospatial Method Matches geoWithin() documents containing a GeoJSON geometry value that falls within a bounding GeoJSON geometry. geoWithinBox() documents containing a coordinates value that exist within the specified box. geoWithinPolygon() documents containing a coordinates value that exist within the specified polygon. geoWithinCenter() documents containing a coordinates value that exist within the specified circle. geoWithinCenterSphere() geometries containing a geospatial data value (GeoJSON or legacy coordinate pairs) that exist within the specified circle, using spherical geometry. geoIntersects() geometries that intersect with a GeoJSON geometry. The  2dsphere  index supports  $geoIntersects . near() geospatial objects in proximity to a point. Requires a geospatial index. The  2dsphere  and  2d  indexes support  $near . nearSphere() geospatial objects in proximity to a point on a sphere. Requires a geospatial index. The  2dsphere  and  2d  indexes support  $nearSphere .",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5, \"vendor\": [\"A\"] }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] }\n{ \"_id\": 3, \"color\": \"blue\", \"qty\": 8, \"vendor\": [\"B\", \"A\"] }\n{ \"_id\": 4, \"color\": \"white\", \"qty\": 6, \"vendor\": [\"D\"] }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 11, \"vendor\": [\"A\", \"B\"] }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 5, \"vendor\": [\"C\"] }\n{ \"_id\": 7, \"color\": \"green\", \"qty\": 8,\"vendor\": [\"B\", \"C\"] }\n{ \"_id\": 8, \"color\": \"orange\", \"qty\": 7, \"vendor\": [\"A\", \"D\"] }"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Filters.*"
        },
        {
          "lang": "kotlin",
          "value": "data class PaintOrder(\n    @BsonId val id: Int,\n    val qty: Int,\n    val color: String,\n    val vendors: List<String> = mutableListOf()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val equalComparison = Filters.eq(PaintOrder::qty.name, 5)\nval resultsFlow = collection.find(equalComparison)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=1, qty=5, color=red, vendors=[A])\nPaintOrder(id=6, qty=5, color=pink, vendors=[C])"
        },
        {
          "lang": "kotlin",
          "value": "val gteComparison = Filters.gte(PaintOrder::qty.name, 10)\nval resultsFlow = collection.find(gteComparison)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=2, qty=10, color=purple, vendors=[C, D])\nPaintOrder(id=5, qty=11, color=yellow, vendors=[A, B])"
        },
        {
          "lang": "kotlin",
          "value": "val emptyComparison = Filters.empty()\nval resultsFlow = collection.find(emptyComparison)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=1, qty=5, color=red, vendors=[A])\nPaintOrder(id=2, qty=10, color=purple, vendors=[C, D])\nPaintOrder(id=3, qty=8, color=blue, vendors=[B, A])\nPaintOrder(id=4, qty=6, color=white, vendors=[D])\nPaintOrder(id=5, qty=11, color=yellow, vendors=[A, B])\nPaintOrder(id=6, qty=5, color=pink, vendors=[C])\nPaintOrder(id=7, qty=8, color=green, vendors=[B, C])\nPaintOrder(id=8, qty=7, color=orange, vendors=[A, D])"
        },
        {
          "lang": "kotlin",
          "value": "val orComparison = Filters.or(\n    Filters.gt(PaintOrder::qty.name, 8),\n    Filters.eq(PaintOrder::color.name, \"pink\")\n)\nval resultsFlow = collection.find(orComparison)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=2, qty=10, color=purple, vendors=[C, D])\nPaintOrder(id=5, qty=11, color=yellow, vendors=[A, B])\nPaintOrder(id=6, qty=5, color=pink, vendors=[C])"
        },
        {
          "lang": "kotlin",
          "value": "val search = listOf(\"A\", \"D\")\nval allComparison = Filters.all(PaintOrder::vendors.name, search)\nval resultsFlow = collection.find(allComparison)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=8, qty=7, color=orange, vendors=[A, D])"
        },
        {
          "lang": "kotlin",
          "value": "val existsComparison = Filters.and(Filters.exists(PaintOrder::qty.name), Filters.nin(\"qty\", 5, 8))\nval resultsFlow = collection.find(existsComparison)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=2, qty=10, color=purple, vendors=[C, D])\nPaintOrder(id=4, qty=6, color=white, vendors=[D])\nPaintOrder(id=5, qty=11, color=yellow, vendors=[A, B])\nPaintOrder(id=8, qty=7, color=orange, vendors=[A, D])"
        },
        {
          "lang": "kotlin",
          "value": "val regexComparison = Filters.regex(PaintOrder::color.name, \"^p\")\nval resultsFlow = collection.find(regexComparison)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=2, qty=10, color=purple, vendors=[C, D])\nPaintOrder(id=6, qty=5, color=pink, vendors=[C])"
        },
        {
          "lang": "json",
          "value": "{ \"_id\": 9, \"decimalValue\": 54, \"binaryValue\": \"00110110\" }\n{ \"_id\": 10, \"decimalValue\": 20, \"binaryValue\": \"00010100\" }\n{ \"_id\": 11, \"decimalValue\": 68, \"binaryValue\": \"1000100\" }\n{ \"_id\": 12, \"decimalValue\": 102, \"binaryValue\": \"01100110\" }"
        },
        {
          "lang": "kotlin",
          "value": "data class BinaryNumber(\n    @BsonId val id: Int,\n    val decimalValue: Int,\n    val binaryValue: String\n)\nval binaryCollection = database.getCollection<BinaryNumber>(\"binary_numbers\")\n\nval bitmask = 34.toLong() // 00100010 in binary\nval bitsComparison = Filters.bitsAllSet(BinaryNumber::decimalValue.name, bitmask)\nval resultsFlow = binaryCollection.find(bitsComparison)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "BinaryNumber(id=1, decimalValue=54, binaryValue=00110110)\nBinaryNumber(id=4, decimalValue=102, binaryValue=01100110)"
        },
        {
          "lang": "json",
          "value": "{ \"_id\": 13, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [2.0, 2.0] } }\n{ \"_id\": 14, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [5.0, 6.0] } }\n{ \"_id\": 15, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [1.0, 3.0] } }\n{ \"_id\": 16, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [4.0, 7.0] } }"
        },
        {
          "lang": "kotlin",
          "value": "data class Store(\n    @BsonId val id: Int,\n    val name: String,\n    val coordinates: Point\n)\nval collection = database.getCollection<Store>(\"stores\")\n\nval square = Polygon(listOf(\n    Position(0.0, 0.0),\n    Position(4.0, 0.0),\n    Position(4.0, 4.0),\n    Position(0.0, 4.0),\n    Position(0.0, 0.0)))\nval geoWithinComparison = Filters.geoWithin(Store::coordinates.name, square)\n\nval resultsFlow = collection.find(geoWithinComparison)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Store(id=13, name=Store 13, coordinates=Point{coordinate=Position{values=[2.0, 2.0]}})\nStore(id=15, name=Store 15, coordinates=Point{coordinate=Position{values=[1.0, 3.0]}})"
        }
      ],
      "preview": "In this guide, you can learn how to use builders to specify\nfilters for your queries in the MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/builders/indexes",
      "title": "Indexes Builders",
      "headings": [
        "Overview",
        "Ascending Indexes",
        "Descending Indexes",
        "Compound Indexes",
        "Text Indexes",
        "Hashed Indexes",
        "Geospatial Indexes"
      ],
      "paragraphs": "In this guide, you can learn how to specify  indexes  using\n builders  in the MongoDB Kotlin Driver.\nThe  Indexes  builder provides helper methods for constructing the\nfollowing types of indexes: Indexes store a subset of the collection's data set. The index stores\nthe value of a specific field or set of fields, ordered by the value of\nthe field. See our guide on  Indexes  for\nexamples of queries covered by indexes. The  Indexes  class provides static factory methods for all the MongoDB index types.\nEach method returns a  BSON \ninstance, which you can pass to\n createIndex() . Ascending Indexes Descending Indexes Compound Indexes Text Indexes Hashed Indexes Geospatial Indexes For brevity, you may choose to import all methods of the\n Indexes \nclass: An ascending index enables you to sort query results by the value of the\nindexed fields from smallest to largest. In order to create an ascending index, first call the\n ascending() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the name or names of the fields you want to index.\nThen, call the  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies an ascending index on the  name  field: If you have an ascending or a descending index on a single field, MongoDB\ncan sort using the index in either direction. A descending index enables you to sort query results by the value of the\nindexed fields from largest to smallest. In order to create a descending index, first call the\n descending() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the name or names of the fields you want to index.\nThen, call the  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies a descending index on the  capacity  field: In order to create a compound index, first call the\n compoundIndex() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the names of the fields you want to index. Then, call\nthe  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies a compound index composed of\ndescending index on the  capacity  and  year  field, followed\nby an ascending index on the  name  field: A text index groups documents by the text in the indexed field. In order to create a text index, first call the\n text() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the name of the fields you want to index. Then, call\nthe  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies a text index key on the  theaters  field: A hashed index groups documents by the hash value in the indexed field. In order to create a hashed index, first call the\n hashed() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the name of the fields you want to index. Then, call\nthe  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies a hashed index on the  capacity \nfield: A  2dsphere  index groups documents by the coordinates in the indexed field. In order to create a  2dsphere  index, first call the\n geo2dsphere() \nbuilder method to create a  Bson  instance that represents the index\ndocument, passing the name or names of the fields you want to index.\nThen, call the  createIndex()  method on the collection, passing the  Bson \ninstance that contains the index document. The following example specifies a  2dsphere  index on the  location  field:",
      "code": [
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Indexes.*"
        },
        {
          "lang": "kotlin",
          "value": "val ascendingIndex = Indexes.ascending(\"name\")\nval indexName = collection.createIndex(ascendingIndex)\nprintln(indexName)\n"
        },
        {
          "lang": "console",
          "value": "name_1"
        },
        {
          "lang": "kotlin",
          "value": "val descendingIndex = Indexes.descending(\"capacity\")\nval indexName = collection.createIndex(descendingIndex)\nprintln(indexName)\n"
        },
        {
          "lang": "console",
          "value": "capacity_-1"
        },
        {
          "lang": "kotlin",
          "value": "val compoundIndexExample = Indexes.compoundIndex(\n    Indexes.descending(\"capacity\", \"year\"),\n    Indexes.ascending(\"name\")\n)\nval indexName = collection.createIndex(compoundIndexExample)\nprintln(indexName)\n"
        },
        {
          "lang": "console",
          "value": "capacity_-1_year_-1_name_1"
        },
        {
          "lang": "kotlin",
          "value": "val textIndex = Indexes.text(\"theaters\")\nval indexName = collection.createIndex(textIndex)\nprintln(indexName)\n"
        },
        {
          "lang": "console",
          "value": "theaters_text"
        },
        {
          "lang": "kotlin",
          "value": "val hashedIndex = Indexes.hashed(\"capacity\")\nval indexName = collection.createIndex(hashedIndex)\nprintln(indexName)\n"
        },
        {
          "lang": "console",
          "value": "capacity_hashed"
        },
        {
          "lang": "kotlin",
          "value": "val geo2dsphereIndex = Indexes.geo2dsphere(\"location\")\nval indexName = collection.createIndex(geo2dsphereIndex)\nprintln(indexName)\n"
        },
        {
          "lang": "console",
          "value": "location_2dsphere"
        }
      ],
      "preview": "In this guide, you can learn how to specify indexes using\nbuilders in the MongoDB Kotlin Driver.\nThe Indexes builder provides helper methods for constructing the\nfollowing types of indexes:",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/builders/projections",
      "title": "Projections Builders",
      "headings": [
        "Overview",
        "Sample Documents and Examples",
        "Projection Operations",
        "Inclusion",
        "Exclusion",
        "Combining Projections",
        "Exclusion of _id",
        "Project an Array Element Match",
        "Project an Array Slice",
        "Project a Text Score"
      ],
      "paragraphs": "In this guide, you can learn how to specify  projections  using\n builders  in the MongoDB Kotlin driver. MongoDB supports  field projection , specifying which fields to include and exclude when returning results from a\nquery. Projection in MongoDB follows some basic rules: Find more information about projection mechanics in the  Project Fields to Return from Query guide  in the MongoDB Server documentation. The  Projections  class provides static factory methods for\nall the MongoDB projection operators. Each method returns an instance of the  BSON  type which you can pass\nto any method that expects a projection. The  _id  field is  always  included unless explicitly excluded Specifying a field for inclusion implicitly excludes all other fields  except  the  _id  field Specifying a field for exclusion removes  only  that field in a query result For brevity, you may choose to import the methods of the\n Projections \nclass: The following sections feature examples that run query and projection operations\non a sample collection called  projection_builders . Each section uses\na variable named  collection  to refer to the  MongoCollection  instance\nof the  projection_builders  collection. The collection contains the following documents, representing the monthly average\ntemperatures in Celsius for the years 2018 and 2019: The following data class is used to represent the documents in the collection: The following sections contain information on the available projection\noperations and how to construct them using the  Projections  class. Use the  include()  method to specify the inclusion of one or more fields. The following example includes the  year  field and implicitly the  _id  field: The following example includes the  year  and  type  fields and implicitly the  _id  field: Use the  exclude()  method to specify the exclusion of one or more fields. The following example excludes the  temperatures  field: The following example excludes the  temperatures  and  type  fields: Use the  fields()  method to combine multiple projections. The following example includes the  year  and  type  fields and excludes the\n _id  field: Use the  excludeId()  convenience method to specify the exclusion of the  _id  field: Use the  elemMatch(String, Bson)  method variant to specify an array projection that will include the first\nelement of an array that matches a supplied query filter. This filtering occurs  after  all documents matching the\nquery filter (if supplied) are retrieved. The following example projects the first element of the  temperatures  array where the  avg  field is\ngreater that  10.1 : When you've specified matching criteria in the  query  portion of your operation, use the  elemMatch(String)  method\nvariant to specify a  positional projection  to include\nthe first element of an array. Only documents that match the query filter will be retrieved. The following example projects the first element of the  temperatures  array: Only the first element that matches the specified query filter will be included,\nregardless of how many matches there may be. In MongoDB version 4.4 and earlier, the specified array field must appear in the query filter. Beginning in MongoDB 4.4,\nyou can use a positional project on an array field that does not appear in the query filter. Use the  slice()  method to project a  slice  of an array. The following example projects the first 6 elements of the  temperatures  array: The following example skips the first 6 elements of the  temperatures  array and projects the next  6 : Use the  metaTextScore()  method to specify a projection of the\n score of a text query . The following example projects the text score as the value of the  score  field:",
      "code": [
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Projections.*"
        },
        {
          "lang": "json",
          "value": "{\n  \"year\" : 2018,\n  \"type\" : \"even number but not a leap year\",\n  \"temperatures\" : [\n    { \"month\" : \"January\", \"avg\" : 9.765 },\n    { \"month\" : \"February\", \"avg\" : 9.675 },\n    { \"month\" : \"March\", \"avg\" : 10.004 },\n    { \"month\" : \"April\", \"avg\" : 9.983 },\n    { \"month\" : \"May\", \"avg\" : 9.747 },\n    { \"month\" : \"June\", \"avg\" : 9.65 },\n    { \"month\" : \"July\", \"avg\" : 9.786 },\n    { \"month\" : \"August\", \"avg\" : 9.617 },\n    { \"month\" : \"September\", \"avg\" : 9.51 },\n    { \"month\" : \"October\", \"avg\" : 10.042 },\n    { \"month\" : \"November\", \"avg\" : 9.452 },\n    { \"month\" : \"December\", \"avg\" : 9.86 }\n  ]\n},\n{\n  \"year\" : 2019,\n  \"type\" : \"odd number, can't be a leap year\",\n  \"temperatures\" : [\n    { \"month\" : \"January\", \"avg\" : 10.023 },\n    { \"month\" : \"February\", \"avg\" : 9.808 },\n    { \"month\" : \"March\", \"avg\" : 10.43 },\n    { \"month\" : \"April\", \"avg\" : 10.175 },\n    { \"month\" : \"May\", \"avg\" : 9.648 },\n    { \"month\" : \"June\", \"avg\" : 9.686 },\n    { \"month\" : \"July\", \"avg\" : 9.794 },\n    { \"month\" : \"August\", \"avg\" : 9.741 },\n    { \"month\" : \"September\", \"avg\" : 9.84 },\n    { \"month\" : \"October\", \"avg\" : 10.15 },\n    { \"month\" : \"November\", \"avg\" : 9.84 },\n    { \"month\" : \"December\", \"avg\" : 10.366 }\n  ]\n}"
        },
        {
          "lang": "kotlin",
          "value": "data class YearlyTemperature(\n    @BsonId val id: ObjectId,\n    val year: Int,\n    val type: String,\n    val temperatures: List<MonthlyTemperature>\n) {\n    data class MonthlyTemperature(\n        val month: String,\n        val avg: Double\n    )\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(@BsonId val id: ObjectId, val year: Int)\n\nval filter = Filters.empty()\nval projection = Projections.include(YearlyTemperature::year.name)\nval resultsFlow = collection.find<Results>(filter).projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(id=6467808db5003e6354a1ee22, year=2018)\nResults(id=6467808db5003e6354a1ee23, year=2019)"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(@BsonId val id: ObjectId, val year: Int, val type: String)\n\nval filter = Filters.empty()\nval projection = Projections.include(YearlyTemperature::year.name, YearlyTemperature::type.name)\nval resultsFlow = collection.find<Results>(filter).projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(id=646780e3311323724f69a907, year=2018, type=even number but not a leap year)\nResults(id=646780e3311323724f69a908, year=2019, type=odd number, can't be a leap year)"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(@BsonId val id: ObjectId, val year: Int, val type: String)\nval filter = Filters.empty()\nval projection = Projections.exclude(YearlyTemperature::temperatures.name)\nval resultsFlow = collection.find<Results>(filter).projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(id=6462976102c85b29a7bfc9d5, year=2018, type=even number but not a leap year)\nResults(id=6462976102c85b29a7bfc9d6, year=2019, type=odd number, can't be a leap year)"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(@BsonId val id: ObjectId, val year: Int)\n\nval filter = Filters.empty()\nval projection = Projections.exclude(YearlyTemperature::temperatures.name, YearlyTemperature::type.name)\nval resultsFlow = collection.find<Results>(filter).projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(id=64629783d7760d2365215147, year=2018)\nResults(id=64629783d7760d2365215148, year=2019)"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(val year: Int, val type: String)\n\nval filter = Filters.empty()\nval projection = Projections.fields(\n    Projections.include(YearlyTemperature::year.name, YearlyTemperature::type.name),\n    Projections.excludeId()\n)\nval resultsFlow = collection.find<Results>(filter).projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(year=2018, type=even number but not a leap year)\nResults(year=2019, type=odd number, can't be a leap year)"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(val year: Int, val type: String, val temperatures: List<YearlyTemperature.MonthlyTemperature>)\nval filter = Filters.empty()\nval projection = Projections.excludeId()\nval resultsFlow = collection.find<Results>(filter).projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(year=2018, type=even number but not a leap year, temperatures=[MonthlyTemperature(month=January, avg=9.765), MonthlyTemperature(month=February, avg=9.675), MonthlyTemperature(month=March, avg=10.004), MonthlyTemperature(month=April, avg=9.983), MonthlyTemperature(month=May, avg=9.747), MonthlyTemperature(month=June, avg=9.65), MonthlyTemperature(month=July, avg=9.786), MonthlyTemperature(month=August, avg=9.617), MonthlyTemperature(month=September, avg=9.51), MonthlyTemperature(month=October, avg=10.042), MonthlyTemperature(month=November, avg=9.452), MonthlyTemperature(month=December, avg=9.86)])\nResults(year=2019, type=odd number, can't be a leap year, temperatures=[MonthlyTemperature(month=January, avg=10.023), MonthlyTemperature(month=February, avg=9.808), MonthlyTemperature(month=March, avg=10.43), MonthlyTemperature(month=April, avg=10.175), MonthlyTemperature(month=May, avg=9.648), MonthlyTemperature(month=June, avg=9.686), MonthlyTemperature(month=July, avg=9.794), MonthlyTemperature(month=August, avg=9.741), MonthlyTemperature(month=September, avg=9.84), MonthlyTemperature(month=October, avg=10.15), MonthlyTemperature(month=November, avg=9.84), MonthlyTemperature(month=December, avg=10.366)])"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(\n    val year: Int,\n    val temperatures: List<YearlyTemperature.MonthlyTemperature>?\n)\n\nval filter = Filters.empty()\nval projection = Projections.fields(\n    Projections.include(YearlyTemperature::year.name),\n    Projections.elemMatch(\n        YearlyTemperature::temperatures.name,\n        Filters.gt(YearlyTemperature.MonthlyTemperature::avg.name, 10.1)\n    )\n)\nval resultsFlow = collection.find<Results>(filter).projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(year=2018, temperatures=null)\nResults(year=2019, temperatures=[MonthlyTemperature(month=March, avg=10.43)])"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(\n    val year: Int,\n    val temperatures: List<YearlyTemperature.MonthlyTemperature>\n)\n\nval filter = Filters.gt(\n    \"${YearlyTemperature::temperatures.name}.${YearlyTemperature.MonthlyTemperature::avg.name}\",\n    10.1\n)\nval projection = Projections.fields(\n    Projections.include(YearlyTemperature::year.name),\n    Projections.elemMatch(YearlyTemperature::temperatures.name)\n)\nval resultsFlow = collection.find<Results>(filter).projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(year=2019, temperatures=[MonthlyTemperature(month=March, avg=10.43)])"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(val temperatures: List<YearlyTemperature.MonthlyTemperature>)\n\nval filter = Filters.empty()\n// First half of the year\nval projection = Projections.fields(\n    Projections.slice(YearlyTemperature::temperatures.name, 6),\n    Projections.excludeId()\n)\nval resultsFlow = collection.find<Results>(filter)\n    .projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(temperatures=[MonthlyTemperature(month=January, avg=9.765), MonthlyTemperature(month=February, avg=9.675), MonthlyTemperature(month=March, avg=10.004), MonthlyTemperature(month=April, avg=9.983), MonthlyTemperature(month=May, avg=9.747), MonthlyTemperature(month=June, avg=9.65)])\nResults(temperatures=[MonthlyTemperature(month=January, avg=10.023), MonthlyTemperature(month=February, avg=9.808), MonthlyTemperature(month=March, avg=10.43), MonthlyTemperature(month=April, avg=10.175), MonthlyTemperature(month=May, avg=9.648), MonthlyTemperature(month=June, avg=9.686)])"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(val temperatures: List<YearlyTemperature.MonthlyTemperature>)\n\nval filter = Filters.empty()\n// Second half of the year\nval projection = Projections.fields(\n    Projections.slice(YearlyTemperature::temperatures.name, 6, 6),\n    Projections.excludeId()\n)\nval resultsFlow = collection.find<Results>(filter)\n    .projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(temperatures=[MonthlyTemperature(month=July, avg=9.786), MonthlyTemperature(month=August, avg=9.617), MonthlyTemperature(month=September, avg=9.51), MonthlyTemperature(month=October, avg=10.042), MonthlyTemperature(month=November, avg=9.452), MonthlyTemperature(month=December, avg=9.86)])\nResults(temperatures=[MonthlyTemperature(month=July, avg=9.794), MonthlyTemperature(month=August, avg=9.741), MonthlyTemperature(month=September, avg=9.84), MonthlyTemperature(month=October, avg=10.15), MonthlyTemperature(month=November, avg=9.84), MonthlyTemperature(month=December, avg=10.366)])"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(val year: Int, val score: Double)\n\nval filter = Filters.text(\"even number\")\nval projection = Projections.fields(\n    Projections.include(YearlyTemperature::year.name),\n    Projections.metaTextScore(\"score\")\n)\nval resultsFlow = collection.find<Results>(filter).projection(projection)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Results(year=2018, score=1.25)\nResults(year=2019, score=0.625)"
        }
      ],
      "preview": "In this guide, you can learn how to specify projections using\nbuilders in the MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/builders/sort",
      "title": "Sorts Builders",
      "headings": [
        "Overview",
        "The Sorts Class",
        "Ascending",
        "Descending",
        "Combining Sort Criteria",
        "Text Score"
      ],
      "paragraphs": "In this guide, you can learn how to specify  sort criteria  for your\nqueries using  builders  in the MongoDB Kotlin Driver. Sort criteria are the rules MongoDB uses to sort your data. Some\nexamples of sort criteria are: Builders are classes provided by the Kotlin driver that help you\nconstruct  BSON  objects. To learn more, see the\n builders  guide. You should read this guide if you want to learn how to use builders to\nspecify sort criteria for your queries. To learn the fundamentals of sorting in the Kotlin driver, see the\n sorting  guide. The examples on this page use a sample collection that\ncontains the following documents: This data is modeled with the following Kotlin data class: Smallest number to largest number Earliest time of day to latest time of day Alphabetical order by first name The  Sorts  class is a builder that provides static factory methods for all sort\ncriteria operators supported by MongoDB. These methods return a  Bson  object\nthat you can pass to the   sort()  method of a  FindFlow  instance or to\n Aggregates.sort() . To learn more about the  Aggregates \nclass, see the  Aggregates builder  guide. For more information about the classes and interfaces in this section, see the\nfollowing API Documentation: Sorts BSON FindFlow Aggregates To specify an ascending sort, use the  Sorts.ascending()  static\nfactory method. Pass the name of the field you want to sort on to\n Sorts.ascending() . The following example sorts the documents in the\n sample collection  by ascending order\non the  orderTotal  field: To specify a descending sort, use the  Sorts.descending()  static factory\nmethod. Pass the name of the field you want to sort on to  Sorts.descending() . The following example sorts the documents in the\n sample collection  in descending order\non the  orderTotal  field: To combine sort criteria, use the  Sorts.orderBy()  static factory\nmethod. This method constructs an object containing an ordered list of sort\ncriteria. When performing the sort, if the previous sort criteria result in a\ntie, the sort uses the next sort criteria in the list to determine the order. The following example sorts the documents in the\n sample collection  in descending order\non the  date  field, and in the event of a tie, ascending order on the\n orderTotal  field: You can sort text search results by their text score, a value that indicates how\nclosely a search result matches your search string. To specify a sort by the\ntext score of a text search, use the  Sorts.metaTextScore()  static factory\nmethod. For a detailed example showing how to specify sort criteria using\nthe  Sorts.metaTextScore()  method, see\n the text search section   of the sorting guide. For more information, see the  Sorts class \nAPI Documentation.",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"date\": \"2022-01-03\", \"orderTotal\": 17.86, \"description\": \"1/2 lb cream cheese and 1 dozen bagels\" },\n{ \"_id\": 2, \"date\": \"2022-01-11\", \"orderTotal\": 83.87, \"description\": \"two medium vanilla birthday cakes\" },\n{ \"_id\": 3, \"date\": \"2022-01-11\", \"orderTotal\": 19.49, \"description\": \"1 dozen vanilla cupcakes\" },\n{ \"_id\": 4, \"date\": \"2022-01-15\", \"orderTotal\": 43.62, \"description\": \"2 chicken lunches and a diet coke\" },\n{ \"_id\": 5, \"date\": \"2022-01-23\", \"orderTotal\": 60.31, \"description\": \"one large vanilla and chocolate cake\" },\n{ \"_id\": 6, \"date\": \"2022-01-23\", \"orderTotal\": 10.99, \"description\": \"1 bagel, 1 orange juice, 1 muffin\" }"
        },
        {
          "lang": "kotlin",
          "value": "data class Order(\n    @BsonId val id: Int,\n    val date: String,\n    val orderTotal: Double,\n    val description: String,\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find()\n    .sort(Sorts.ascending(Order::orderTotal.name))\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Order(id=6, date=2022-01-23, orderTotal=10.99, description=1 bagel, 1 orange juice, 1 muffin)\nOrder(id=1, date=2022-01-03, orderTotal=17.86, description=1/2 lb cream cheese and 1 dozen bagels)\nOrder(id=3, date=2022-01-11, orderTotal=19.49, description=1 dozen vanilla cupcakes)\nOrder(id=4, date=2022-01-15, orderTotal=43.62, description=2 chicken lunches and a diet coke)\nOrder(id=5, date=2022-01-23, orderTotal=60.31, description=one large vanilla and chocolate cake)\nOrder(id=2, date=2022-01-11, orderTotal=83.87, description=two medium vanilla birthday cakes)"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find()\n    .sort(Sorts.descending(Order::orderTotal.name))\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Order(id=2, date=2022-01-11, orderTotal=83.87, description=two medium vanilla birthday cakes)\nOrder(id=5, date=2022-01-23, orderTotal=60.31, description=one large vanilla and chocolate cake)\nOrder(id=4, date=2022-01-15, orderTotal=43.62, description=2 chicken lunches and a diet coke)\nOrder(id=3, date=2022-01-11, orderTotal=19.49, description=1 dozen vanilla cupcakes)\nOrder(id=1, date=2022-01-03, orderTotal=17.86, description=1/2 lb cream cheese and 1 dozen bagels)\nOrder(id=6, date=2022-01-23, orderTotal=10.99, description=1 bagel, 1 orange juice, 1 muffin)"
        },
        {
          "lang": "kotlin",
          "value": "val orderBySort = Sorts.orderBy(\n    Sorts.descending(Order::date.name), Sorts.ascending(Order::orderTotal.name)\n)\nval results = collection.find().sort(orderBySort)\n\nresults.collect {println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Order(id=6, date=2022-01-23, orderTotal=10.99, description=1 bagel, 1 orange juice, 1 muffin)\nOrder(id=5, date=2022-01-23, orderTotal=60.31, description=one large vanilla and chocolate cake)\nOrder(id=4, date=2022-01-15, orderTotal=43.62, description=2 chicken lunches and a diet coke)\nOrder(id=3, date=2022-01-11, orderTotal=19.49, description=1 dozen vanilla cupcakes)\nOrder(id=2, date=2022-01-11, orderTotal=83.87, description=two medium vanilla birthday cakes)\nOrder(id=1, date=2022-01-03, orderTotal=17.86, description=1/2 lb cream cheese and 1 dozen bagels)"
        }
      ],
      "preview": "In this guide, you can learn how to specify sort criteria for your\nqueries using builders in the MongoDB Kotlin Driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/builders/updates",
      "title": "Updates Builders",
      "headings": [
        "Overview",
        "Field Updates",
        "Set",
        "Unset",
        "Set On Insert",
        "Increment",
        "Multiply",
        "Rename",
        "Min",
        "Max",
        "Current Date",
        "Current Timestamp",
        "Bit",
        "Array Updates",
        "Add to Set",
        "Pop",
        "Pull All",
        "Pull",
        "Push",
        "Combining Multiple Update Operators"
      ],
      "paragraphs": "In this guide, you can learn how to specify  updates  by using\n builders  in the MongoDB Kotlin Driver. The  Updates  builder provides helper methods for the following types of updates: Some methods that expect updates are: The  Updates  class provides static factory methods for all the MongoDB update\noperators. Each method returns an instance of the  BSON \ntype, which you can pass to any method that expects an update argument. The examples in this guide use the following document: This example is modeled by the following data class unless otherwise noted: Field Updates Array Updates Combining Multiple Update Operators updateOne() updateMany() bulkWrite() For brevity, you may choose to import the methods of the  Updates  class: Use the  set() \nmethod to assign the value of a field in an update operation. The following example sets the value of the  qty  field to  11 : The preceding example updates the original document to the following state: Use the  unset()  method\nto delete the value of a field in an update operation. The following example deletes the  qty  field: The preceding example updates the original document to the following state: Use the  setOnInsert() \nmethod to assign the value of a field in an update operation on an\ninsert of a document. The following example sets the value of the  color  field to  \"pink\"  if\nthe operation resulted in the insert of a document: The preceding example updates the original document to the following state: If the document is not inserted, no change will occur. Use the  inc() \nmethod to increment the value of a numeric field in an update operation. The following example increments the value of the  qty  field, which was  5 , by  3 : The preceding example updates the original document to the following state: Use the  mul() \nmethod to multiply the value of a numeric field in an update operation. The following example multiplies the value of the  qty  field, which\nwas  5 , by  2 : The preceding example updates the original document to the following state: Use the  rename() \nmethod to rename the value of a field in an update operation. The following example renames the  qty  field to  quantity : The preceding example updates the original document to the following state: Use the  min() \nmethod to set the value of the field to the given value if the given value is\nless than the current value of the field. The following example updates the  qty  field to  2  because  2 \nis less than the current value of the  qty  field ( 5 ): The preceding example updates the original document to the following state: Use the  max() \nmethod to update the value of a field with the larger number of the two\nspecified in an update operation. The following example updates the  qty  field to  8  because  8 \nis greater than the current value of the  qty  field ( 5 ): The preceding example updates the original document to the following state: Use the  currentDate() \nmethod to assign the value of a field in an update operation to the\ncurrent date as a  BSON date . The following example sets the value of the  lastModified  field to\nthe current date as a BSON date: Since we wrote this page on June 16, 2023, the preceding example updates\nthe original document to the following state: Use the  currentTimestamp() \nmethod to assign the value of a field in an update operation to the\ncurrent date as a  timestamp . The following example sets the value of the  lastModified  field to\nthe current date as a BSON timestamp: Since we wrote this page on June 16, 2023, the preceding example updates\nthe original document to the following state: Use the  bitwiseOr() ,\n bitwiseAnd() ,\nand  bitwiseXor() \nmethods to perform a bitwise update of the integer value of a field in\nan update operation. The following example performs a bitwise  OR  between the number\n 10  and the integer value of the  qty  field ( 5 ): The bitwise operation results in  15 : The preceding example updates the original document to the following state: Use the  addToSet() \nmethod to append a value to an array if the value is not already present\nin an update operation. The following example adds a  Vendor  instance that has a  name \nvalue of  \"C\"  to the  vendor  array: The preceding example updates the original document to the following state: Use the  popFirst() \nmethod to remove the first element of an array and the\n popLast() \nmethod to remove the last element of an array in an update operation. The following example removes the first entry of the  vendor  array: The preceding example updates the original document to the following state: Use the  pullAll() \nmethod to remove all instances of specified values from an existing array in\nan update operation. The following example removes  Vendor  instances that have  name  values\nof  \"A\"  and  \"M\"  from the  vendor  array: The preceding example updates the original document to the following state: Use the  pull() \nmethod to remove all instances of a specified value from an existing array in\nan update operation. The following example removes  Vendor  instances that have a  name \nvalue of  \"D\"  from the  vendor  array: The preceding example updates the original document to the following state: Use the  push() \nmethod to append a value to an array in an update operation. The following example adds a  Vendor  instance that has a  name \nvalue of  \"Q\"  to the  vendor  array: The preceding example updates the original document to the following state: An application can update multiple fields of a single document by\ncombining two or more of the update operators described in the preceding\nsections. The following example increments the value of the  qty  field by  6 , sets\nthe value of the  color  field to  \"purple\" , and adds a  Vendor \ninstance that has a  name  value of  \"R\"  to the  vendor  field: The preceding example updates the original document to the following state:",
      "code": [
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Updates.*"
        },
        {
          "lang": "kotlin",
          "value": "data class PaintOrder (\n    @BsonId val id: Int,\n    val color: String,\n    val qty: Int?,\n    val vendor: List<Vendor>?,\n    val lastModified: LocalDateTime?\n)\n\ndata class Vendor (\n    val name: String,\n)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 11,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.set(PaintOrder::qty.name, 11)\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.unset(PaintOrder::qty.name)\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"pink\"\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.setOnInsert(PaintOrder::color.name, \"pink\")\ncollection.updateOne(filter, update, UpdateOptions().upsert(true))\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 8,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.inc(PaintOrder::qty.name, 3)\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 10,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.mul(PaintOrder::qty.name, 2)\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" },\n   \"quantity\": 5,\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.rename(PaintOrder::qty.name, \"quantity\")\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 2,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.min(PaintOrder::qty.name, 2)\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 8,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.max(PaintOrder::qty.name, 8)\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"$date\": \"2023-06-16T17:13:06.373Z\"\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.currentDate(PaintOrder::lastModified.name)\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"$timestamp\": { \"t\": 1686935654, \"i\": 3 }\n}"
        },
        {
          "lang": "kotlin",
          "value": "// Create a new instance of the collection with the flexible `Document` type\n// to allow for the changing of the `lastModified` field to a `BsonTimestamp`\n// from a `LocalDateTime`.\nval collection = database.getCollection<Document>(\"paint_orders\")\n\nval filter = Filters.eq(\"_id\", 1)\nval update = Updates.currentTimestamp(PaintOrder::lastModified.name)\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "none",
          "value": "0101 // bit representation of 5\n1010 // bit representation of 10\n----\n1111 // bit representation of 15"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 15,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.bitwiseOr(PaintOrder::qty.name, 10)\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" },\n      { \"name\": \"C\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.addToSet(PaintOrder::vendor.name, Vendor(\"C\"))\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [\n      { \"name\": \"D\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.popFirst(PaintOrder::vendor.name)\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [\n      { \"name\": \"D\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.pullAll(PaintOrder::vendor.name, listOf(Vendor(\"A\"), Vendor(\"M\")))\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"M\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.pull(PaintOrder::vendor.name, Vendor(\"D\"))\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"red\",\n   \"qty\": 5,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" },\n      { \"name\": \"Q\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.push(PaintOrder::vendor.name, Vendor(\"Q\"))\ncollection.updateOne(filter, update)\n"
        },
        {
          "lang": "json",
          "value": "{\n   \"_id\": 1,\n   \"color\": \"purple\",\n   \"qty\": 11,\n   \"vendor\": [\n      { \"name\": \"A\" },\n      { \"name\": \"D\" },\n      { \"name\": \"M\" },\n      { \"name\": \"R\" }\n   ],\n   \"lastModified\": { \"$date\": \"2000-01-01T07:00:00.000Z\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.combine(\n    Updates.set(PaintOrder::color.name, \"purple\"),\n    Updates.inc(PaintOrder::qty.name, 6),\n    Updates.push(PaintOrder::vendor.name, Vendor(\"R\"))\n)\ncollection.updateOne(filter, update)\n"
        }
      ],
      "preview": "In this guide, you can learn how to specify updates by using\nbuilders in the MongoDB Kotlin Driver.",
      "tags": "code example, change data, nested class",
      "facets": {
        "genre": ["reference"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/builders",
      "title": "Builders",
      "headings": [
        "Overview",
        "Why Use Builders?",
        "Scenario",
        "Using the MongoDB Shell",
        "Without Using Builders",
        "Using Builders",
        "Available Builders"
      ],
      "paragraphs": "This section includes guides on how to use each of the available\nbuilders, and demonstrates the utility the MongoDB Kotlin driver builder classes\nprovide. The Kotlin driver provides classes to simplify the process for developers\nto use CRUD operations and the Aggregation API. The static utility methods allow you\nto build a query more efficiently. Using the builders class, you leverage the power of: When using builders, the Kotlin compiler and the IDE catch errors such as misspelled\noperators early on. When using the MongoDB shell or plain Kotlin, you\nwrite operators as strings and get no visual indication of a problem,\npushing these errors to runtime instead of compile time. With the builder classes, you write operators as methods. The IDE\ninstantly underlines and gives you a red bar on the right indicating\nsomething is wrong. While developing, the IDE also shows you the\nmethods you can use. It automatically completes your code with\nplaceholder parameters once you select which method you want to use. The Kotlin compiler and the IDE to find errors during development The IDE for discovery and code completion Imagine we want to send a marketing email to all users in our  users \ncollection with the following criteria: We only want their email address, so we'll ensure our query doesn't\nreturn data we pay bandwidth costs for but don't need. The documents in the  users  collection are modeled with the following data class\nin our application: Users that identify as  female  gender Users that are older than  29 Aggregates  for building aggregation pipelines. Filters  for building query filters. Indexes  for creating index keys. Projections  for building projections. Sorts  for building sort criteria. Updates  for building updates.",
      "code": [
        {
          "lang": "kotlin",
          "value": "data class User(\n    @BsonId\n    val id: BsonObjectId = BsonObjectId(),\n    val gender: String,\n    val age: Int,\n    val email: String,\n)\n"
        },
        {
          "lang": "js",
          "value": "collection.find({ \"gender\": \"female\", \"age\" : { \"$gt\": 29 }}, { \"_id\": 0, \"email\": 1 })"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(val email: String)\n\nval filter = Document().append(\"gender\", \"female\").append(\"age\", Document().append(\"\\$gt\", 29))\nval projection = Document().append(\"_id\", 0).append(\"email\", 1)\nval results = collection.find<Results>(filter).projection(projection)\n"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Filters\nimport com.mongodb.client.model.Projections"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(val email: String)\n\nval filter = Filters.and(Filters.eq(User::gender.name, \"female\"), Filters.gt(User::age.name, 29))\nval projection = Projections.fields(Projections.excludeId(), Projections.include(\"email\"))\nval results = collection.find<Results>(filter).projection(projection)\n"
        }
      ],
      "preview": "This section includes guides on how to use each of the available\nbuilders, and demonstrates the utility the MongoDB Kotlin driver builder classes\nprovide.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/collations",
      "title": "Collations",
      "headings": [
        "Overview",
        "Sample Data for Examples",
        "Collations in MongoDB",
        "How to Specify Collations",
        "Collection",
        "Index",
        "Operation",
        "Index Types That Do Not Support Collations",
        "Collation Options",
        "Collation Examples",
        "find() and sort() Example",
        "findOneAndUpdate() Example",
        "findOneAndDelete() Example",
        "Aggregation Example"
      ],
      "paragraphs": "In this guide, you can learn how to use  collations  with MongoDB to order your\nquery or aggregation operation results by string values. A collation is a set\nof character ordering and matching rules that apply to a specific language and\nlocale. You can learn more about collations in the following sections in this guide: Collations in MongoDB How to Specify Collations Collation Options Collation Code Examples The examples on this page use a MongoDB collection with the following documents: These documents are represented by the following data class: MongoDB sorts strings using  binary collation  by default. The binary\ncollation uses the  ASCII standard  character values to\ncompare and order strings. Certain languages and locales have specific\ncharacter ordering conventions that differ from the ASCII character values. For example, in Canadian French, the right-most accented character\n(diacritic) determines the ordering for strings when all preceding characters\nare the same. Consider the following Canadian French words: When using binary collation, MongoDB sorts them in the following order: When using the Canadian French collation, MongoDB sorts them in a different\norder as shown below: cote cot\u00e9 c\u00f4te c\u00f4t\u00e9 MongoDB supports collations on most  CRUD operations \nand aggregations. For a complete list of supported operations, see the\n Operations that Support Collations \nserver manual page. You can specify the locale code and optional variant in the following string\nformat: The following example specifies the \"de\" locale code and \"phonebook\" variant\ncode: If you do not need to specify a variant, omit everything after the locale\ncode as follows: For a complete list of supported locales, see our server manual page on\n Supported Languages and Locales . The following sections show you different ways to apply collations in\nMongoDB: Collection Index Operation You can set a default collation when you create a collection. When you\ncreate a collection with a specified collation, all supported operations\nthat scan that collection apply the rules of the collation. You can only assign a default collation to a collection when you create that\ncollection. However, you can specify a collation in a new index on an existing\ncollection. See the  Index  section of this guide\nfor more information. The following snippet shows how to specify the \"en_US\" locale collation\nwhen creating a new collection called  items : To check whether you created the collation successfully, retrieve a list\nof the indexes on that collection as follows: You can specify a collation when you create a new index on a collection.\nThe index stores an ordered representation of the documents in the\ncollection so your operation does not need to perform the ordering\nin-memory. To use the index, your operation must meet the following\ncriteria: The following code snippet shows how you can create an index on the \"firstName\"\nfield with the \"en_US\" locale collation in ascending order: To check whether you created the collation successfully, retrieve a list\nof the indexes on that collection as follows: The following code snippet shows an example operation that specifies the\nsame collation and is covered by the index we created in the preceding code snippet: The operation uses the same collation as the one specified in the index. The operation is covered by the index that contains the collation. You can override the default collation on a collection by passing the\nnew collation as a parameter to one of the supported operations. However,\nsince the operation does not use an index, the operation may not perform\nas well as one that is covered by an index. For more information on the\ndisadvantages of sorting operations not covered by an index, see the server\nmanual page on  Use Indexes to Sort Query Results . The following code snippet shows an example query operation with the\nfollowing characteristics: The referenced collection contains the default collation \"en_US\" similar to\nthe one specified in the  Collection  section. The query specifies the Icelandic (\"is\") collation which is not covered\nby the collection's default collation index. Since the specified collation is not covered by an index, the sort\noperation is performed in-memory. While most MongoDB index types support collation, the following types support\nonly binary comparison: text 2d geoHaystack This section covers various collation options and how to specify them to\nfurther refine the ordering and matching behavior. You can use the  Collation.Builder  class to specify values for the\npreceding collation options. You can call the  build()  method to construct a\n Collation  object as shown in the following code snippet: For more information on the corresponding methods and parameters they\ntake, see the API Documentation for  Collation.Builder . Collation Option Description Locale Backwards Case-sensitivity Alternate Case First Max Variable Strength Normalization Numeric Ordering This section contains examples that demonstrate how to use a selection of\nMongoDB operations that support collations. In the following examples, we specify the  \"de@collation=phonebook\"  locale and\nvariant collation. The \"de\" part of the collation specifies the German\nlocale and the \"collation=phonebook\" part specifies a variant. The\n\"de\" locale collation contains rules for prioritizing proper nouns,\nidentified by capitalization of the first letter. In the\n\"collation=phonebook\" variant, characters with umlauts are ordered before\nthe same characters without them in an ascending sort. The following example demonstrates how you can apply a collation when\nretrieving sorted results from a collection. To perform this\noperation, call  find()  on the example collection and chain the\n collation()  and  sort()  methods to specify the order in which you want\nto receive the results. When we perform this operation on our  example collection ,\nthe output should resemble the following: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: find() sort() Sorts This section demonstrates how you can specify a collation in an\noperation that updates the first match from your query. To specify the\ncollation for this operation, instantiate a  FindOneAndUpdateOptions \nobject, set a collation on it, and pass it as a parameter to your call to\nthe  findOneAndUpdate()  method. In this example, we demonstrate the following: Since \"G\u00fcnter\" is lexically before \"Gunter\" using the\n de@collation=phonebook  collation in ascending order, the following operation\nreturns \"G\u00fcnter\" before \"Gunter\" in the results: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Retrieve the first document in our  example collection \nthat precedes \"Gunter\" in an ascending order. Set options for operation including the  \"de@collation=phonebook\" \ncollation. Add a new field \"verified\" with the value \"true\". Retrieve and print the updated document. The following code example uses imports from the\n import com.mongodb.client.model  package for convenience. findOneAndUpdate findOneAndUpdateOptions Filters Updates Sorts This section demonstrates how you can specify a numerical ordering of\nstrings in a collation in an operation that deletes the first match from your\nquery. To specify the collation for this operation, instantiate\na  FindOneAndDeleteOptions  object, set a numeric ordering collation on\nit, and pass it as a parameter to your call to the  findOneAndDelete() \nmethod. This example calls the  findOneAndDelete()  operation on a collection that\ncontains the following documents: These documents are represented by the following data class: In the collation, we set the  locale  option to \"en\" and the\n numericOrdering  option to \"true\" in order to sort strings based on their\nnumerical order. The numeric value of the string \"179\" is greater than the number 100, so\nthe preceding document is the only match. If we perform the same operation without the numerical ordering collation\non the original collection of three documents, the filter matches all of\nour documents since \"100\" comes before \"16\", \"84\", and \"179\" when ordering\nby binary collation. For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: The following code example uses imports from the\n import com.mongodb.client.model  package for convenience. findOneAndDelete FindOneAndDeleteOptions Filters Sorts This section demonstrates how you can specify a collation in an aggregation\noperation. In an aggregation operation, you can specify a series of\naggregation stages which is collectively called the aggregation pipeline. To\nperform an aggregation, call the  aggregate()  method on a\n MongoCollection  object. To specify a collation for an aggregation operation, call the  collation() \nmethod on the  AggregateFlow  returned by the aggregation operation.\nMake sure to specify a sort aggregation stage on which to apply the\ncollation in your aggregation pipeline. The following example shows how we can construct an aggregation pipeline on\nthe  example collection  and apply\na collation by specifying the following: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: A group aggregation stage using the  Aggregates.group()  helper to\nidentify each document by the  firstName  field and use that value as\nthe  _id  of the result. An accumulator in the group aggregation stage to sum the number of\ninstances of matching values in the  firstName  field. Apply an ascending sort to the  _id  field of the output documents of\nthe prior aggregation stage. Construct a collation object, specifying the German locale and\na collation strength that ignores accents and umlauts. aggregate() AggregateFlow CollationStrength Accumulators Aggregates Sorts",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\" : 1, \"firstName\" : \"Klara\" }\n{ \"_id\" : 2, \"firstName\" : \"Gunter\" }\n{ \"_id\" : 3, \"firstName\" : \"G\u00fcnter\" }\n{ \"_id\" : 4, \"firstName\" : \"J\u00fcrgen\" }\n{ \"_id\" : 5, \"firstName\" : \"Hannah\" }"
        },
        {
          "lang": "kotlin",
          "value": "data class FirstName(\n    @BsonId val id: Int, \n    val firstName: String, \n    val verified: Boolean = false\n)\n"
        },
        {
          "lang": "none",
          "value": "cote\ncot\u00e9\nc\u00f4te\nc\u00f4t\u00e9"
        },
        {
          "lang": "none",
          "value": "cote\nc\u00f4te\ncot\u00e9\nc\u00f4t\u00e9"
        },
        {
          "lang": "none",
          "value": "\"<locale code>@collation=<variant code>\""
        },
        {
          "lang": "none",
          "value": "\"de@collation=phonebook\""
        },
        {
          "lang": "none",
          "value": "\"de\""
        },
        {
          "lang": "kotlin",
          "value": "database.createCollection(\n    \"names\",\n    CreateCollectionOptions().collation(\n        Collation.builder().locale(\"en_US\").build()\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val collection = database.getCollection<FirstName>(\"names\")\nval indexInformation = collection.listIndexes().first()\nprintln(indexInformation.toJson())\n"
        },
        {
          "lang": "javascript",
          "value": "{\n  // ...\n  \"collation\": {\n     \"locale\": \"en_US\",\n     // ...\n  },\n  // ...\n}"
        },
        {
          "lang": "kotlin",
          "value": "val collection = database.getCollection<FirstName>(\"names\")\nval idxOptions = IndexOptions().collation(Collation.builder().locale(\"en_US\").build())\ncollection.createIndex(Indexes.ascending(FirstName::firstName.name), idxOptions)\n"
        },
        {
          "lang": "kotlin",
          "value": "val collection = database.getCollection<FirstName>(\"names\")\nval indexInformation = collection.listIndexes().first()\nprintln(indexInformation.toJson())\n"
        },
        {
          "lang": "javascript",
          "value": "{\n  // ...\n  \"collation\": {\n     \"locale\": \"en_US\",\n     // ...\n  },\n  // ...\n}"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find()\n    .collation(Collation.builder().locale(\"en_US\").build())\n    .sort(Sorts.ascending(FirstName::firstName.name));\n"
        },
        {
          "lang": "kotlin",
          "value": "val findFlow = collection.find()\n    .collation(Collation.builder().locale(\"is\").build())\n    .sort(Sorts.ascending(FirstName::firstName.name))\n"
        },
        {
          "lang": "kotlin",
          "value": "Collation.builder()\n    .caseLevel(true)\n    .collationAlternate(CollationAlternate.SHIFTED)\n    .collationCaseFirst(CollationCaseFirst.UPPER)\n    .collationMaxVariable(CollationMaxVariable.SPACE)\n    .collationStrength(CollationStrength.SECONDARY)\n    .locale(\"en_US\")\n    .normalization(false)\n    .numericOrdering(true)\n    .build()\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find()\n    .collation(Collation.builder().locale(\"de@collation=phonebook\").build())\n    .sort(Sorts.ascending(FirstName::firstName.name))\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "FirstName(id=3, firstName=G\u00fcnter, verified=false)\nFirstName(id=2, firstName=Gunter, verified=false)\nFirstName(id=5, firstName=Hannah, verified=false)\nFirstName(id=4, firstName=J\u00fcrgen, verified=false)\nFirstName(id=1, firstName=Klara, verified=false)"
        },
        {
          "lang": "kotlin",
          "value": "val result = collection.findOneAndUpdate(\n    Filters.lt(FirstName::firstName.name, \"Gunter\"),\n    Updates.set(\"verified\", true),\n    FindOneAndUpdateOptions()\n        .collation(Collation.builder().locale(\"de@collation=phonebook\").build())\n        .sort(Sorts.ascending(FirstName::firstName.name))\n        .returnDocument(ReturnDocument.AFTER)\n)\nprintln(result)\n"
        },
        {
          "lang": "console",
          "value": "FirstName(id=3, firstName=G\u00fcnter, verified=true)"
        },
        {
          "lang": "json",
          "value": "{ \"_id\" : 1, \"a\" : \"16 apples\" }\n{ \"_id\" : 2, \"a\" : \"84 oranges\" }\n{ \"_id\" : 3, \"a\" : \"179 bananas\" }"
        },
        {
          "lang": "kotlin",
          "value": "data class CollationExample(@BsonId val id: Int, val a: String)\n"
        },
        {
          "lang": "kotlin",
          "value": "val result = collection.findOneAndDelete(\n    Filters.gt(CollationExample::a.name, \"100\"),\n    FindOneAndDeleteOptions()\n        .collation(Collation.builder().locale(\"en\").numericOrdering(true).build())\n        .sort(Sorts.ascending(CollationExample::a.name))\n)\nprintln(result)\n"
        },
        {
          "lang": "console",
          "value": "CollationExample(id=3, a=179 bananas)"
        },
        {
          "lang": "kotlin",
          "value": "data class Result(@BsonId val id: String, val nameCount: Int)\nval groupStage = Aggregates.group(\n    \"\\$${FirstName::firstName.name}\",\n    Accumulators.sum(\"nameCount\", 1)\n)\nval sortStage = Aggregates.sort(Sorts.ascending(\"_id\"))\nval resultsFlow = collection.aggregate<Result>(listOf(groupStage, sortStage))\n    .collation(\n        Collation.builder().locale(\"de\")\n            .collationStrength(CollationStrength.PRIMARY)\n            .build()\n    )\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Result(id=Gunter, nameCount=2)\nResult(id=Hannah, nameCount=1)\nResult(id=J\u00fcrgen, nameCount=1)\nResult(id=Klara, nameCount=1)"
        }
      ],
      "preview": "In this guide, you can learn how to use collations with MongoDB to order your\nquery or aggregation operation results by string values. A collation is a set\nof character ordering and matching rules that apply to a specific language and\nlocale.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/connection/connect",
      "title": "Connect to MongoDB",
      "headings": [
        "MongoClient",
        "Connection URI",
        "Atlas Connection Example",
        "Other Ways to Connect to MongoDB",
        "Connect to a MongoDB Server on Your Local Machine",
        "Connect to a Replica Set"
      ],
      "paragraphs": "In this guide, you can learn how to connect to a MongoDB instance or\nreplica set using the Kotlin driver. You can view sample code to  connect to an Atlas cluster \nor continue reading to learn more about the  MongoClient  class and\nconnection URIs. You can connect to and communicate with MongoDB using the  MongoClient \nclass. Use the  MongoClient.create()  method to construct a  MongoClient . To learn more about how connection pools work in the driver, see the  FAQ page . All resource usage limits, such as max connections, apply to individual\n MongoClient  instances. To learn about the different settings you can use to control the\nbehavior of your  MongoClient , see the guide on\n MongoClient Settings . As each  MongoClient  represents a thread-safe pool of connections to the\ndatabase, most applications only require a single instance of a\n MongoClient , even across multiple threads. Always call  MongoClient.close()  to clean up resources when an\ninstance is no longer needed. The  connection URI  provides a set of instructions that the driver uses to\nconnect to a MongoDB deployment. It instructs the driver on how it should\nconnect to MongoDB and how it should behave while connected. The following\nfigure explains each part of a sample connection URI: This figure uses the  Standard Connection String Format ,\n mongodb  for the protocol. You can also use the  DNS Seed List Connection Format ,\n mongodb+srv , if you want more flexibility of deployment and the ability\nto change the servers in rotation without reconfiguring clients. The next part of the connection URI contains your credentials if you are\nusing a password-based authentication mechanism. Replace the value of  user \nwith your database username and  pass  with your database user's password. If your\nauthentication mechanism does not require credentials, omit this part of\nthe connection URI. The next part of the connection URI specifies the hostname or IP\naddress, followed by the port of your MongoDB instance. In the example,\n sample.host  represents the hostname and  27017  is the port number.\nReplace these values to refer to your MongoDB instance. The last part of the connection URI contains connection options as parameters.\nIn the example, we set two connection options:  maxPoolSize=20  and\n w=majority . For more information on connection options, skip to the\n Connection Options  section of this guide. If your deployment is on MongoDB Atlas, see the\n Atlas driver connection guide \nand select  Kotlin  from the language dropdown to retrieve your connection\nstring. To connect to a MongoDB deployment on Atlas, create a client. You can\ncreate a client that uses your connection string and other\nclient options by passing a  MongoClientSettings  object to the\n MongoClient.create()  method. To instantiate a  MongoClientSettings  object, use the builder method to specify\nyour connection string and any other client options, and then call the  build() \nmethod. Chain the  applyConnectionString()  method to the builder to specify your\nconnection URI. You can set the Stable API version client option to avoid\nbreaking changes when you upgrade to a new server version. To\nlearn more about the Stable API feature, see the  Stable API page . The following code shows how you can specify the connection string and\nthe Stable API client option when connecting to a MongoDB\ndeployment on Atlas and verify that the connection is successful: If you are connecting to a single MongoDB server instance or replica set\nthat is not hosted on Atlas, see the following sections to find out how to\nconnect. To test whether you can connect to your server, replace the connection\nstring in the  Connect to MongoDB Atlas  code\nexample and run it. If you need to run a MongoDB server on your local machine for development\npurposes instead of using an Atlas cluster, you need to complete the following: After you successfully start your MongoDB server, specify your connection\nstring in your driver connection code. If your MongoDB Server is running locally, you can use the connection string\n \"mongodb://localhost:<port>\"  where  <port>  is the port number you\nconfigured your server to listen for incoming connections. If you need to specify a different hostname or IP address, see our Server\nManual entry on  Connection Strings . Download the  Community \nor  Enterprise  version\nof MongoDB Server. Install and configure \nMongoDB Server. Start the server. Always secure your MongoDB server from malicious attacks. See our\n Security Checklist  for a\nlist of security recommendations. A MongoDB replica set deployment is a group of connected instances that\nstore the same set of data. This configuration of instances provides data\nredundancy and high data availability. To connect to a replica set deployment, specify the hostnames (or IP\naddresses) and port numbers of the members of the replica set. If you are not able to provide a full list of hosts in the replica set,\nyou can specify a single or subset of the hosts in the replica and\ninstruct the driver to perform automatic discovery in one of the following\nways: The following examples show how to specify multiple hosts to a  MongoClient \ninstance using either the  ConnectionString  or  MongoClientSettings \nclass. Select the tab that corresponds to your preferred class. Specify the name of the replica set as the value of the  replicaSet \nparameter Specify  false  as the value of the  directConnection  parameter Specify more than one host in the replica set Although you can specify a subset of the hosts in a replica set,\ninclude all the hosts in the replica set to ensure the driver is able to\nestablish the connection if one of the hosts are unreachable.",
      "code": [
        {
          "lang": "kotlin",
          "value": "// Replace the placeholder with your Atlas connection string\nval uri = \"<connection string>\"\n\n// Construct a ServerApi instance using the ServerApi.builder() method\nval serverApi = ServerApi.builder()\n    .version(ServerApiVersion.V1)\n    .build()\nval settings = MongoClientSettings.builder()\n    .applyConnectionString(ConnectionString(uri))\n    .serverApi(serverApi)\n    .build()\n// Create a new client and connect to the server\nval mongoClient = MongoClient.create(settings)\nval database = mongoClient.getDatabase(\"admin\")\ntry {\n    // Send a ping to confirm a successful connection\n    val command = Document(\"ping\", BsonInt64(1))\n    val commandResult = database.runCommand(command)\n    println(\"Pinged your deployment. You successfully connected to MongoDB!\")\n} catch (me: MongoException) {\n    System.err.println(me)\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val connectionString = ConnectionString(\"mongodb://host1:27017,host2:27017,host3:27017/\")\nval mongoClient = MongoClient.create(connectionString)\n"
        },
        {
          "lang": "kotlin",
          "value": "val seed1 = ServerAddress(\"host1\", 27017)\nval seed2 = ServerAddress(\"host2\", 27017)\nval seed3 = ServerAddress(\"host3\", 27017)\nval settings = MongoClientSettings.builder()\n    .applyToClusterSettings { builder ->\n        builder.hosts(\n            listOf(seed1, seed2, seed3)\n        )\n    }\n    .build()\nval mongoClient = MongoClient.create(settings)\n"
        }
      ],
      "preview": "In this guide, you can learn how to connect to a MongoDB instance or\nreplica set using the Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/connection/connection-options",
      "title": "Connection Options",
      "headings": [],
      "paragraphs": "This section explains MongoDB connection and authentication options\nsupported by the driver. You can pass the connection options as\nparameters of the connection URI to specify the behavior of the client. For a complete list of options, see the\n ConnectionString \nAPI reference page. Option Name Type Description minPoolSize integer Specifies the minimum number of connections that must exist at\nany moment in a single connection pool. maxPoolSize integer Specifies the maximum number of connections that a connection\npool may have at a given time. waitQueueTimeoutMS integer Specifies the maximum amount of time, in milliseconds that a\nthread may wait for a connection to become available. serverSelectionTimeoutMS integer Specifies the maximum amount of time, in milliseconds, the driver\nwill wait for server selection to succeed before throwing an\nexception. localThresholdMS integer When communicating with multiple instances of MongoDB in a replica\nset, the driver will only send requests to a server whose\nresponse time is less than or equal to the server with the fastest\nresponse time plus the local threshold, in milliseconds. heartbeatFrequencyMS integer Specifies the frequency, in milliseconds that the driver will\nwait between attempts to determine the current state of each\nserver in the cluster. replicaSet string Specifies that the  connection string \nprovided includes multiple hosts. When specified, the driver\nattempts to find all members of that set. ssl boolean Specifies that all communication with MongoDB instances should\nuse TLS/SSL. Superseded by the  tls  option. tls boolean Specifies that all communication with MongoDB instances should\nuse TLS. Supersedes the  ssl  option. tlsInsecure boolean Specifies that the driver should allow invalid hostnames for TLS\nconnections. Has the same effect as setting\n tlsAllowInvalidHostnames  to  true . To configure TLS security\nconstraints in other ways, use a\n custom SSLContext . tlsAllowInvalidHostnames boolean Specifies that the driver should allow invalid hostnames in the\ncertificate for TLS connections. Supersedes\n sslInvalidHostNameAllowed . connectTimeoutMS integer Specifies the maximum amount of time, in milliseconds, the Kotlin\ndriver waits for a connection to open before timing out. A value of\n 0  instructs the driver to never time out while waiting for a connection\nto open. socketTimeoutMS integer Specifies the maximum amount of time, in milliseconds, the Kotlin\ndriver will wait to send or receive a request before timing out.\nA value of  0  instructs the driver to never time out while waiting\nto send or receive a request. maxIdleTimeMS integer Specifies the maximum amount of time, in milliseconds, that the driver\nallows a pooled connection to idle before closing the\nconnection. A value of  0  indicates that there is no upper bound\non how long the driver allows a pooled connection to be idle. maxLifeTimeMS integer Specifies the maximum amount of time, in milliseconds, the Kotlin\ndriver will continue to use a pooled connection before closing the\nconnection. A value of  0  indicates that there is no upper bound\non how long the driver can keep a pooled connection open. journal boolean Specifies that the driver must wait for the connected MongoDB\ninstance to group commit to the journal file on disk for all writes. w string or integer Specifies the write concern. For more information on values, see\nthe server documentation for the  w option . wtimeoutMS integer Specifies a time limit, in milliseconds, for the write concern. For\nmore information, see the server documentation for the\n wtimeoutMS option .\nA value of  0  instructs the driver to never time out write operations. readPreference string Specifies the read preference. For more information on values, see\nthe server documentation for the\n readPreference option . readPreferenceTags string Specifies the read preference tags. For more information on values, see\nthe server documentation for the\n readPreferenceTags option . maxStalenessSeconds integer Specifies, in seconds, how stale a secondary can be before the\ndriver stops communicating with that secondary. The minimum value is\neither 90 seconds or the heartbeat frequency plus 10 seconds, whichever\nis greater. For more information, see the server documentation for the\n maxStalenessSeconds option .\nNot providing a parameter or explicitly specifying  -1  indicates\nthat there should be no staleness check for secondaries. authMechanism string Specifies the  authentication mechanism \nthat the driver should use if a credential\nwas supplied. authSource string Specifies the database that the supplied credentials should be\nvalidated against. authMechanismProperties string Specifies authentication properties for the specified authentication\nmechanism as a list of colon-separated properties and values.\nFor more information, see the server documentation for\nthe  authMechanismProperties option . appName string Specifies the name of the application provided to MongoDB instances\nduring the connection handshake. Can be used for server logs and\nprofiling. compressors string Specifies one or more compression algorithms that the driver\nwill attempt to use to compress requests sent to the connected\nMongoDB instance. Possible values include:  zlib ,  snappy ,\nand  zstd . zlibCompressionLevel integer Specifies the degree of compression that  Zlib \nshould use to decrease the size of requests to the connected MongoDB\ninstance. The level can range from  -1  to  9 , with lower values\ncompressing faster (but resulting in larger requests) and larger values\ncompressing slower (but resulting in smaller requests). retryWrites boolean Specifies that the driver must retry supported write operations\nif they fail due to a network error. retryReads boolean Specifies that the driver must retry supported read operations\nif they fail due to a network error. serverMonitoringMode string Specifies which server monitoring protocol the driver uses. When set to\n auto , the monitoring mode is determined by the environment in which\nthe driver is running. The driver uses  poll  mode in function-as-a-service\n(FaaS) environments and  stream  mode in other environments. uuidRepresentation string Specifies the UUID representation to use for read and write\noperations. For more information, see the driver documentation\nfor the\n MongoClientSettings.getUuidRepresentation() method . directConnection boolean Specifies that the driver must connect to the host directly. maxConnecting integer Specifies the maximum number of connections a pool may be establishing\nconcurrently. srvServiceName string Specifies the service name of the\n SRV resource records \nthe driver retrieves to construct your\n seed list .\nYou must use the\n DNS Seed List Connection Format \nin your\n connection URI \nto use this option.",
      "code": [],
      "preview": "This section explains MongoDB connection and authentication options\nsupported by the driver. You can pass the connection options as\nparameters of the connection URI to specify the behavior of the client.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/connection/mongoclientsettings",
      "title": "Specify MongoClient Settings",
      "headings": [
        "Overview",
        "MongoClient Settings",
        "Example",
        "Cluster Settings",
        "Example",
        "Socket Settings",
        "Example",
        "Connection Pool Settings",
        "Example",
        "Server Settings",
        "Example",
        "TLS/SSL Settings",
        "Example"
      ],
      "paragraphs": "In this guide, you can learn about the different settings to control\nthe behavior of your  MongoClient . The following sections describe commonly used settings: MongoClient Settings Cluster Settings Socket Settings Connection Pool Settings Server Settings TLS/SSL Settings You can control the behavior of your  MongoClient  by creating and passing\nin a  MongoClientSettings \nobject to the  MongoClient.create() \nmethod. To create a  MongoClientSettings  object, use the\n MongoClientSettings.builder()  method and chain methods to specify your\nsettings. After chaining them, use the  build()  method to create the\n MongoClientSettings  object. The following table describes all the methods you can chain to modify your\nconnection behavior: Method Description addCommandListener() Adds a listener for  command events . applicationName() Sets the logical name of the application using the  MongoClient . applyConnectionString() Applies the settings from the given  ConnectionString  to the\nbuilder. If you omit this method, the driver attempts to connect to\n localhost . applyToClusterSettings() Applies the  ClusterSettings.Builder  block and then sets the\n cluster settings . applyToConnectionPoolSettings() Applies the  ConnectionPoolSettings.Builder  block and then sets the\n connection pool settings . applyToServerSettings() Applies the  ServerSettings.Builder  block and then sets the\n server settings . applyToSocketSettings() Applies the  SocketSettings.Builder  block and then sets the\n socket settings . applyToSslSettings() Applies the  SslSettings.Builder  block and then sets the\n TLS/SSL settings . autoEncryptionSettings() Sets the  auto-encryption settings . codecRegistry() Sets the codec registry. Sets the  codec registry . commandListenerList() Sets the  command listeners . compressorList() Sets the  compressors  to use for compressing\nmessages to the server. credential() Sets the  credential . readConcern() Sets the  read concern . readPreference() Sets the  read preference . retryReads() Whether the driver should  retry reads \nif a network error occurs. retryWrites() Whether the driver should  retry writes \nif a network error occurs. serverApi() Sets the  server API  to use when sending\ncommands to the server. streamFactoryFactory() Sets the factory to use to create a  StreamFactory . uuidRepresentation() Sets the UUID representation to use when encoding instances of UUID\nand decoding BSON binary values with subtype of 3. writeConcern() Sets the  write concern . This example demonstrates specifying a  ConnectionString : Each setting has an  applyConnectionString()  method. They are\nrarely needed within the settings, so you should use this method as shown\nin  the preceding example . Some options in the settings map to a connection string option.\nIf you specify the same options in your settings and connection\nstring, the order you chain them determines which option the driver\nuses. The driver uses the  last  setting it reads. For example, this snippet contains settings with the following times\nfor the driver to connect to an available socket: Since the driver reads the socket settings options last, the driver\nexpects to connect to an available socket within  5 SECONDS  before\ntiming out. The connection string specifies within  2 SECONDS The  socket settings  specifies within\n 5 SECONDS To log the  MongoClient  instance settings,\nset the  org.mongodb.driver.client  named\nlogger to the  INFO  level. To learn more about logging with the MongoDB Kotlin Driver, see the\n Logging  guide. Chain the  applyToClusterSettings() \nmethod to modify the driver's behavior when interacting with your\nMongoDB cluster. The following table describes all the methods you can chain to your\nsettings to modify the driver's behavior: Method Description addClusterListener() Adds a listener for cluster-related events. applyConnectionString() Uses the settings from a  ConnectionString  object. applySettings() Uses the cluster settings specified in a  ClusterSettings  object. hosts() Sets all the specified locations of a Mongo server. localThreshold() Sets the amount of time that a server\u2019s round trip can take and still\nbe eligible for server selection. mode() Sets how to connect to a MongoDB server. requiredClusterType() Sets the type of cluster required for the cluster. requiredReplicaSetName() Sets the replica set name required for the cluster. serverSelectionTimeout() Sets the maximum time to select a primary node before throwing a\ntimeout exception. serverSelector() Adds a server selector to apply before server selection. srvHost() Sets the host name to use to look up an SRV DNS record to find the\nMongoDB hosts. When setting  srvHost , the driver does not process any\nassociated TXT records associated with the host. If you want to enable the processing of TXT records, you must\nspecify the SRV host in the connection string using the\n applyConnectionString()  method. srvMaxHosts() This example specifies for the driver to connect directly to a server,\nregardless of the type of MongoDB cluster it's a part of: This is analogous to the  directConnection  parameter you can specify\nin your connection URI. See  Connection Options  for more\ninformation. Chain the  applyToSocketSettings() \nmethod to modify the driver's behavior when connecting and communicating\nwith your MongoDB server. The following table describes all the methods you can chain to your settings\nto modify the driver's behavior: Method Description applyConnectionString() Uses the settings from a  ConnectionString  object. applySettings() Uses the socket settings specified in a  SocketSettings  object. applyToProxySettings() Applies the  ProxySettings.Builder  block and then sets the\n proxySettings  field. connectTimeout() Sets the maximum time to connect to an available socket before throwing\na timeout exception. readTimeout() Sets the maximum time to read to an available socket before throwing a\ntimeout exception. receiveBufferSize() Sets the socket's buffer size when receiving. sendBufferSize() Sets the socket's buffer size when sending. This example specifies the following driver behavior in a MongoDB socket: To connect to an available socket within  10 SECONDS To read from an available socket within  15 SECONDS Chain the  applyToConnectionPoolSettings() \nmethod to modify the way the driver manages its connection pool. The following table describes all the methods you can chain to your\nsettings to modify the driver's behavior: Method Description addConnectionPoolListener() Adds a listener for connection pool-related events. applyConnectionString() Uses the settings from a  ConnectionString  object. applySettings() Uses the connection pool settings specified in a\n ConnectionPoolSettings  object. maintenanceFrequency() Sets the frequency for running a maintenance job. maintenanceInitialDelay() Sets the time to wait before running the first maintenance job. maxConnectionIdleTime() Sets the maximum time a connection can be idle before it's closed. maxConnectionLifeTime() Sets the maximum time a pooled connection can be alive before it's\nclosed. maxWaitTime() Sets the maximum time to wait for an available connection. maxSize() Sets the maximum amount of connections associated with a connection\npool. minSize() Sets the minimum amount of connections associated with a connection\npool. This  maxSize  and  minSize  settings apply to each server\nin the cluster you connect the driver to. For example, assume you connect the driver to a cluster with three\n mongos  servers. This means that there can be at most  maxSize \nconnections and at least  minSize  connections to each  mongos  server. This example specifies the following driver behavior in a pool of\n Connection  types: The thread to wait at most  10 SECONDS  for an available connection To have at most  200  connections associated with the pool Chain the  applyToServerSettings() \nmethod to modify the driver's behavior when monitoring each MongoDB\nserver. The following table describes all the methods you can chain to your\nsettings to modify the driver's behavior: Method Description addServerListener() Adds a listener for server-related events. addServerMonitorListener() Adds a listener for server monitor-related events. applyConnectionString() Uses the settings from a  ConnectionString  object. applySettings() Uses the server settings specified in a  ServerSettings  object. heartbeatFrequency() Sets the interval for a cluster monitor to attempt reaching a server. minHeartbeatFrequency() Sets the minimum interval for server monitoring checks. serverMonitoringMode() Specifies which server monitoring protocol the driver uses. This example specifies the following driver behavior in a MongoDB server: The minimum interval for server monitoring checks to be at least\n 700 MILLISECONDS The cluster monitor to attempt reaching a server every  15 SECONDS Chain the  applyToSslSettings() \nmethod to modify the driver's behavior when using TLS/SSL to secure a\nconnection between your application and MongoDB. The following table describes all the methods you can chain to your\nsettings to modify the driver's behavior: Method Description applyConnectionString() Uses the settings from a  ConnectionString  object. applySettings() Uses the TLS/SSL settings specified in a  SslSettings  object. context() Sets the  SSLContext  for use when you enable TLS/SSL. enabled() Whether to enable TLS/SSL. (You must enable this for Atlas clusters.) invalidHostNameAllowed() Whether to allow a mismatch between the server\u2019s hostname and the\nhostname specified by the TLS certificate. This example specifies for the driver to enable TLS/SSL when connecting\nto MongoDB:",
      "code": [
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyConnectionString(ConnectionString(\"<your connection string>\"))\n        .build()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyConnectionString(ConnectionString(\"mongodb+srv:/<db_username>:<db_password>@<hostname>:<port>?connectTimeoutMS(2000)\"))\n        .applyToSocketSettings{ builder ->\n            builder.connectTimeout(5, TimeUnit.SECONDS)\n        }\n        .build()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyConnectionString(ConnectionString(\"mongodb+srv://host1.acme.com\"))\n        .build()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyToClusterSettings{ builder ->\n            builder.mode(ClusterConnectionMode.SINGLE)\n        }\n        .build()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyConnectionString(ConnectionString(\"<your connection string>\"))\n        .applyToSocketSettings{ builder ->\n            builder\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(15, TimeUnit.SECONDS)\n        }\n        .build()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyConnectionString(ConnectionString(\"<your connection string>\"))\n        .applyToConnectionPoolSettings{ builder ->\n            builder\n                .maxWaitTime(10, TimeUnit.SECONDS)\n                .maxSize(200)\n        }\n        .build()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyConnectionString(ConnectionString(\"<your connection string>\"))\n        .applyToServerSettings{ builder ->\n            builder\n                .minHeartbeatFrequency(700, TimeUnit.MILLISECONDS)\n                .heartbeatFrequency(15, TimeUnit.SECONDS)\n        }\n        .build()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyConnectionString(ConnectionString(\"<your connection string>\"))\n        .applyToSslSettings{ builder ->\n            builder.enabled(true)\n        }\n        .build()\n)\n"
        }
      ],
      "preview": "In this guide, you can learn about the different settings to control\nthe behavior of your MongoClient.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/connection/network-compression",
      "title": "Network Compression",
      "headings": [
        "Specify Compression Algorithms",
        "Compression Algorithm Dependencies"
      ],
      "paragraphs": "The MongoDB Kotlin Driver provides a connection option to compress messages,\nThis reduces the amount of data passed over the network between MongoDB\nand your application. The driver supports the following algorithms: The driver tests against the following versions of these libraries: If you specify multiple compression algorithms, the driver selects the\nfirst one that is supported by the MongoDB instance that the driver is\nconnected to. Snappy : available in MongoDB 3.4 and later. Zlib : available in MongoDB 3.6 and later. Zstandard : available in MongoDB 4.2 and later. org.xerial.snappy:snappy-java:1.1.8.4 com.github.luben:zstd-jni:1.5.5-2 If your application requires Snappy or Zstandard compression, you must add\n explicit dependencies  for those algorithms. You can enable compression on your connection by specifying the\nalgorithms in the following ways: Adding the  compressors  parameter to your  ConnectionString  instance Calling the  compressorList()  method from the  MongoClientSettings  builder To enable compression on your connection in a  ConnectionString \ninstance, specify the  compressors  parameter. You can specify\none or more of the following values for the  compressors  parameter: The following example shows how to specify Snappy, Zlib, and\nZstandard as the compression algorithms for a connection: \"snappy\"  for  Snappy  compression \"zlib\"  for  Zlib  compression \"zstd\"  for  Zstandard  compression To enable compression using within your  MongoClientSettings ,\ncall the  compressorList() \nbuilder method and pass one or more  MongoCompressor \ninstances as a parameter. You can specify compression algorithms by calling the following\nmethods from  MongoCompressor : The following example shows how to specify Snappy, Zlib, and\nZstandard as the compression algorithms for a connection: createSnappyCompressor()  for  Snappy  compression createZlibCompressor()  for  Zlib  compression createZstdCompressor()  for  Zstandard  compression The JDK supports  Zlib  compression natively, but\n Snappy  and\n Zstandard  depend on open source\nimplementations. See\n snappy-java  and\n zstd-java  for details.",
      "code": [
        {
          "lang": "kotlin",
          "value": "// Replace the placeholders with values from your MongoDB deployment's connection string\nval connectionString = ConnectionString(\"mongodb+srv://<user>:<password>@<cluster-url>/?compressors=snappy,zlib,zstd\")\n\n// Create a new client with your settings\nval mongoClient = MongoClient.create(connectionString)\n"
        },
        {
          "lang": "kotlin",
          "value": "// Replace the placeholder with your MongoDB deployment's connection string\nval uri = \"<connection string>\"\n\nval settings = MongoClientSettings.builder()\n    .applyConnectionString(ConnectionString(uri))\n    .compressorList(\n        listOf(\n            MongoCompressor.createSnappyCompressor(),\n            MongoCompressor.createZlibCompressor(),\n            MongoCompressor.createZstdCompressor())\n    )\n    .build()\n\n// Create a new client with your settings\nval mongoClient = MongoClient.create(settings)\n"
        }
      ],
      "preview": "The MongoDB Kotlin Driver provides a connection option to compress messages,\nThis reduces the amount of data passed over the network between MongoDB\nand your application.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/connection/socks5",
      "title": "Connect to MongoDB by Using a SOCKS5 Proxy",
      "headings": [
        "Overview",
        "SOCKS5 Proxy Settings",
        "Examples",
        "Specify Proxy Settings in the MongoClientSettings",
        "Specify Proxy Settings in the Connection String",
        "API Documentation"
      ],
      "paragraphs": "In this guide, you can learn how to use the MongoDB Kotlin Driver to connect\nto MongoDB by using a  SOCKS5 proxy . SOCKS5 is a standardized\nprotocol for communicating with network services through a proxy server. To learn more about the SOCKS5 protocol, see the Wikipedia entry on\n SOCKS . The proxy settings specify the SOCKS5 proxy server address and your\nauthentication credentials. You can specify your settings in an instance of\n MongoClientSettings  or in your connection string. The following table describes the SOCKS5 client options: Name Accepted Values Description proxyHost String Specifies the SOCKS5 proxy IPv4 address, IPv6 address, or hostname.\nYou must provide this value to connect to a SOCKS5 proxy. proxyPort Non-negative integer Specifies the TCP port number of the SOCKS5 proxy server. If you\nset a value for  proxyHost , this option defaults to  1080 ,\nbut you can specify a different port number. proxyUsername String Specifies the username for authentication to the SOCKS5 proxy server.\nThe driver ignores  null  and empty string values for this setting.\nThe driver requires that you pass values for both  proxyUsername \nand  proxyPassword  or that you omit both values. proxyPassword String Specifies the password for authentication to the SOCKS5 proxy server.\nThe driver ignores  null  and empty string values for this setting.\nThe driver requires that you pass values for both  proxyUsername \nand  proxyPassword  or that you omit both values. The following examples show how to instantiate a  MongoClient  that connects\nto MongoDB by using a SOCKS5 proxy. The proxy settings can be specified in a\n MongoClientSettings  instance or a connection string. These examples use\nthe placeholder values described in the  SOCKS5 Proxy Settings  section.\nReplace the placeholders with your proxy specifications and credentials. The following code example shows how to specify SOCKS5 proxy settings by\nusing the  applyToSocketSettings()  builder method when creating a\n MongoClientSettings  instance: The following code example shows how to specify SOCKS5 proxy settings in\nyour connection string: To learn more about the methods and types discussed in this guide, see the\nfollowing API documentation: MongoClientSettings.Builder SocketSettings.Builder MongoClient.create() ProxySettings.Builder",
      "code": [
        {
          "lang": "kotlin",
          "value": "val uri = \"<connection string>\"\n\nval mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyConnectionString(ConnectionString(uri))\n        .applyToSocketSettings{ builder ->\n            builder\n                .applyToProxySettings{ proxyBuilder ->\n                    proxyBuilder\n                        .host(\"<proxyHost>\")\n                        .port(\"<proxyPort>\".toInt())\n                        .username(\"<proxyUsername>\")\n                        .password(\"<proxyPassword>\")\n                        .build()\n                }\n        }\n        .build()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val connectionString = ConnectionString(\n    \"mongodb+srv://<user>:<password>@<cluster-url>/?\" +\n        \"proxyHost=<proxyHost>\" +\n        \"&proxyPort=<proxyPort>\" +\n        \"&proxyUsername=<proxyUsername>\" +\n        \"&proxyPassword=<proxyPassword>\"\n)\n\nval mongoClient = MongoClient.create(connectionString)\n"
        }
      ],
      "preview": "In this guide, you can learn how to use the MongoDB Kotlin Driver to connect\nto MongoDB by using a SOCKS5 proxy. SOCKS5 is a standardized\nprotocol for communicating with network services through a proxy server.",
      "tags": "code example, security, connection string",
      "facets": {
        "genre": ["reference"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/connection/tls",
      "title": "Enable TLS/SSL on a Connection",
      "headings": [
        "Overview",
        "Enable TLS/SSL",
        "Configure Certificates",
        "Configure the JVM Trust Store",
        "Configure the JVM Key Store",
        "Configure a Client-Specific Trust Store and Key Store",
        "Disable Hostname Verification",
        "Restrict Connections to TLS 1.2 Only",
        "Customize TLS/SSL Configuration through the Java SE SSLContext",
        "Online Certificate Status Protocol (OCSP)",
        "Client-Driven OCSP",
        "OCSP Stapling"
      ],
      "paragraphs": "In this guide, you can learn how to connect to MongoDB instances with the\n TLS/SSL \nsecurity protocol using the underlying TLS/SSL support in the JDK. To\nconfigure your connection to use TLS/SSL, enable the TLS/SSL settings in\neither the  ConnectionString \nor  MongoClientSettings . If you experience trouble setting up your TLS/SSL connection, you can\nuse the  -Djavax.net.debug=all  system property to view more\nlog statements. See  the Oracle guide to debugging TLS/SSL connections \nfor more information. You can enable TLS/SSL for the connection to your MongoDB instance\nin two different ways: through a parameter in your connection string, or\nusing a method in the  MongoClientSettings.Builder  class. If you connect by using the DNS seedlist protocol, indicated by the\n mongodb+srv  prefix in your connection string, the driver\nautomatically enables TLS/SSL. To disable it, set the  tls \nparameter value to  false  in your connection string, or set the\n enabled  property to  false  in the  SslSettings.Builder \nblock when creating a  MongoClientSettings  instance. To learn more about connection behavior when you use a DNS seedlist,\nsee the  SRV Connection Format \nsection in the Server manual. To enable TLS/SSL on a connection with a  ConnectionString , assign the connection string\nparameter  tls  a value of  true  in the connection string passed to\n MongoClient.create() : To configure your  MongoClient 's TLS/SSL connection options using the\n MongoClientSettings.Builder  class, call the\n applyToSslSettings() \nmethod. Set the  enabled  property to  true  in the  SslSettings.Builder \nblock to enable TLS/SSL: Kotlin applications that initiate TLS/SSL requests require access to\ncryptographic certificates that prove identity for the application\nitself and other applications with which the application\ninteracts. You can configure access to these certificates in your application with\nthe following mechanisms: The JVM Trust Store and JVM Key Store A Client-Specific Trust Store and Key Store The following sections are based on the documentation for Oracle JDK,\nso some parts may be inapplicable to your JDK or to the custom TLS/SSL\nimplementation you use. The JVM trust store saves certificates that securely identify other\napplications with which your Kotlin application interacts. Using these\ncertificates, your application can prove that the connection to another\napplication is genuine and secure from tampering by third parties. If your MongoDB instance uses a certificate that is signed by an\nauthority that is not present in the JRE's default certificate store,\nyour application must configure two system properties to initiate\nSSL/TLS requests. These properties ensure that your application can\nvalidate the TLS/SSL certificate presented by a connected MongoDB instance. You can create a trust store with the  keytool \ncommand line tool provided as part of the JDK: By default, the JRE includes many commonly used public certificates\nfrom signing authorities like  Let's Encrypt . As a result, you can connect to\ninstances of  MongoDB Atlas  (or any other\nserver whose certificate is signed by an authority in the JRE's default\ncertificate store) with TLS/SSL without configuring the trust store. javax.net.ssl.trustStore : the path to a trust store containing the\ncertificate of the signing authority javax.net.ssl.trustStorePassword : the password to access the trust\nstore defined in  javax.net.ssl.trustStore The JVM key store saves certificates that securely identify your Kotlin\napplication to other applications. Using these certificates, other\napplications can prove that the connection to your application is\ngenuine and secure from tampering by third parties. An application that initiates TLS/SSL requests needs to set two JVM system\nproperties to ensure that the client presents a TLS/SSL certificate to\nthe MongoDB server: You can create a key store with the  keytool \nor  openssl \ncommand line tool. For more information on configuring a Kotlin application to use TLS/SSL,\nplease see the  JSSE Reference Guide . By default, MongoDB instances do not perform client certificate\nvalidation. You must configure the key store if you configured your MongoDB\ninstance to validate client certificates. javax.net.ssl.keyStore : the path to a key store containing the client's\nTLS/SSL certificates javax.net.ssl.keyStorePassword : the password to access the key store\ndefined in  javax.net.ssl.keyStore You can configure a client-specific trust store and key store using the\n init()  method of the  SSLContext  class. You can find an example showing how to configure a client with an  SSLContext \ninstance in the\n Customize TLS/SSL Configuration with an SSLContext section of this guide . For more information on the  SSLContext  class, see the API\ndocumentation for  SSL Context . By default, the driver ensures that the hostname included in the server's\nTLS/SSL certificates matches the hostnames provided when constructing\na  MongoClient . To disable hostname verification for your\napplication, you can explicitly disable this by setting the\n invalidHostNameAllowed  property of the builder to  true  in the\n applytoSslSettings()  builder lambda: Disabling hostname verification can make your configuration\n insecure .\nDisable hostname verification only for testing purposes or\nwhen there is no other alternative. To restrict your application to use only the TLS 1.2 protocol, set the\n jdk.tls.client.protocols  system property to \"TLSv1.2\". Java Runtime Environments (JREs) before Java 8 only enabled\nthe TLS 1.2 protocol in update releases. If your JRE has not enabled\nthe TLS 1.2 protocol, upgrade to a later release to connect by using\nTLS 1.2. If your TLS/SSL configuration requires customization, you can\nset the  sslContext  property of your  MongoClient  by\npassing an  SSLContext \nobject to the builder in the  applyToSslSettings()  lambda: OCSP is a standard used to check whether X.509 certificates have been\nrevoked. A certificate authority can add an X.509 certificate to the\nCertificate Revocation List (CRL) before the expiry time to invalidate\nthe certificate. When a client sends an X.509 certificate during the TLS\nhandshake, the CA's revocation server checks the CRL and returns a status\nof \"good\", \"revoked\", or \"unknown\". The driver supports the following variations of OCSP: The following sections describe the differences between them and how to enable\nthem for your application. Client-Driven OCSP OCSP Stapling The Kotlin driver uses the JVM arguments configured for the application\nand cannot be overridden for a specific  MongoClient  instance. In client-driven OCSP, the client sends the certificate in an OCSP request to\nan OCSP responder after receiving the certificate from the server. The OCSP\nresponder checks the status of the certificate with a certificate\nauthority (CA) and reports whether it's valid in a response sent to the\nclient. To enable client-driven OCSP for your application, set the following JVM\nsystem properties: Property Value com.sun.net.ssl.checkRevocation Set this property to  true  to enable revocation checking. ocsp.enable Set this property to  true  to enable client-driven OCSP. If the OCSP responder is unavailable, the TLS support provided by the\nJDK reports a \"hard fail\". This differs from the \"soft fail\" behavior of\nthe MongoDB Shell and some other drivers. OCSP stapling is a mechanism in which the server must obtain the signed\ncertificate from the certificate authority (CA) and include it in a\ntime-stamped OCSP response to the client. To enable OCSP stapling for your application, set the following JVM system\nproperties: For more information about OCSP, check out the following resources: Property Description com.sun.net.ssl.checkRevocation Set this property to  true  to enable revocation checking. jdk.tls.client.enableStatusRequestExtension Oracle JDK 8 Documentation on  how to enable OCSP for an application Official IETF specification for OCSP (RFC 6960)",
      "code": [
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\"mongodb+srv://<user>:<password>@<cluster-url>?tls=true\")\n"
        },
        {
          "lang": "kotlin",
          "value": "val settings = MongoClientSettings.builder()\n    .applyConnectionString(ConnectionString(\"<connection string>\"))\n    .applyToSslSettings { builder ->\n        builder.enabled(true)\n    }\n    .build()\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "console",
          "value": "keytool -importcert -trustcacerts -file <path to certificate authority file>\n         -keystore <path to trust store> -storepass <password>"
        },
        {
          "lang": "kotlin",
          "value": "val settings = MongoClientSettings.builder()\n    .applyConnectionString(ConnectionString(\"<connection string>\"))\n    .applyToSslSettings { builder ->\n        builder.enabled(true)\n        builder.invalidHostNameAllowed(true)\n    }\n    .build()\nval mongoClient = MongoClient.create(settings);\n"
        },
        {
          "lang": "kotlin",
          "value": "// You can customize SSL settings using the SSLContext\nval sslContext = SSLContext.getDefault()\n\nval settings = MongoClientSettings.builder()\n    .applyToSslSettings { builder ->\n        builder.enabled(true)\n        builder.context(sslContext)\n    }\n    .build()\nval mongoClient = MongoClient.create(settings);\n"
        }
      ],
      "preview": "In this guide, you can learn how to connect to MongoDB instances with the\nTLS/SSL\nsecurity protocol using the underlying TLS/SSL support in the JDK. To\nconfigure your connection to use TLS/SSL, enable the TLS/SSL settings in\neither the ConnectionString\nor MongoClientSettings.",
      "tags": "code example, security, authentication",
      "facets": {
        "genre": ["reference"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/connection",
      "title": "Connection Guide",
      "headings": ["Overview"],
      "paragraphs": "Learn how to set up a connection and specify connection behavior from your\napplication to a MongoDB deployment using the driver in the following\nsections: For information about authenticating with a MongoDB instance,\nsee  Authentication Mechanisms  and  Enterprise Authentication Mechanisms . Connect to MongoDB View a List of Connection Options Specify Connection Behavior with the MongoClient Class Enable Network Compression Enable TLS/SSL on a Connection Connect to MongoDB by Using a SOCKS5 Proxy",
      "code": [],
      "preview": "Learn how to set up a connection and specify connection behavior from your\napplication to a MongoDB deployment using the driver in the following\nsections:",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/compound-operations",
      "title": "Compound Operations",
      "headings": [
        "Overview",
        "How to Use Compound Operations",
        "Find and Update",
        "Example",
        "Find and Replace",
        "Example",
        "Find and Delete",
        "Example",
        "Avoiding a Race Condition",
        "Example With Race Condition",
        "Example Without Race Condition"
      ],
      "paragraphs": "In this guide, you can learn how to perform  compound operations  with\nthe MongoDB Kotlin driver. Compound operations consist of a read and write operation performed as one\n atomic operation . An atomic operation is an operation which either completes\nentirely, or does not complete at all. Atomic operations cannot partially complete. Atomic operations can help you avoid  race conditions  in your code. A\nrace condition occurs when your code's behavior is dependent on the order of\nuncontrollable events. MongoDB supports the following compound operations: If you need to perform more complex tasks atomically, such as reading and\nwriting to more than one document, use  transactions . Transactions are a\nfeature of MongoDB and other databases that lets you define an arbitrary\nsequence of database commands as an atomic operation. For more information on atomic operations and atomicity, see\n the MongoDB manual entry for atomicity and transactions . For more information on transactions, see\n the MongoDB manual entry for transactions . Find and update one document Find and replace one document Find and delete one document This section shows how to use each compound operation with the MongoDB Kotlin Driver. The following examples use a collection containing these two sample documents. This data is modeled with the following Kotlin data class: By default, each compound operation returns your found document in the state\nbefore your write operation. You can retrieve your found document in the\nstate after your write operation by using the options class corresponding to\nyour compound operation. You can see an example of this configuration in the\n Find and Replace example below . To find and update one document, use the  findOneAndUpdate()  method of the\n MongoCollection  class. The  findOneAndUpdate()  method returns your found\ndocument or  null  if no documents match your query. The following example uses the  findOneAndUpdate()  method to find a\ndocument with the  color  field set to  \"green\"  and  update the\n food  field in that document to  \"pizza\" . The example also uses a  FindOneAndUpdateOptions  instance to specify the\nfollowing options: For more information on the  Projections  class, see our\n guide on the Projections builder . For more information on the upsert operation, see our\n guide on upserts . For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Specify an upsert, which inserts the document specified by the query filter if no documents match the query. Set a maximum execution time of 5 seconds for this operation on the MongoDB\ninstance. If the operation takes longer, the  findOneAndUpdate()  method\nwill throw a  MongoExecutionTimeoutException . findOneAndUpdate() FindOneAndUpdateOptions MongoExecutionTimeoutException To find and replace one document, use the  findOneAndReplace()  method of the\n MongoCollection  class. The  findOneAndReplace()  method returns your found\ndocument or  null  if no documents match your query. The following example uses the  findOneAndReplace()  method to find a\ndocument with the  color  field set to  \"green\"  and  replace it\nwith the following document: The example also uses a  FindOneAndReplaceOptions  instance to specify that\nthe returned document should be in the state after our replace operation. For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: findOneAndReplace() FindOneAndReplaceOptions To find and delete one document, use the  findOneAndDelete()  method of the\n MongoCollection  class. The  findOneAndDelete()  method returns your found\ndocument or  null  if no documents match your query. The following example uses the  findOneAndDelete()  method to find and\ndelete the document with the largest value in the  _id  field. The example uses a  FindOneAndDeleteOptions  instance to specify a\ndescending sort on the  _id  field. For more information on the  Sorts  class, see our\n guide on the Sorts builder . For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: findOneAndDelete() FindOneAndDeleteOptions In this section we explore two examples. The first example contains a\nrace condition, the second example uses a compound operation to\navoid the race condition present in the first example. For both examples, let's imagine that we run a hotel with one room and that we\nhave a small Kotlin program to help us checkout this room to a guest. The following document in MongoDB represents the room: This data is modeled with the following Kotlin data class: Let's say our app uses this  bookARoomUnsafe  method to checkout our room to\na guest: Imagine two separate guests, Jan and Pat, try to book the room with this method\nat the same time. Jan sees this output: And Pat sees this output: When we look at our database, we see the following: Pat will be unhappy. When Pat shows up to our hotel, Jan will be\noccupying her room. What went wrong? Here is the sequence of events that happened from the perspective of our MongoDB\ninstance: Notice that for a brief moment Pat had reserved the room, but as Jan's update\noperation was the last to execute our document has  \"Jan\"  as the guest. Find and return an empty room for Jan. Find and return an empty room for Pat. Update the room to booked for Pat. Update the room to booked for Jan. Let's use a compound operation to avoid the race condition and\nalways give our users the correct message. Imagine two separate guests, Jan and Pat, try to book the room with this method\nat the same time. Jan sees this output: And Pat sees this output: When we look at our database, we see the following: Pat got the correct message. While she might be sad she didn't get the\nreservation, at least she knows not to travel to our hotel. Here is the sequence of events that happened from the perspective of our MongoDB\ninstance: For information on the  Updates  class, see our\n guide on the Updates builder . For more information of the  Filters  class, see our\n guide on the Filters builder . For more information on the  findOneAndUpdate()  method, see\nthe API Documentation for the  MongoCollection class . Find an empty room for Jan and reserve it. Try to find an empty room for Pat and reserve it. When there are not any rooms left, return  null . Your MongoDB instance places a write lock on the document you are modifying\nfor the duration of your compound operation.",
      "code": [
        {
          "lang": "json",
          "value": " {\"_id\": 1, \"food\": \"donut\", \"color\": \"green\"}\n {\"_id\": 2, \"food\": \"pear\", \"color\": \"yellow\"}"
        },
        {
          "lang": "kotlin",
          "value": "data class FoodOrder(\n    @BsonId val id: Int,\n    val food: String,\n    val color: String\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "\nval filter = Filters.eq(FoodOrder::color.name, \"green\")\nval update = Updates.set(FoodOrder::food.name, \"pizza\")\nval options = FindOneAndUpdateOptions()\n    .upsert(true)\n    .maxTime(5, TimeUnit.SECONDS)\n/* The result variable contains your document in the\n    state before your update operation is performed\n    or null if the document was inserted due to upsert\n    being true */\nval result = collection.findOneAndUpdate(filter, update, options)\n\nprintln(result)\n"
        },
        {
          "lang": "console",
          "value": "FoodOrder(id=1, food=donut, color=green)"
        },
        {
          "lang": "json",
          "value": "{\"music\": \"classical\", \"color\": \"green\"}"
        },
        {
          "lang": "kotlin",
          "value": "data class Music(\n    @BsonId val id: Int,\n    val music: String,\n    val color: String\n)\n\nval filter = Filters.eq(FoodOrder::color.name, \"green\")\nval replace = Music(1, \"classical\", \"green\")\nval options = FindOneAndReplaceOptions()\n    .returnDocument(ReturnDocument.AFTER)\nval result = collection.withDocumentClass<Music>().findOneAndReplace(filter, replace, options)\n\nprintln(result)\n"
        },
        {
          "lang": "console",
          "value": "Music(id=1, music=classical, color=green)"
        },
        {
          "lang": "kotlin",
          "value": "val sort = Sorts.descending(\"_id\")\nval filter = Filters.empty()\nval options = FindOneAndDeleteOptions().sort(sort)\nval result = collection.findOneAndDelete(filter, options)\n\nprintln(result)\n"
        },
        {
          "lang": "console",
          "value": "FoodOrder(id=2, food=pear, color=yellow)"
        },
        {
          "lang": "json",
          "value": " {\"_id\": 1, \"guest\": null, \"room\": \"Blue Room\", \"reserved\": false}"
        },
        {
          "lang": "kotlin",
          "value": "data class HotelRoom(\n    @BsonId val id: Int,\n    val guest: String? = null,\n    val room: String,\n    val reserved: Boolean = false\n)\n"
        },
        {
          "lang": "none",
          "value": "You got the Blue Room, Jan"
        },
        {
          "lang": "none",
          "value": "You got the Blue Room, Pat"
        },
        {
          "lang": "json",
          "value": " {\"_id\": 1, \"guest\": \"Jan\", \"room\": \"Blue Room\", \"reserved\": false}"
        },
        {
          "lang": "kotlin",
          "value": "suspend fun bookARoomUnsafe(guestName: String) {\n    val filter = Filters.eq(\"reserved\", false)\n    val myRoom = hotelCollection.find(filter).firstOrNull()\n    if (myRoom == null) {\n        println(\"Sorry, we are booked, $guestName\")\n        return\n    }\n\n    val myRoomName = myRoom.room\n\n    println(\"You got the $myRoomName, $guestName\")\n\n    val update = Updates.combine(Updates.set(\"reserved\", true), Updates.set(\"guest\", guestName))\n    val roomFilter = Filters.eq(\"_id\", myRoom.id)\n    hotelCollection.updateOne(roomFilter, update)\n}\n"
        },
        {
          "lang": "console",
          "value": "You got the Blue Room, Jan"
        },
        {
          "lang": "console",
          "value": "Sorry, we are booked, Pat"
        },
        {
          "lang": "json",
          "value": " {\"_id\": 1, \"guest\": \"Jan\", \"room\": \"Blue Room\", \"reserved\": false}"
        },
        {
          "lang": "kotlin",
          "value": "suspend fun bookARoomSafe(guestName: String) {\n    val update = Updates.combine(\n        Updates.set(HotelRoom::reserved.name, true),\n        Updates.set(HotelRoom::guest.name, guestName)\n    )\n    val filter = Filters.eq(\"reserved\", false)\n    val myRoom = hotelCollection.findOneAndUpdate(filter, update)\n    if (myRoom == null) {\n        println(\"Sorry, we are booked, $guestName\")\n        return\n    }\n\n    val myRoomName = myRoom.room\n    println(\"You got the $myRoomName, $guestName\")\n}\n"
        }
      ],
      "preview": "In this guide, you can learn how to perform compound operations with\nthe MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/query-document",
      "title": "Specify a Query",
      "headings": [
        "Overview",
        "Comparison Operators",
        "Logical Operators",
        "Array Operators",
        "Element Operators",
        "Evaluation Operators"
      ],
      "paragraphs": "In this guide, you can learn how to specify a query in the MongoDB Kotlin\ndriver. Most CRUD operations allow you to narrow the set of matched documents by\nspecifying matching criteria in a  query filter . Query filters\ncontain one or more query operators that apply to specific fields which\ndetermine which documents to include in the result set. In this page, we cover the following query operators with\nexamples on how to use them: The examples in this guide use the following documents in the\n paint_purchases  collection: This data is modeled with the following Kotlin data class: Comparison Operators Logical Operators Array Operators Element Operators Evaluation Operators Comparison operators query data based on comparisons with values in a\ncollection. Common comparison operators include  gt()  for \"greater\nthan\" comparisons,  lte()  for \"less than or equal to\" comparisons,\nand  ne()  for \"not equal to \" comparisons. The following example uses the  Filters.gt()  method to match all\ndocuments where the value of  qty  is greater than  7  in the\n paint_purchases  collection: Logical operators query data using logic applied to the results of\nfield-level operators. Common logical operators include  and()  where\nall operators must be true, and  or()  where at least one of the\noperators must be true. The following example uses the  Filters.and()  method to match\ndocuments where the value of  qty  is less than or equal to  5  and\nthe value of  color  is not  \"pink\"  in the  paint_purchases \ncollection: Array operators query data based on the value or quantity of elements in\nan array field. The following example uses the  Filters.size()  method to match\ndocuments where the size of the  vendor  list is  3  in the\n paint_purchases  collection: Element operators query data based on the presence or type of a field. The following example uses the  Filters.exists()  method to match\ndocuments that have a  rating  in the  paint_purchases  collection: Evaluation operators query data on higher level logic, like regex\nand text searches. The following example uses the  Filters.regex()  method to match\ndocuments that have a  color  ending with the letter  \"k\"  in the\n paint_purchases  collection: For more information about the operators mentioned in this guide,\nsee the following Server Manual Entries: Query Operators Comparison Operators Logical Operators Array Operators Element Operators Evaluation Operators",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 9, \"vendor\": [\"A\", \"E\"] }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 8, \"vendor\": [\"B\", \"D\", \"F\"], \"rating\": 5 }\n{ \"_id\": 3, \"color\": \"blue\", \"qty\": 5, \"vendor\": [\"A\", \"E\"] }\n{ \"_id\": 4, \"color\": \"white\", \"qty\": 6, \"vendor\": [\"D\"], \"rating\": 9 }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 4, \"vendor\": [\"A\", \"B\"] }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 3, \"vendor\": [\"C\"] }\n{ \"_id\": 7, \"color\": \"green\", \"qty\": 8, \"vendor\": [\"C\", \"E\"], \"rating\": 7 }\n{ \"_id\": 8, \"color\": \"black\", \"qty\": 7, \"vendor\": [\"A\", \"C\", \"D\"] }"
        },
        {
          "lang": "kotlin",
          "value": "data class PaintOrder(\n    @BsonId val id: Int,\n    val qty: Int,\n    val color: String,\n    val vendor: List<String>,\n    val rating: Int? = null\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.gt(\"qty\", 7)\nval findFlow = collection.find(filter)\nfindFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=1, qty=9, color=red, vendor=[A, E], rating=null)\nPaintOrder(id=2, qty=8, color=purple, vendor=[B, D, F], rating=5)\nPaintOrder(id=7, qty=8, color=green, vendor=[C, E], rating=7)"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.and(Filters.lte(\"qty\", 5), Filters.ne(\"color\", \"pink\"))\nval findFlow = collection.find(filter)\nfindFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=3, qty=5, color=blue, vendor=[A, E], rating=null)\nPaintOrder(id=5, qty=4, color=yellow, vendor=[A, B], rating=null)"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.size(\"vendor\", 3)\nval findFlow = collection.find(filter)\nfindFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=2, qty=8, color=purple, vendor=[B, D, F], rating=5)\nPaintOrder(id=8, qty=7, color=black, vendor=[A, C, D], rating=null)"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.exists(\"rating\")\nval findFlow = collection.find(filter)\nfindFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=2, qty=8, color=purple, vendor=[B, D, F], rating=5)\nPaintOrder(id=4, qty=6, color=white, vendor=[D], rating=9)\nPaintOrder(id=7, qty=8, color=green, vendor=[C, E], rating=7)"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.regex(\"color\", \"k$\")\nval findFlow = collection.find(filter)\nfindFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=6, qty=3, color=pink, vendor=[C], rating=null)\nPaintOrder(id=8, qty=7, color=black, vendor=[A, C, D], rating=null)"
        }
      ],
      "preview": "In this guide, you can learn how to specify a query in the MongoDB Kotlin\ndriver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/read-operations/change-streams",
      "title": "Open Change Streams",
      "headings": [
        "Overview",
        "Open a Change Stream",
        "Example",
        "Apply Aggregation Operators to your Change Stream",
        "Example",
        "Split Large Change Stream Events",
        "Include Pre-images and Post-images",
        "Create a Collection with Pre-Image and Post-Images Enabled",
        "Pre-image Configuration Example",
        "Post-image Configuration Example"
      ],
      "paragraphs": "In this guide, you can learn how to use a  change stream  to monitor\nreal-time changes to your database. A change stream is a MongoDB server\nfeature that allows your application to subscribe to data changes on a single\ncollection, database, or deployment. You can specify a set of aggregation\noperators to filter and transform the data your application receives.\nWhen connecting to MongoDB v6.0 or later, you can configure the events\nto include the document data before and after the change. Learn how to open and configure your change streams in the following\nsections: Open a Change Stream Apply Aggregation Operators to your Change Stream Split Large Change Stream Events Include Pre-images and Post-images You can open a change stream to subscribe to specific types of data changes\nand produce change events in your application. To open a change stream, call the  watch()  method on an instance of a\n MongoCollection ,  MongoDatabase , or  MongoClient . The object on which you call the  watch()  method on determines the scope of\nevents that the change stream listens for. If you call  watch()  on a  MongoCollection , the change stream monitors\na collection. If you call  watch()  on a  MongoDatabase , the change stream monitors all\ncollections in that database. If you call  watch()  on a  MongoClient , the change stream monitors all\nchanges in the connected MongoDB deployment. Standalone MongoDB deployments don't support change streams because\nthe feature requires a replica set oplog. To learn more about the oplog,\nsee the  Replica Set Oplog  server manual page. The following code example shows how to open a change stream and print\nchange stream events whenever the data in the collection changes: An insert operation on the collection should produce output similar to the\nfollowing text: For a runnable example, see the  Watch for Changes  usage example page. To learn more about the  watch()  method, see the following API\ndocumentation: MongoCollection.watch() MongoDatabase.watch() MongoClient.watch() You can pass an aggregation pipeline as a parameter to the  watch()  method\nto specify which change events the change stream receives. To learn which aggregation operators your MongoDB server version supports, see\n Modify Change Stream Output . The following code example shows how you can apply an aggregation pipeline to\nconfigure your change stream to receive change events for only insert and\nupdate operations: When the change stream receives an update change event, the preceding code\nexample outputs the following text: When connecting to MongoDB v7.0 or later,\nyou can use the  $changeStreamSplitLargeEvent  aggregation operator to\nsplit event documents that exceed 16 MB into smaller fragments. Use the  $changeStreamSplitLargeEvent  operator only when you expect\nthe change stream events to exceed the document size limit. For\nexample, you might use this feature if your application requires full\ndocument pre-images or post-images. A  $changeStreamSplitLargeEvent  aggregation stage returns\nfragments sequentially. You can access the fragments by using a change\nstream cursor. Each fragment document includes a  splitEvent  object that\ncontains the following fields: The following example opens a change stream that includes an aggregation\npipeline with an  $changeStreamSplitLargeEvent  aggregation stage to\nsplit large events: To learn more about the  $changeStreamSplitLargeEvent  aggregation operator,\nsee  $changeStreamSplitLargeEvent (aggregation)  in the\nServer manual. Field Description fragment The index of the fragment, starting at  1 of The total number of fragments that compose the split event You can have only one  $changeStreamSplitLargeEvent  stage in your\naggregation pipeline, and it must be the last stage in the pipeline. You can configure the change event to contain or omit the following data: To receive change stream events that include a pre-image or post-image, you\nmust connect to a MongoDB v6.0 or later deployment and set up the following: The  pre-image  which is a document that represents the version of the\ndocument before the operation if it exists The  post-image  which is a document that represents the version of the\ndocument after the operation if it exists Enable pre-images and post-images for the collection on your MongoDB\ndeployment. To learn how to enable these on your deployment, see the\n Change Streams with Document Pre- and Post-Images \nMongoDB server manual page. To learn how to instruct the driver to create a collection with pre-images\nand post-images enabled, see the  Create a Collection with Pre-Image and Post-Images Enabled \nsection. Configure your change stream to retrieve either or both the pre-images and\npost-images. To configure your change stream to include the pre-image, see\nthe  Pre-image Configuration Example . To configure your change stream to include the post-image, see the\n Post-image Configuration Example . To create a collection with the pre-image and post-image option using the\ndriver, specify an instance of   ChangeStreamPreAndPostImagesOptions \nand call the  createCollection()  method as shown in the following example: You can change the pre-image and post-image option in an existing collection\nby running the  collMod  command from the MongoDB Shell. To learn how to\nperform this operation, see the  collMod \nserver manual documentation. When you modify this option on a collection, any change streams open on\nthat collection in your application may fail if configured to require\nreceiving the pre-image or post-image. The following code example shows how you can configure a change stream to\ninclude the pre-image and output the results: The preceding example configures the change stream to use the\n FullDocumentBeforeChange.REQUIRED  option. This configures the change\nstream to return pre-images for replace, update, and delete change events and\nfor the server to raise an error if the pre-image is unavailable. Suppose an application updated the  latestVersion  field of a document in a\ncollection of software library dependencies from the value of  2.0.0  to\n 2.1.0 . The corresponding change event output by the preceding code example\nshould resemble the following text: For a list of options, see the  FullDocumentBeforeChange \nAPI documentation. The following code example shows how you can configure a change stream to\ninclude the post-image and output the results: The preceding example configures the change stream to use the\n FullDocument.UPDATE_LOOKUP  option. This configures the change\nstream to return both the deltas between the original and changed document\nand a copy of the document at some point in time after the change occurred. Suppose an application updated the  population  field of a document from\nthe value of  800  to  950  in a collection of city census data. The\ncorresponding change event output by the preceding code example should\nresemble the following text: For a list of options, see the  FullDocument \nAPI documentation.",
      "code": [
        {
          "lang": null,
          "value": "Received a change event: ChangeStreamDocument{\n   operationType='insert',\n   resumeToken={\"_data\": \"825EC...\"},\n   namespace=myDb.myChangeStreamCollection,\n   ...\n}"
        },
        {
          "lang": "kotlin",
          "value": "\n// Launch the change stream in a separate coroutine,\n// so you can cancel it later.\nval job = launch {\n    val changeStream = collection.watch()\n    changeStream.collect {\n        println(\"Received a change event: $it\")\n    }\n}\n\n// Perform MongoDB operations that trigger change events...\n\n// Cancel the change stream when you're done listening for events.\njob.cancel()\n"
        },
        {
          "lang": "text",
          "value": "Received a change event: ChangeStreamDocument{\noperationType=update,\nresumeToken={...},\n..."
        },
        {
          "lang": "kotlin",
          "value": "val pipeline = listOf(\n    Aggregates.match(Filters.`in`(\"operationType\",\n        listOf(\"insert\", \"update\")))\n)\n\n// Launch the change stream in a separate coroutine,\n// so you can cancel it later.\nval job = launch {\n    val changeStream = collection.watch(pipeline)\n    changeStream.collect {\n        println(\"Received a change event: $it\")\n    }\n}\n\n// Perform MongoDB operations that trigger change events...\n\n// Cancel the change stream when you're done listening for events.\njob.cancel()\n"
        },
        {
          "lang": "kotlin",
          "value": "val pipeline = listOf(BsonDocument().append(\"\\$changeStreamSplitLargeEvent\", BsonDocument()))\n\nval job = launch {\n    val changeStream = collection.watch(pipeline)\n    changeStream.collect {\n        println(\"Received a change event: $it\")\n    }\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val collectionOptions = CreateCollectionOptions()\ncollectionOptions.changeStreamPreAndPostImagesOptions(ChangeStreamPreAndPostImagesOptions(true))\ndatabase.createCollection(\"myChangeStreamCollection\", collectionOptions)\n"
        },
        {
          "lang": "text",
          "value": "Received a change event: ChangeStreamDocument{\n   operationType=update,\n   resumeToken={...}\n   namespace=software.libraries,\n   destinationNamespace=null,\n   fullDocument=null,\n   fullDocumentBeforeChange=Document{{_id=6388..., latestVersion=2.0.0, ...}},\n   ..."
        },
        {
          "lang": "kotlin",
          "value": "val job = launch {\n    val changeStream = collection.watch()\n        .fullDocumentBeforeChange(FullDocumentBeforeChange.REQUIRED)\n    changeStream.collect {\n        println(it)\n    }\n}\n// Perform MongoDB operations that trigger change events...\n\n// Cancel the change stream when you're done listening for events.\njob.cancel()\n"
        },
        {
          "lang": "text",
          "value": "Received a change event: ChangeStreamDocument{\n   operationType=update,\n   resumeToken={...},\n   namespace=censusData.cities,\n   destinationNamespace=null,\n   fullDocument=Document{{_id=6388..., city=Springfield, population=950, ...}},\n   updatedFields={\"population\": 950}, ...\n   ..."
        },
        {
          "lang": "kotlin",
          "value": "val job = launch {\n    val changeStream = collection.watch()\n        .fullDocument(FullDocument.UPDATE_LOOKUP)\n    changeStream.collect {\n        println(it)\n    }\n}\n\n// Perform MongoDB operations that trigger change events...\n\n// Cancel the change stream when you're done listening for events.\njob.cancel()\n"
        }
      ],
      "preview": "In this guide, you can learn how to use a change stream to monitor\nreal-time changes to your database. A change stream is a MongoDB server\nfeature that allows your application to subscribe to data changes on a single\ncollection, database, or deployment. You can specify a set of aggregation\noperators to filter and transform the data your application receives.\nWhen connecting to MongoDB v6.0 or later, you can configure the events\nto include the document data before and after the change.",
      "tags": "code example, monitoring, aggregation",
      "facets": {
        "genre": ["reference"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/read-operations/flow",
      "title": "Access Data From a Flow",
      "headings": [
        "Overview",
        "Terminal Methods",
        "Find the First Document",
        "Count Number of Results",
        "Convert Results to a List",
        "Iterate through Results",
        "Explain the Query"
      ],
      "paragraphs": "In this guide, you can learn how to access data using a  Flow  with the\nMongoDB Kotlin driver. A  Flow  is a data type built into Kotlin coroutines that represent a stream\nof values that are being computed asynchronously. The Kotlin coroutine driver\nuses flows to represent the results of database read operations. This page uses an initiating method,  find()  to show how to access\ndata from a  FindFlow . The  find()  method creates and returns an instance of a\n FindFlow . A  FindFlow  allows you to browse the documents\nmatched by your search criteria and to further specify which documents\nto see by setting parameters through methods. The following ways to access and store data apply to\nother iterables such as an  AggregateFlow . Terminal methods execute an operation on the MongoDB server after\nconfiguring all parameters of a  Flow  instance controlling the\noperation. Use the  firstOrNull()  method to retrieve the first document in your query\nresults or  null  if there are no results: Alternatively, you can use the  first()  method to retrieve the first document\nin your query or throw a  NoSuchElementException  if there are no results: These methods are often used when your query filter will match one\ndocument, such as when filtering by a unique index. Use the  count()  method to retrieve the number of results in the query: Use the  toList()  method to store your query results in a  List : This method is often used when your query filter returns a small number\nof documents that can fit into available memory. Use the  collect()  method to iterate through fetched documents and\nensure that the flow closes if there is an early termination: Use the  explain()  method to view information about how MongoDB\nexecutes your operation. The  explain()  method returns  execution plans  and performance\nstatistics. An execution plan is a potential way MongoDB\ncan complete an operation. The  explain()  method provides both the\nwinning plan (the plan MongoDB executed) and rejected plans. The following example prints the JSON representation of the\nwinning plan for aggregation stages that produce execution plans: For more information on the explain operation, see the following\nServer Manual Entries: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: You can specify the level of detail of your explanation by passing a\nverbosity level to the  explain()  method. The following table shows all verbosity levels for explanations and\ntheir intended use cases: Verbosity Level Use Case ALL_PLANS_EXECUTIONS You want to know which plan MongoDB will choose to run your query. EXECUTION_STATS You want to know if your query is performing well. QUERY_PLANNER You have a problem with your query and you want as much information\nas possible to diagnose the issue. Explain Output Query Plans collect() explain() ExplainVerbosity",
      "code": [
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find()\nval firstResultOrNull = resultsFlow.firstOrNull()\n"
        },
        {
          "lang": "kotlin",
          "value": "try {\n    val resultsFlow = collection.find()\n    val firstResult = resultsFlow.first()\n} catch (e: NoSuchElementException) {\n    println(\"No results found\")\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find()\nval count = resultsFlow.count()\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find()\nval results = resultsFlow.toList()\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find()\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "kotlin",
          "value": "val explanation = collection.find().explain(ExplainVerbosity.EXECUTION_STATS)\nval jsonSummary = explanation.getEmbedded(\n    listOf(\"queryPlanner\", \"winningPlan\"),\n    Document::class.java\n).toJson()\nprintln(jsonSummary)\n"
        },
        {
          "lang": "json",
          "value": "{ \"stage\": \"COLLSCAN\", \"direction\": \"forward\" }"
        }
      ],
      "preview": "In this guide, you can learn how to access data using a Flow with the\nMongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/read-operations/geo",
      "title": "Search Geospatially",
      "headings": [
        "Overview",
        "Coordinates on Earth",
        "GeoJSON Positions",
        "GeoJSON Types",
        "Index",
        "Coordinates on a 2D Plane",
        "Index",
        "Geospatial Queries",
        "Query Operators",
        "Query Parameters",
        "Examples",
        "Query by Proximity",
        "Query Within a Range"
      ],
      "paragraphs": "In this guide, you can learn how to search  geospatial data  with the\nMongoDB Kotlin Driver, and the different geospatial data formats supported by MongoDB. Geospatial data is data that represents a geographical location on\nthe surface of the Earth. Examples of geospatial data include: Locations of movie theaters Borders of countries Routes of bicycle rides Dog exercise areas in New York City To store and query your geospatial data in MongoDB, use  GeoJSON . GeoJSON is\na data format created by the Internet Engineering Task Force (IETF). Here is the location of MongoDB headquarters in GeoJSON: For definitive information on GeoJSON, see the\n official IETF specification . A position represents a single place on Earth, and exists in code as an array\ncontaining two or three number values: Longitude in the first position (required) Latitude in the second position (required) Elevation in the third position (optional) GeoJSON orders coordinates as longitude first and latitude second. This may\nbe surprising as geographic coordinate system conventions generally list\nlatitude first and longitude second. Make sure to check what format any other\ntools you are working with use. Popular tools such as OpenStreetMap and Google\nMaps list coordinates as latitude first and longitude second. Your GeoJSON object's type determines its geometric shape. Geometric shapes are\nmade up of positions. Here are some common GeoJSON types and how you can specify them with positions: To learn more about the shapes you can use in MongoDB, see the\n GeoJSON manual entry . Point : a single position. This could represent the location of a\n sculpture . LineString : an array of two or more positions, thus forming a series of line\nsegments. This could represent\n the route of the Great Wall of China . Polygon : an array of positions in which the first and last\nposition are the same, thus enclosing some space. This could represent\n the land within Vatican City . To query data stored in the GeoJSON format, add the field containing\nGeoJSON data to a  2dsphere  index. The following snippet creates a\n 2dsphere  index on the  location.geo  field using the  Indexes  builder: For more information on the  Indexes  builder, see our\n guide on the Indexes builder . You can store geospatial data using  x  and  y  coordinates on\na two-dimensional Euclidean plane. We refer to coordinates on a two-dimensional\nplane as \"legacy coordinate pairs\". Legacy coordinate pairs have the following structure: Your field should contain an array of two values in which the first represents\nthe  x  axis value and the second represents the  y  axis value. To query data stored as legacy coordinate pairs, you must add the field containing\nlegacy coordinate pairs to  a  2d  index. The following snippet creates a\n 2d  index on the  coordinates  field using the  Indexes  builder: For more information on the  Indexes  builder, see our\n guide on the Indexes builder . For more information on legacy coordinate pairs, see the\n MongoDB server manual page on legacy coordinate pairs . Spherical ( 2dsphere ) and flat ( 2d ) indexes support some, but\nnot all, of the same query operators. For a full list of operators\nand their index compatibility, see the\n manual entry for geospatial queries . Geospatial queries consist of a query operator and GeoJSON shapes as query\nparameters. To query your geospatial data, use one of the following query operators: You can specify these query operators in the MongoDB Kotlin driver with the\n near() ,  geoWithin() ,  nearSphere() , and  geoIntersects()  utility\nmethods of the  Filters  builder class. For more information on geospatial query operators, see the\n manual entry for geospatial queries . For more information on  Filters , see our\n guide on the Filters builder . $near $geoWithin $nearSphere $geoIntersects   requires a 2dsphere index To specify a shape to use in a geospatial query, use the\n Position ,  Point ,  LineString , and  Polygon  classes of the MongoDB\nKotlin driver. For a full list of the GeoJSON shapes available in the MongoDB Kotlin driver, see the\n GeoJSON package \nAPI Documentation. The following examples use the MongoDB Atlas sample dataset. You can learn how\nto  set up your own free-tier Atlas cluster and how to load the sample dataset\nin our  quick start guide . The examples use the  theaters  collection in the  sample_mflix  database\nfrom the sample dataset. The examples require the following imports: The data is modeled using the following Kotlin data class: The results are modeled using the following Kotlin data class: The  theaters  collection already contains a  2dsphere  index on the\n \"${Theater::location.name}.${Theater.Location::geo.name}\"  field. To search for and return documents from nearest to farthest from a point, use\nthe  near()  static utility method of the  Filters  builder class. The\n near()  method constructs a query with the  $near  query operator. The following example queries for theaters between  10,000  and  5,000 \nmeters from the Great Lawn of Central Park: For more information on the  $near  operator, see the\n reference documentation for $near . For more information on  Filters , see\n our guide on the Filters builder . MongoDB uses the\n same reference system \nas GPS satellites to calculate geometries over the Earth. To search for geospatial data within a specified shape use the  geoWithin() \nstatic utility method of the  Filters  builder class. The  geoWithin() \nmethod constructs a query with the  $geoWithin  query operator. The following example searches for movie theaters in a section of Long Island. The following figure shows the polygon defined by the\n longIslandTriangle  variable and dots representing the locations of\nthe movie theaters returned by our query. For more information on the  $geoWithin  operator, see the\n reference documentation for $geoWithin For more information on the operators you can use in your query, see the\n MongoDB server manual page on geospatial query operators",
      "code": [
        {
          "lang": "json",
          "value": "\"MongoDB Headquarters\" : {\n   \"type\": \"point\",\n   \"coordinates\": [-73.986805, 40.7620853]\n}"
        },
        {
          "lang": "kotlin",
          "value": "collection.createIndex((Indexes.geo2dsphere(\"location.geo\")))\n"
        },
        {
          "lang": "json",
          "value": "\"<field name>\" : [ x, y ]"
        },
        {
          "lang": "kotlin",
          "value": "collection.createIndex((Indexes.geo2d(\"coordinates\")))\n"
        },
        {
          "lang": null,
          "value": "import com.mongodb.client.model.geojson.Point\nimport com.mongodb.client.model.geojson.Polygon\nimport com.mongodb.client.model.geojson.Position\nimport com.mongodb.client.model.Filters.near\nimport com.mongodb.client.model.Filters.geoWithin\nimport com.mongodb.client.model.Projections.fields\nimport com.mongodb.client.model.Projections.include\nimport com.mongodb.client.model.Projections.excludeId"
        },
        {
          "lang": "kotlin",
          "value": "data class Theater(\n    val theaterId: Int,\n    val location: Location\n) {\n    data class Location(\n        val address: Address,\n        val geo: Point\n    ) {\n        data class Address(\n            val street1: String,\n            val street2: String? = null,\n            val city: String,\n            val state: String,\n            val zipcode: String\n        )\n    }\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "data class TheaterResults(\n    val location: Location\n) {\n    data class Location(\n        val address: Address\n    ) {\n        data class Address(\n            val city: String\n        )\n    }\n}\n\n"
        },
        {
          "lang": "kotlin",
          "value": "val database = client.getDatabase(\"sample_mflix\")\nval collection = database.getCollection<TheaterResults>(\"theaters\")\nval centralPark = Point(Position(-73.9667, 40.78))\nval query = Filters.near(\n    \"${Theater::location.name}.${Theater.Location::geo.name}\", centralPark, 10000.0, 5000.0\n)\nval projection = Projections.fields(\n    Projections.include(\n        \"${Theater::location.name}.${Theater.Location::address.name}.${Theater.Location.Address::city.name}\"),\n    Projections.excludeId()\n)\nval resultsFlow = collection.find(query).projection(projection)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "TheaterResults(location=Location(address=Address(city=Bronx)))\nTheaterResults(location=Location(address=Address(city=New York)))\nTheaterResults(location=Location(address=Address(city=New York)))\nTheaterResults(location=Location(address=Address(city=Long Island City)))\nTheaterResults(location=Location(address=Address(city=New York)))\nTheaterResults(location=Location(address=Address(city=Secaucus)))\nTheaterResults(location=Location(address=Address(city=Jersey City)))\nTheaterResults(location=Location(address=Address(city=Elmhurst)))\nTheaterResults(location=Location(address=Address(city=Flushing)))\nTheaterResults(location=Location(address=Address(city=Flushing)))\nTheaterResults(location=Location(address=Address(city=Flushing)))\nTheaterResults(location=Location(address=Address(city=Elmhurst)))"
        },
        {
          "lang": "kotlin",
          "value": "val longIslandTriangle = Polygon(\n    listOf(\n        Position(-72.0, 40.0),\n        Position(-74.0, 41.0),\n        Position(-72.0, 39.0),\n        Position(-72.0, 40.0)\n    )\n)\nval projection = Projections.fields(\n    Projections.include(\n        \"${Theater::location.name}.${Theater.Location::address.name}.${Theater.Location.Address::city.name}\"),\n    Projections.excludeId()\n)\nval geoWithinComparison = Filters.geoWithin(\n    \"${Theater::location.name}.${Theater.Location::geo.name}\", longIslandTriangle\n)\nval resultsFlow = collection.find<TheaterResults>(geoWithinComparison)\n    .projection(projection)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "TheaterResults(location=Location(address=Address(city=Baldwin))))\nTheaterResults(location=Location(address=Address(city=Levittown)))\nTheaterResults(location=Location(address=Address(city=Westbury)))\nTheaterResults(location=Location(address=Address(city=Mount Vernon)))\nTheaterResults(location=Location(address=Address(city=Massapequa)))"
        }
      ],
      "preview": "In this guide, you can learn how to search geospatial data with the\nMongoDB Kotlin Driver, and the different geospatial data formats supported by MongoDB.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/read-operations/limit",
      "title": "Limit the Number of Returned Results",
      "headings": [
        "Overview",
        "Sample Documents",
        "Specify a Limit",
        "Combining Skip and Limit"
      ],
      "paragraphs": "In this guide, you can learn how to limit the number of results returned\nfrom read operations with the MongoDB Kotlin driver. Use  limit()  to cap the number of documents that a read operation returns.\nThis instance method designates the maximum number of\ndocuments that a read operation can return. If there are not enough documents\nto reach the specified limit, it can return a smaller number.\nIf you use  limit()  with the  skip()  instance method, the skip applies\nfirst and the limit only applies to the documents left over after\nthe skip. For more information on the  skip()  method, see our\n guide on Skipping Returned Documents . The following examples demonstrate, respectively, how to insert data into\na collection, how to use  limit()  to restrict the number of returned documents,\nand how to combine  limit()  with  skip()  to further narrow the results returned from a query. The following sections feature examples that update this sample document: This data is modeled with the following Kotlin data class: The next example queries the collection to return the top three\nlongest books. It first matches all the documents with the query, then sorts on the\n length  field to return books with longer lengths before\nbooks with shorter lengths. Lastly, it limits the return value to  3  documents,\nand returns the following three documents, sorted by length: The order in which you call  limit()  and  sort()  does not matter\nbecause the find command always applies the sort first and the\nlimit after it. The following two calls are equivalent: To see the next three longest books, append the  skip()  method to your\n find()  call. The integer argument passed to  skip()  will determine\nhow many documents the find operation returns. This operation returns the\ndocuments that describe the fourth through sixth longest books: You can combine  skip()  and  limit()  in this way to implement paging for your\ncollection, returning only small subsets of the collection at one time. For more information about the methods and classes mentioned in this guide,\nsee the following API Documentation: In order to ensure stable sorts across multiple queries, you must sort\nusing a unique key (such as  _id ). Otherwise, a call to  skip() \nand  limit()  may produce unpredictable results when combined with\n sort() . For example, consider the following data: If you sorted by  type  alone,  sort()  does not guarantee the same order\nupon return. Appending  skip()  and  limit()  to the  sort() \ncould return different documents for different queries. In this case, sorting\nby  data  or  serial_no  would guarantee a stable sort, as both are unique keys. FindFlow.collect() MongoCollection.find()",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"title\": \"The Brothers Karamazov\", \"author\": \"Dostoyevsky\", \"length\": 824 }\n{ \"_id\": 2, \"title\": \"Les Mis\u00e9rables\", \"author\": \"Hugo\", \"length\": 1462  }\n{ \"_id\": 3, \"title\": \"Atlas Shrugged\", \"author\": \"Rand\", \"length\": 1088  }\n{ \"_id\": 4, \"title\": \"Infinite Jest\", \"author\": \"Wallace\", \"length\": 1104  }\n{ \"_id\": 5, \"title\": \"Cryptonomicon\", \"author\": \"Stephenson\", \"length\": 918  }\n{ \"_id\": 6, \"title\": \"A Dance with Dragons\", \"author\": \"Martin\", \"length\": 1104  }"
        },
        {
          "lang": "kotlin",
          "value": "data class Book(\n    @BsonId val id: Int,\n    val title: String,\n    val author: String,\n    val length: Int\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val results = collection.find()\n    .sort(descending(\"length\"))\n    .limit(3)\n\nresults.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "  Book(id=2, title=Les Mis\u00e9rables, author=Hugo, length=1462)\n  Book(id=6, title=A Dance with Dragons, author=Martin, length=1104)\n  Book(id=4, title=Infinite Jest, author=Wallace, length=1104)"
        },
        {
          "lang": "kotlin",
          "value": "    collection.find().sort(descending(\"length\")).limit(3)\n    collection.find().limit(3).sort(descending(\"length\"))\n"
        },
        {
          "lang": "kotlin",
          "value": "val results = collection.find()\n    .sort(descending(\"length\"))\n    .skip(3)\n    .limit(3)\n\nresults.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "  Book(id=3, title=Atlas Shrugged, author=Rand, length=1088)\n  Book(id=5, title=Cryptonomicon, author=Stephenson, length=918)\n  Book(id=1, title=The Brothers Karamazov, author=Dostoyevsky, length=824)"
        },
        {
          "lang": "json",
          "value": "{ type: \"computer\", data: \"1\", serial_no: 235235 }\n{ type: \"computer\", data: \"2\", serial_no: 235237 }\n{ type: \"computer\", data: \"3\", serial_no: 235239 }\n{ type: \"computer\", data: \"4\", serial_no: 235241 }"
        }
      ],
      "preview": "In this guide, you can learn how to limit the number of results returned\nfrom read operations with the MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/read-operations/project",
      "title": "Specify Which Fields to Return",
      "headings": ["Overview", "Behavior", "Explanation"],
      "paragraphs": "In this guide, you can learn how to control which fields appear in\ndocuments returned from read operations with the MongoDB Kotlin driver. Many read requests require only a subset of fields in a document.\nFor example, when logging a user in you may only need their username, and\nnot all of their profile information. By default, queries in MongoDB return\nall fields in matching documents. You can use a  projection  to return\nonly the data you need. A projection is a document that instructs MongoDB which fields of a\ndocument to return. Use the  Projections  class\nto construct a projection document. Projections work in two ways: These two methods of projection are mutually exclusive: if you\nexplicitly include fields, you cannot explicitly exclude fields, and\nvice versa. Explicitly including fields. This has the side-effect of implicitly\nexcluding all unspecified fields. Implicitly excluding fields. This has the side-effect of implicitly\nincluding all unspecified fields. The  _id  field is  not  subject to these mechanics. You must\nexplicitly exclude the  _id  field if you do not want it returned.\nYou can exclude the  _id  field even if you have specified certain\nfields to include. Consider the following collection containing documents that describe\nvarieties of fruit: This data is modeled using the following Kotlin data class: In the following query, pass the projection to return the  name \nfield of each document. The results are modeled using the  FruitName  Kotlin data class: The projection document specifies that the read operation result should\n include  the  name  field of each returned document. As a result, this\nprojection implicitly excludes the  qty  and  rating  fields. Chaining\nthis projection to  find()  with an empty query filter yields the\nabove results. Despite the fact that this projection only explicitly included the\n name  field, the query also returned the  _id  field, represented by  id  in the data class. The  _id  field is a special case: it is always included in every query\nresult unless explicitly excluded. That's because the  _id  field is a\nunique identifier for each document, a property that can be useful when\nconstructing queries. The  _id  is the only exception to the mutually exclusive include-exclude\nbehavior in projections: you  can  explicitly exclude the  _id  field\neven when explicitly including other fields if you do not want  _id \nto be present in returned documents. The projection document specifies that the read operation result should\n include  the  name  field of each returned document, and specifies to\n exclude  the  _id  field. As a result, this projection implicitly\nexcludes the  qty  and  rating  fields. Chaining this projection to\n find()  with an empty query filter yields the above results. You can also specify multiple fields to include in your projection. This example that identifies two fields to include in the projection yields\nthe following results using the  FruitRating  Kotlin data class: For additional projection examples, see the\n MongoDB Manual page on Project Fields to Return from Query . The order in which you specify the fields in the projection does not\nalter the order in which they are returned.",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"name\": \"apples\", \"qty\": 5, \"rating\": 3 },\n{ \"_id\": 2, \"name\": \"bananas\", \"qty\": 7, \"rating\": 1 },\n{ \"_id\": 3, \"name\": \"oranges\", \"qty\": 6, \"rating\": 2 },\n{ \"_id\": 4, \"name\": \"avocados\", \"qty\": 3, \"rating\": 5 },"
        },
        {
          "lang": "kotlin",
          "value": "data class Fruit(\n    @BsonId val id: Int,\n    val name: String,\n    val qty: Int,\n    val rating: Int\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "data class FruitName(\n    @BsonId val id: Int? = null,\n    val name: String\n)\n\n// Return all documents with only the name field\nval filter = Filters.empty()\nval projection = Projections.fields(\n    Projections.include(FruitName::name.name)\n)\nval flowResults = collection.find<FruitName>(filter).projection(projection)\n\nflowResults.collect { println(it)}\n"
        },
        {
          "lang": "console",
          "value": "FruitName(id=1, name=apples),\nFruitName(id=2, name=bananas),\nFruitName(id=3, name=oranges),\nFruitName(id=4, name=avocados)"
        },
        {
          "lang": "kotlin",
          "value": "data class FruitName(\n    @BsonId val id: Int? = null,\n    val name: String\n)\n\n// Return all documents with *only* the name field\n// excludes the id\nval filter = Filters.empty()\nval projection = Projections.fields(\n    Projections.include(FruitName::name.name),\n    Projections.excludeId()\n)\nval flowResults = collection.find<FruitName>(filter).projection(projection)\n\nflowResults.collect { println(it)}\n"
        },
        {
          "lang": "console",
          "value": "FruitName(name=apples),\nFruitName(name=bananas),\nFruitName(name=oranges),\nFruitName(name=avocados)"
        },
        {
          "lang": "kotlin",
          "value": "data class FruitRating(\n    val name: String,\n    val rating: Int\n)\n\nval filter = Filters.empty()\nval projection = Projections.fields(\n    Projections.include(FruitRating::name.name, FruitRating::rating.name),\n    Projections.excludeId()\n)\nval flowResults = collection.find<FruitRating>(filter).projection(projection)\n\nflowResults.collect { println(it)}\n"
        },
        {
          "lang": "console",
          "value": "FruitRating(name=apples, rating=3),\nFruitRating(name=bananas, rating=1),\nFruitRating(name=oranges, rating=2),\nFruitRating(name=avocados, rating=5)"
        }
      ],
      "preview": "In this guide, you can learn how to control which fields appear in\ndocuments returned from read operations with the MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/read-operations/retrieve",
      "title": "Retrieve Data",
      "headings": [
        "Overview",
        "Sample Data for Examples",
        "Find Operation",
        "Example",
        "Aggregate Operation",
        "Example"
      ],
      "paragraphs": "In this guide, you can learn how to retrieve data from your MongoDB\ndatabase. To retrieve data, use read operations. Read operations allow you to do the following: Retrieve a subset of documents from your collection using a  find operation Perform transformations on retrieved documents from your collection using an  aggregate operation Monitor real-time changes to your database using  change streams The following sections feature examples of how the owner of a paint\nstore manages their customers' orders. For each order, the owner keeps\ntrack of the color and quantity, which corresponds to the  color  and\n qty  fields in their  paint_order  collection: This data is modeled with the following Kotlin data class: Use the find operation to retrieve a subset of your existing data in\nMongoDB. You can specify what data to return including which documents\nto retrieve, in what order to retrieve them, and how many to retrieve. To perform a find operation, call the  find()  method on an instance\nof a  MongoCollection . This method searches a collection for documents that\nmatch the query filter you provide. For more information on how to\nspecify a query, see our  Specify a Query  guide. The owner would like to know which orders contain greater than three, but\nless than nine cans of paint from their  paint_order collection . To address this scenario, the owner finds orders to match the criteria: After the owner runs this query, they find two orders that matched the\ncriteria. For more information on how to build filters, see our  Filters Builders  guide. For a runnable  find()  example, see our  Find Multiple\nDocuments  page. Use the aggregate operation to perform the stages in an aggregation\npipeline.  An aggregation pipeline is a multi-staged transformation that\nproduces an aggregated result. To perform an aggregate operation, call the  aggregate()  method on an\ninstance of a  MongoCollection . This method accepts aggregation\nexpressions to run in sequence. To perform aggregations, you can\ndefine aggregation stages that specify how to match documents, rename\nfields, and group values. For more information, see our\n Aggregation  guide. The owner would like to know which paint color is the most purchased\n(highest quantity sold) from their  paint_order collection . To address the scenario, the owner creates an aggregation pipeline that: After the owner runs the aggregation, they find that \"green\" is the most\npurchased color. For more information on how to construct an aggregation pipeline, see\nthe MongoDB server manual page on  Aggregation . For additional information on the methods mentioned on this page, see\nthe following API Documentation: Matches all the documents in the  paint_order  collection Groups orders by colors Sums up the quantity field by color Orders the results by highest-to-lowest quantity MongoCollection.find() MongoCollection.aggregate()",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"color\": \"purple\", \"qty\": 10 }\n{ \"_id\": 2, \"color\": \"green\", \"qty\": 8 }\n{ \"_id\": 3, \"color\": \"purple\", \"qty\": 4 }\n{ \"_id\": 4, \"color\": \"green\", \"qty\": 11 }"
        },
        {
          "lang": "kotlin",
          "value": "data class PaintOrder(\n    @BsonId val id: Int,\n    val qty: Int,\n    val color: String\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.and(Filters.gt(\"qty\", 3), Filters.lt(\"qty\", 9))\nval resultsFlow = collection.find(filter)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=2, qty=8, color=green)\nPaintOrder(id=3, qty=4, color=purple)"
        },
        {
          "lang": "kotlin",
          "value": "data class AggregationResult(@BsonId val id: String, val qty: Int)\n\nval filter = Filters.empty()\nval pipeline = listOf(\n    Aggregates.match(filter),\n    Aggregates.group(\n        \"\\$color\",\n        Accumulators.sum(\"qty\", \"\\$qty\")\n    ),\n    Aggregates.sort(Sorts.descending(\"qty\"))\n)\nval resultsFlow = collection.aggregate<AggregationResult>(pipeline)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=2, qty=8, color=green)\nPaintOrder(id=3, qty=4, color=purple)"
        }
      ],
      "preview": "In this guide, you can learn how to retrieve data from your MongoDB\ndatabase. To retrieve data, use read operations.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/read-operations/skip",
      "title": "Skip Returned Results",
      "headings": [
        "Overview",
        "Examples",
        "Using a FindIterable",
        "Using Aggregation"
      ],
      "paragraphs": "In this guide, you can learn how to skip a specified number of returned\nresults from read operations with the MongoDB Kotlin driver. You can skip results on the returned results of a query by using the\n skip()  method. You can also skip documents at a specific stage in an\naggregation pipeline by specifying a  $skip  aggregation stage. The  skip()  method takes an integer that specifies the number of documents\nto omit from the beginning of the list of documents returned by the\n FindFlow . You can use the  skip()  method to skip the first two documents as follows: Aggregates.skip() \nis an optional stage in the aggregation pipeline that specifies how many\ndocuments to omit from the beginning of the results of the prior stage. You can use the  Aggregates.skip()  method to skip the first two documents as follows: The following example is about a paint store that sells eight different\ncolors of paint.  The best colors sell quicker than the other colors.\nOne day, a customer asks what the three best-selling (lowest inventory)\ncolors are. The paint store keeps track of inventory in the  qty \nfield in their  paint_inventory  collection: This data is modeled with the following Kotlin data class: To address the scenario, the paint store needs to query the\n paint_inventory  collection with an empty filter, sort the documents\nby  qty  field and omit the first five results. The  find()  method returns all documents. The  sort()  method specifies documents to display from highest to lowest based on the  qty  field. The  skip()  method specifies to omit the first five documents. After the paint store runs the query, they find the three best-selling colors are pink,\nred, and white. The  match()  stage returns all documents. The  sort()  stage specifies documents to display from highest to lowest based on the  qty  field. The  skip()  stage specifies to omit the first five documents. If the value of skip is greater than or equal to the number of matched\ndocuments for a query, that query returns no documents. If the  skip()  method from the preceding example skips the first nine\ndocuments, no results would return since the specified quantity\nexceeds the number of matched documents.",
      "code": [
        {
          "lang": "kotlin",
          "value": "collection.find().skip(2)\n"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.empty()\nval results = collection.aggregate(listOf(\n    Aggregates.match(filter),\n    Aggregates.skip(2))\n)\n"
        },
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 10 }\n{ \"_id\": 3, \"color\": \"blue\", \"qty\": 9 }\n{ \"_id\": 4, \"color\": \"white\", \"qty\": 6 }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 11 }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 3 }\n{ \"_id\": 7, \"color\": \"green\", \"qty\": 8 }\n{ \"_id\": 8, \"color\": \"orange\", \"qty\": 7 }"
        },
        {
          "lang": "kotlin",
          "value": "data class PaintOrder(\n    @BsonId val id: Int,\n    val qty: Int,\n    val color: String\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.empty()\nval results = collection.find(filter)\n    .sort(descending(PaintOrder::qty.name))\n    .skip(5)\nresults.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=4, qty=6, color=white)\nPaintOrder(id=1, qty=5, color=red)\nPaintOrder(id=6, qty=3, color=pink)"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.empty()\nval aggregate = listOf(\n    Aggregates.match(filter),\n    Aggregates.sort(descending(PaintOrder::qty.name)),\n    Aggregates.skip(5)\n)\nval findFlow = collection.aggregate(aggregate)\nfindFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=4, qty=6, color=white)\nPaintOrder(id=1, qty=5, color=red)\nPaintOrder(id=6, qty=3, color=pink)"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.empty()\nval emptyQuery = listOf(\n    Aggregates.match(filter),\n    Aggregates.sort(descending(PaintOrder::qty.name)),\n    Aggregates.skip(9)\n)\nval findFlow = collection.aggregate(emptyQuery)\nfindFlow.collect { println(it) }\n"
        }
      ],
      "preview": "In this guide, you can learn how to skip a specified number of returned\nresults from read operations with the MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/read-operations/sort",
      "title": "Sort Results",
      "headings": [
        "Overview",
        "Methods For Sorting",
        "Sorting Direction",
        "Ascending",
        "Descending",
        "Handling Ties",
        "Combining Sort Criteria",
        "Text Search"
      ],
      "paragraphs": "In this guide, you can learn how to use  sort  operations to order your\nresults from read operations with the MongoDB Kotlin driver. The sort operation orders the documents returned from your query by your specified\n sort criteria . Sort criteria are the rules you pass to MongoDB that describe\nhow you would like your data to be ordered. Some examples of sort criteria are: You should read this guide to learn how to perform the following\nactions: The examples in this guide use a sample collection that contains the following\ndocuments: This data is modeled with the following Kotlin data class: Smallest number to largest number Earliest time of day to latest time of day Alphabetical order by first name Perform ascending sorts and descending sorts Combine sort criteria Sort on the text score of a  text search You can sort results retrieved by a query, or you can sort results\nwithin an aggregation pipeline. To sort your query results, use the\n sort()  method of a  FindFlow  instance. To sort your results within an\naggregation pipeline, use the  Aggregates.sort()  static factory method. Both\nof these methods receive objects that implement the  Bson  interface as\narguments. For more information, see the API Documentation for the\n BSON interface . You can use the  sort()  method of a  FindFlow  instance as follows: You can use the  Aggregates.sort()  method within an aggregation pipeline to\nsort the documents in the\n sample collection  from smallest to\nlargest value of the  orderTotal  field as follows: In the preceding code snippets, we specify the sort criteria using the  Sorts \nbuilder class. While it is possible to specify sort criteria using any class\nthat implements the  Bson  interface, we recommend that you specify sort\ncriteria through the  Sorts  builder. For more information on the  Sorts \nbuilder class, see the  Sorts builder  guide. For more information about the classes and interfaces in this section, see the\nfollowing API Documentation: FindFlow Aggregates Sorts BSON Document The direction of your sort can either be  ascending  or  descending .\nAn ascending sort orders your results from smallest to largest. A\ndescending sort orders your results from largest to smallest. Here are some examples of data sorted in ascending order: Here are some examples of data sorted in descending order: The following subsections show how to specify these sort criteria. Numbers: 1, 2, 3, 43, 43, 55, 120 Dates: 1990-03-10, 1995-01-01, 2005-10-30, 2005-12-21 Words (ASCII): Banana, Dill, carrot, cucumber, hummus Numbers: 100, 30, 12, 12, 9, 3, 1 Dates: 2020-01-01, 1998-12-11, 1998-12-10, 1975-07-22 Words (reverse ASCII): pear, grapes, apple, Cheese To specify an ascending sort, use the  Sorts.ascending()  static\nfactory method. Pass the  Sorts.ascending()  method\nthe name of the field you need to sort in ascending order. You can pass the  sort()  method the output of the  Sorts.ascending() \nmethod to specify an ascending sort on a field as follows: The preceding  sort()  method returns a  FindIterable  object that can iterate\nover the documents in your collection, sorted from smallest to largest on the\nspecified field name. In the following code example, we use the  ascending()  method to sort the\n sample collection \nby the  orderTotal  field: To specify a descending sort, use the  Sorts.descending()  static factory\nmethod. Pass the  Sorts.descending()  method the name of the field you need to sort in descending order. The following code snippet shows how to specify a descending sort on the\n orderTotal  field and return the documents in the\n sample collection \nin descending order: A tie occurs when two or more documents have identical values in the field\nyou are using to order your results. MongoDB does not guarantee sort order in\nthe event of ties. For example, suppose we encounter a tie when applying a sort\nto the  sample collection  using the following\ncode: Since multiple documents that matched the query contain the same value\nin the  date  field, the documents may not be returned in a consistent order. If you need to guarantee a specific order for documents that have fields\nwith identical values, you can specify additional fields to sort on in the event\nof a tie. We can specify an ascending sort on the  date  field followed by the\n orderTotal  field to return the documents in the\n sample collection \nin the following order: To combine sort criteria, use the  Sorts.orderBy()  static factory\nmethod. This method constructs an object containing an ordered list of sort\ncriteria. When performing the sort, if the previous sort criteria result in a\ntie, the sort uses the next sort criteria in the list to determine the order. In the following code snippet, we use the  orderBy()  method to order the data\nby performing a descending sort on the  date  field, and in the event of a\ntie, by performing an ascending sort on the  orderTotal  field. With\nthese sort criteria, the code returns the documents in the  sample\ncollection  in the following order: You can specify the order of the results of a\n text search  by how closely the string values of\neach result's fields specified by the collection's text index match your search\nstring. The text search assigns a numerical\n text score  to\nindicate how closely each result matches the search string. Use the\n Sorts.metaTextScore()  static factory method to build your sort criteria to\nsort by the text score. In the following code example, we show how you can use the\n Sorts.metaTextScore()  method to sort the results of a text\nsearch on the  sample collection .\nThe code example uses the  Filters ,\n Indexes , and\n Projections  builders. The code example performs the following actions: The data is modeled with the following Kotlin data class: For more information about the classes in this section, see the\nfollowing API Documentation: For more information, see the\n Sorts class  API Documentation.\nSee the server manual documentation for more information on the  $text \nquery operator and the\n $meta \naggregation pipeline operator. You need a  text index  on your collection to\nperform a text search. See the server manual documentation for more\ninformation on how to\n create a text index . Creates a text index for your\n sample collection \non the  description  field. If you call  createIndex()  specifying an index that\nalready exists on the collection, the operation does not create a new index. Runs your text search for the phrase  \"vanilla\" . Projects text scores into your query results as the\n score  field. Sorts your results by text score (best match first). The structure of text search has changed for MongoDB 4.4 or later. You no\nlonger need to project  Projections.metaTextScore()  into your\n FindFlow  instance in order to sort on the text score. In addition,\nthe field name you specify in a  $meta  text score aggregation operation\nused in a sort is ignored. This means that the field name argument you pass\nto  Sorts.metaTextScore()  is disregarded. Filters Indexes Projections MongoCollection",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"date\": \"2022-01-03\", \"orderTotal\": 17.86, \"description\": \"1/2 lb cream cheese and 1 dozen bagels\" },\n{ \"_id\": 2, \"date\": \"2022-01-11\", \"orderTotal\": 83.87, \"description\": \"two medium vanilla birthday cakes\" },\n{ \"_id\": 3, \"date\": \"2022-01-11\", \"orderTotal\": 19.49, \"description\": \"1 dozen vanilla cupcakes\" },\n{ \"_id\": 4, \"date\": \"2022-01-15\", \"orderTotal\": 43.62, \"description\": \"2 chicken lunches and a diet coke\" },\n{ \"_id\": 5, \"date\": \"2022-01-23\", \"orderTotal\": 60.31, \"description\": \"one large vanilla and chocolate cake\" },\n{ \"_id\": 6, \"date\": \"2022-01-23\", \"orderTotal\": 10.99, \"description\": \"1 bagel, 1 orange juice, 1 muffin\" }"
        },
        {
          "lang": "kotlin",
          "value": "data class Order(\n    @BsonId val id: Int,\n    val date: String,\n    val orderTotal: Double,\n    val description: String,\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find().sort(Sorts.ascending(Order::orderTotal.name))\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.aggregate(listOf(\n    Aggregates.sort(Sorts.ascending(Order::orderTotal.name))\n))\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Order(id=6, date=2022-01-23, orderTotal=10.99, description=1 bagel, 1 orange juice, 1 muffin)\nOrder(id=1, date=2022-01-03, orderTotal=17.86, description=1/2 lb cream cheese and 1 dozen bagels)\nOrder(id=3, date=2022-01-11, orderTotal=19.49, description=1 dozen vanilla cupcakes)\nOrder(id=4, date=2022-01-15, orderTotal=43.62, description=2 chicken lunches and a diet coke)\nOrder(id=5, date=2022-01-23, orderTotal=60.31, description=one large vanilla and chocolate cake)\nOrder(id=2, date=2022-01-11, orderTotal=83.87, description=two medium vanilla birthday cakes)"
        },
        {
          "lang": "kotlin",
          "value": "collection.find().sort(Sorts.ascending(\"<field name>\"))"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find()\n    .sort(Sorts.ascending(Order::orderTotal.name))\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Order(id=6, date=2022-01-23, orderTotal=10.99, description=1 bagel, 1 orange juice, 1 muffin)\nOrder(id=1, date=2022-01-03, orderTotal=17.86, description=1/2 lb cream cheese and 1 dozen bagels)\nOrder(id=3, date=2022-01-11, orderTotal=19.49, description=1 dozen vanilla cupcakes)\nOrder(id=4, date=2022-01-15, orderTotal=43.62, description=2 chicken lunches and a diet coke)\nOrder(id=5, date=2022-01-23, orderTotal=60.31, description=one large vanilla and chocolate cake)\nOrder(id=2, date=2022-01-11, orderTotal=83.87, description=two medium vanilla birthday cakes)"
        },
        {
          "lang": "kotlin",
          "value": "val resultsFlow = collection.find()\n    .sort(Sorts.descending(Order::orderTotal.name))\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Order(id=2, date=2022-01-11, orderTotal=83.87, description=two medium vanilla birthday cakes)\nOrder(id=5, date=2022-01-23, orderTotal=60.31, description=one large vanilla and chocolate cake)\nOrder(id=4, date=2022-01-15, orderTotal=43.62, description=2 chicken lunches and a diet coke)\nOrder(id=3, date=2022-01-11, orderTotal=19.49, description=1 dozen vanilla cupcakes)\nOrder(id=1, date=2022-01-03, orderTotal=17.86, description=1/2 lb cream cheese and 1 dozen bagels)\nOrder(id=6, date=2022-01-23, orderTotal=10.99, description=1 bagel, 1 orange juice, 1 muffin)"
        },
        {
          "lang": "kotlin",
          "value": "collection.find().sort(Sorts.ascending(Order::date.name))\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.find().sort(Sorts.ascending(Order::date.name, Order::orderTotal.name))\n"
        },
        {
          "lang": "console",
          "value": "Order(id=1, date=2022-01-03, orderTotal=17.86, description=1/2 lb cream cheese and 1 dozen bagels)\nOrder(id=3, date=2022-01-11, orderTotal=19.49, description=1 dozen vanilla cupcakes)\nOrder(id=2, date=2022-01-11, orderTotal=83.87, description=two medium vanilla birthday cakes)\nOrder(id=4, date=2022-01-15, orderTotal=43.62, description=2 chicken lunches and a diet coke)\nOrder(id=6, date=2022-01-23, orderTotal=10.99, description=1 bagel, 1 orange juice, 1 muffin)\nOrder(id=5, date=2022-01-23, orderTotal=60.31, description=one large vanilla and chocolate cake)"
        },
        {
          "lang": "kotlin",
          "value": "val orderBySort = Sorts.orderBy(\n    Sorts.descending(Order::date.name), Sorts.ascending(Order::orderTotal.name)\n)\nval results = collection.find().sort(orderBySort)\n\nresults.collect {println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Order(id=6, date=2022-01-23, orderTotal=10.99, description=1 bagel, 1 orange juice, 1 muffin)\nOrder(id=5, date=2022-01-23, orderTotal=60.31, description=one large vanilla and chocolate cake)\nOrder(id=4, date=2022-01-15, orderTotal=43.62, description=2 chicken lunches and a diet coke)\nOrder(id=3, date=2022-01-11, orderTotal=19.49, description=1 dozen vanilla cupcakes)\nOrder(id=2, date=2022-01-11, orderTotal=83.87, description=two medium vanilla birthday cakes)\nOrder(id=1, date=2022-01-03, orderTotal=17.86, description=1/2 lb cream cheese and 1 dozen bagels)"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Sorts\nimport com.mongodb.client.model.Projections\nimport com.mongodb.client.model.Filters\nimport com.mongodb.client.model.Indexes"
        },
        {
          "lang": "kotlin",
          "value": "data class OrderScore(\n   @BsonId val id: Int,\n   val description: String,\n   val score: Double\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.createIndex(Indexes.text(Order::description.name))\nval metaTextScoreSort = Sorts.orderBy(\n    Sorts.metaTextScore(OrderScore::score.name),\n    Sorts.descending(\"_id\")\n)\nval metaTextScoreProj = Projections.metaTextScore(OrderScore::score.name)\nval searchTerm = \"vanilla\"\nval searchQuery = Filters.text(searchTerm)\n\nval results = collection.find<OrderScore>(searchQuery)\n    .projection(metaTextScoreProj)\n    .sort(metaTextScoreSort)\n\nresults.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "OrderScore(id=3, description=1 dozen vanilla cupcakes, score=0.625)\nOrderScore(id=5, description=one large vanilla and chocolate cake, score=0.6)\nOrderScore(id=2, description=two medium vanilla birthday cakes, score=0.6)"
        }
      ],
      "preview": "In this guide, you can learn how to use sort operations to order your\nresults from read operations with the MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/read-operations/text",
      "title": "Search Text",
      "headings": [
        "Overview",
        "Sample Documents",
        "Text Index",
        "Text Search",
        "Specify Options",
        "Search Text by a Term",
        "Example",
        "Example",
        "Search Text by a Phrase",
        "Example",
        "Search Text with Terms Excluded",
        "Example"
      ],
      "paragraphs": "In this guide, you can learn how to run a  text search  in the MongoDB\nKotlin driver. You can use a text search to retrieve documents that contain a  term \nor a  phrase  in a specified field. A term is a sequence of characters\nthat excludes whitespace characters. A phrase is a sequence of terms\nwith any number of whitespace characters. The following sections show you how to perform the following types of\ntext searches: If you want to sort your text search results, see the  Text Search  section of our Sort Results guide. Search Text by a Term Search Text by a Phrase Search Text with Terms Excluded The following sections feature examples of text searches on the\n fast_and_furious_movies  collection. Each section uses a variable\nnamed  collection  to refer to the  MongoCollection  instance of the\n fast_and_furious_movies  collection. The  fast_and_furious_movies  collection contains documents that\ndescribe one of the several movies that are part of the Fast and Furious\nmovie franchise. Each document contains a title field and a tags field. This data is modeled with the following Kotlin data class: You must create a  text index  before running a text search. A text\nindex specifies the string or string array field on which to run a text\nsearch. In the following examples, you run text searches on the  title \nfield in the  fast_and_furious_movies  collection. To enable text\nsearches on the  title  field, create a text index using the\n Indexes  builder with the following snippet: For more information, see the following resources: Text Indexes  section of our Indexes guide Text Indexes  Server Manual Entry Use the  Filters.text()  method to specify a text search. The  Filters.text()  method uses the  Filters builder  to define a query filter specifying\nwhat to search for during the text search. The query filter is\nrepresented by a  BSON  instance. Pass the query filter to the\n find()  method to run a text search. When you execute the  find()  method, MongoDB runs a text search on\nall the fields indexed with the text index on the collection. MongoDB\nreturns documents that contain one or more of the search terms and a\nrelevance score for each result. For more information on relevance\nscores, see the  Text Search  section in\nour Sort Results guide. You can include  TextSearchOptions  as the second parameter of the\n Filters.text()  method to specify text search options such as case\nsensitivity. By default, text searches run without case sensitivity\nwhich means the search matches lowercase and uppercase values. To specify a case sensitive search, use the following snippet: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Filters.text() TextSearchOptions Pass a term as a string to the  Filters.text()  method to specify the\nterm in your text search. The following example runs a text search on the documents in the\n fast_and_furious_movies  collection for titles that contain the\nterm \"fast\": To match multiple terms in your text search, separate each term\nwith spaces in the  Filters.text()  builder method. The builder method\nreturns the text search query as a  Bson  instance. When you pass\nthis to the  find()  method, it returns documents that match any of\nthe terms. The following example runs a text search on the documents in the\n fast_and_furious_movies  collection for titles that contain the\nterms \"fate\" or \"7\": Pass a phrase with  escaped quotes  to the  Filters.text()  method to\nspecify the phrase in your text search. Escaped quotes are double quote\ncharacters preceded by a backslash character. If you don't add escaped\nquotes around the phrase, the  find()  method runs a  term search . The following example runs a text search on the documents in the\n fast_and_furious_movies  collection for titles that contain the\nphrase \"fate of the furious\": For each term you want to exclude from your text search, prefix the term\nwith a minus sign in the string that you pass to the  Filters.text() \nbuilder method. None of the documents returned from the search contain the excluded term\nin your text index field. You must have at least one text search term if you want to\nexclude terms from your search. The following example runs a text search on the documents in the\n fast_and_furious_movies  collection for titles that contain the\nterm \"furious\", but do not contain the term \"fast\":",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"title\": \"2 Fast 2 Furious \", \"tags\": [\"undercover\", \"drug dealer\"] }\n{ \"_id\": 2, \"title\": \"Fast 5\", \"tags\": [\"bank robbery\", \"full team\"] }\n{ \"_id\": 3, \"title\": \"Furious 7\", \"tags\": [\"emotional\"] }\n{ \"_id\": 4, \"title\": \"The Fate of the Furious\", \"tags\": [\"betrayal\"] }"
        },
        {
          "lang": "kotlin",
          "value": "data class Movies(\n    @BsonId val id: Int,\n    val title: String,\n    val tags: List<String>\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.createIndex(Indexes.text(\"title\"))\n"
        },
        {
          "lang": "kotlin",
          "value": "val options: TextSearchOptions = TextSearchOptions().caseSensitive(true)\nval filter = Filters.text(\"SomeText\", options)\n"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.text(\"fast\")\nval findFlow = collection.find(filter)\nfindFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Movies(id=1, title=2 Fast 2 Furious, tags=[undercover, drug dealer])\nMovies(id=2, title=Fast 5, tags=[bank robbery, full team])"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.text(\"fate 7\")\nval findFlow = collection.find(filter)\nfindFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Movies(id=3, title=Furious 7, tags=[emotional])\nMovies(id=4, title=The Fate of the Furious, tags=[betrayal])"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.text(\"\\\"fate of the furious\\\"\")\nval findFlow = collection.find(filter)\nfindFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Movies(id=4, title=The Fate of the Furious, tags=[betrayal])"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.text(\"furious -fast\")\nval findFlow = collection.find(filter)\nfindFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Movies(id=3, title=Furious 7, tags=[emotional])\nMovies(id=4, title=The Fate of the Furious, tags=[betrayal])"
        }
      ],
      "preview": "In this guide, you can learn how to run a text search in the MongoDB\nKotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/read-operations",
      "title": "Read Operations",
      "headings": [],
      "paragraphs": "Retrieve Data Access Data From a Flow Open Change Streams Sort Results Skip Returned Results Limit the Number of Returned Results Specify Which Fields to Return Search Geospatially Search Text",
      "code": [],
      "preview": null,
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/write-operations/bulk",
      "title": "Bulk Operations",
      "headings": [
        "Overview",
        "Performing Bulk Operations",
        "Insert Operation",
        "Example",
        "Replace Operation",
        "Example",
        "Update Operation",
        "Example",
        "Delete Operation",
        "Example",
        "Order of Execution",
        "Ordered Execution",
        "Example",
        "Unordered Execution",
        "Summary"
      ],
      "paragraphs": "In this guide, you can learn how to use bulk operations in the\nMongoDB Kotlin Driver. For individual CRUD operations, you can use the relevant method. For\nexample, to insert one document and then update multiple documents, you\ncan use the  insertOne()  method and the  updateMany()  method. The  MongoClient  performs these operations by making a request to the\ndatabase corresponding to each operation. You can reduce the number of\ncalls to the database by using bulk operations. Bulk operations consist of a large number of write operations. To perform\na bulk operation, pass a  List  containing  WriteModel  documents to the\n bulkWrite()  method. A  WriteModel  is a model that represents a single\nwrite operation. The following sections show how to create and use each variation of the  WriteModel \ntype. The examples in each section use the following documents in the  people  collection: This data is modeled with the following Kotlin data class: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: bulkWrite() WriteModel BulkWriteOptions To perform an insert operation, create an  InsertOneModel  specifying\nthe document you want to insert. To insert multiple documents, you must\ncreate an  InsertOneModel  for each document you want to insert. The following example creates an  InsertOneModel  for two documents\ndescribing people: For more information about the methods and classes mentioned in this section,\nsee the  InsertOneModel  API Documentation. When performing a  bulkWrite()  operation, the  InsertOneModel  cannot\ninsert a document with an  _id  that already exists in the\ncollection. In this case, the driver throws a  MongoBulkWriteException . The following example tries to insert two documents where the  _id \nvalues are  1  and  3 . Since there is already a document with an  _id \nof  1  in the collection, the operation results in an error: To learn about why the driver didn't insert the document with the\n _id  of  3 , see the  Order of Execution  section. To perform a replace operation, create a  ReplaceOneModel  specifying\na query filter for the document you want to replace and the replacement\ndocument. When performing a  bulkWrite() , the  ReplaceOneModel  cannot\nmake changes that violate unique index constraints on\nthe collection. Additionally, the model does not perform the replace\noperation if there are no matches to the query filter. The following example creates a  ReplaceOneModel  to\nreplace a document where the  _id  is  1  with a document that\ncontains the additional  location  field: For more information about the methods and classes mentioned in this section,\nsee the following resources: ReplaceOneModel  API Documentation Unique indexes  Server Manual Explanation To perform an update operation, create an  UpdateOneModel  or an\n UpdateManyModel  that specifies a query filter and an update document. The  UpdateOneModel  updates the first document that matches your query\nfilter and the  UpdateManyModel  updates all the documents that\nmatch your query filter. When performing a  bulkWrite() , the  UpdateOneModel  and\n UpdateManyModel  types cannot make changes that violate unique\nindex constraints on the collection. Additionally, the models do not\nperform update operations if there are no matches to the query\nfilter. The following example creates an  UpdateOneModel  to increment the  age \nfield by  1  in a document where the  _id  is  2 : For more information about the methods and classes mentioned in this section,\nsee the following resources: UpdateOneModel  API Documentation UpdateManyModel  API Documentation unique indexes  Server Manual Explanation To perform a delete operation, create a  DeleteOneModel  or a\n DeleteManyModel  that specifies a query filter for documents you want\nto delete. The  DeleteOneModel  deletes the first document that matches your query\nfilter and the  DeleteManyModel  deletes all the documents that\nmatch your query filter. When performing a  bulkWrite() , the  DeleteOneModel  and\n DeleteManyModel  types do not delete any documents if there are no\nmatches to the query filter. The following example creates a  DeleteOneModel  to delete\na document where the  _id  is  1  and a  DeleteManyModel  to delete\ndocuments where the  age  value is less than  30 : For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: DeleteOneModel DeleteManyModel The  bulkWrite()  method accepts an optional  BulkWriteOptions  as\na second parameter to specify if you want to execute the bulk operations\nas ordered or unordered. By default, the  bulkWrite()  method executes bulk operations in\norder. This means that the operations execute in the order you\nadded them to the list until any error occurs. The following example performs these bulk operations: After running this example, your collection contains the following\ndocument: An insert operation for a document where the  name  is\n \"Zaynab Omar\"  and  the  age  is  37 A replace operation for a document where the  _id  is  1  with a new\ndocument that contains the  location  field An update operation for a document where the  _id  is  6  to\nchange the  name  field A delete operation for all documents that have an  age  value\ngreater than  50 You can also execute bulk operations in any order by passing  false \nto the  ordered()  method on a  BulkWriteOptions  object. This means that\nall the write operations execute regardless of errors. If any errors occur,\nthe driver reports them at the end. The following code shows how to execute a bulk operation with no order\nof execution: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Unordered bulk operations do not guarantee the order of execution. The\norder may differ from the way you list them to optimize the runtime. In the preceding example, if the  bulkWrite()  method performed the\ninsert operation after the update operation, the update operation\nwould not produce changes because the document did not exist\nat that point in time. The collection would then contain the following\ndocuments: BulkWriteOptions ordered() To perform a bulk operation, create and pass a list of\n WriteModel  documents to the  bulkWrite()  method. There are six variations of  WriteModel : There are two ways to execute the  bulkWrite()  method: InsertOneModel ReplaceOneModel UpdateOneModel UpdateManyModel DeleteOneModel DeleteManyModel Ordered, where the driver performs the write operations in order until any error occurs Unordered, where the driver performs all the write operations in any order and\nreports any errors after the operations complete",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"name\": \"Karen Sandoval\", \"age\": 31 }\n{ \"_id\": 2, \"name\": \"William Chin\", \"age\": 54 }\n{ \"_id\": 8, \"name\": \"Shayla Ray\", \"age\": 20 }"
        },
        {
          "lang": "kotlin",
          "value": "data class Person(\n    @BsonId val id: Int,\n    val name: String,\n    val age: Int? = null,\n    val location: String? = null\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val juneDoc = InsertOneModel(Person(3, \"June Carrie\", 17))\nval kevinDoc = InsertOneModel(Person(4, \"Kevin Moss\", 22))\n"
        },
        {
          "lang": "kotlin",
          "value": "try {\n    val bulkOperations = listOf(\n        (InsertOneModel(Person(1, \"James Smith\", 13))),\n        (InsertOneModel(Person(3, \"Colin Samuels\")))\n    )\n    val bulkWrite = collection.bulkWrite(bulkOperations)\n} catch (e: MongoBulkWriteException) {\n    println(\"A MongoBulkWriteException occurred with the following message: \" + e.message)\n}\n"
        },
        {
          "lang": "console",
          "value": "A MongoBulkWriteException occurred with the following message:\nBulk write operation error on server sample-shard-00-02.pw0q4.mongodb.net:27017.\nWrite errors: [BulkWriteError{index=0, code=11000, message='E11000 duplicate key\nerror collection: crudOps.bulkWrite index: _id_ dup key: { _id: 1 }', details={}}]."
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval insert = Person(1, \"Celine Stork\", location = \"San Diego, CA\")\nval doc = ReplaceOneModel(filter, insert)\n"
        },
        {
          "lang": "java",
          "value": "val filter = Filters.eq(\"_id\", 2)\nval update = Updates.inc(Person::age.name, 1)\nval doc = UpdateOneModel<Person>(filter, update)\n"
        },
        {
          "lang": "kotlin",
          "value": "val deleteId1 = DeleteOneModel<Person>(Filters.eq(\"_id\", 1))\nval deleteAgeLt30 = DeleteManyModel<Person>(Filters.lt(Person::age.name, 30))\n"
        },
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"name\": \"Sandy Kane\", \"location\": \"Helena, MT\" }\n{ \"_id\": 8, \"name\": \"Shayla Ray\", \"age\": 20 }\n{ \"_id\": 6, \"name\": \"Zaynab Hassan\", \"age\": 37 }"
        },
        {
          "lang": "kotlin",
          "value": "val insertMdl = InsertOneModel(Person(6, \"Zaynab Omar\", 37))\nval replaceMdl = ReplaceOneModel(\n    Filters.eq(\"_id\", 1),\n    Person(1, \"Sandy Kane\", location = \"Helena, MT\")\n)\nval updateMdl  = UpdateOneModel<Person>(\n        Filters.eq(\"_id\", 6),\n        Updates.set(Person::name.name, \"Zaynab Hassan\")\n    )\nval deleteMdl = DeleteManyModel<Person>(Filters.gt(Person::age.name, 50))\n\nval bulkOperations = listOf(\n    insertMdl,\n    replaceMdl,\n    updateMdl,\n    deleteMdl\n)\n\nval result = collection.bulkWrite(bulkOperations)\n"
        },
        {
          "lang": "kotlin",
          "value": "val options = BulkWriteOptions().ordered(false)\nval unorderedResult = collection.bulkWrite(bulkOperations, options)\n"
        },
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"name\": \"Sandy Kane\", \"location\": \"Helena, MT\" }\n{ \"_id\": 8, \"name\": \"Shayla Ray\", \"age\": 20 }\n{ \"_id\": 6, \"name\": \"Zaynab Omar\", \"age\": 37 }"
        }
      ],
      "preview": "In this guide, you can learn how to use bulk operations in the\nMongoDB Kotlin Driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/write-operations/delete",
      "title": "Delete Documents",
      "headings": [
        "Overview",
        "Sample Documents",
        "Delete Many Documents",
        "Delete a Document",
        "Find and Delete a Document"
      ],
      "paragraphs": "In this guide, you can learn how to remove documents with the MongoDB Kotlin\ndriver. You can remove documents by passing a query filter to the\n deleteOne() ,  deleteMany()  or  findOneAndDelete()  methods. The  deleteOne()  method deletes a single document. If the query\nfilter matches more than one document, the method will remove the first\noccurrence of a match in the collection. The  deleteMany()  method deletes all documents that match the query\nfilter. The  findOneAndDelete()  method atomically finds and deletes the first\noccurrence of a match in the collection. To specify a collation or hint an index, use  DeleteOptions \nas a second parameter to the  deleteOne()  and  deleteMany()  methods. To specify a collation, hint an index, specify sort order, or specify a\nprojection on the returned document, use  FindOneAndDeleteOptions \nas the second parameter to the  findOneAndDelete()  method. When deleting a single document, filter your query by a unique index,\nsuch as an  _id , to ensure your query matches the document you want to\ndelete. The following examples are about a paint store that sells eight different\ncolors of paint. The store had their annual online sale resulting in the\nfollowing documents in their  paint_inventory  collection: This data is modeled with the following Kotlin data class: The paint store website displays all documents in the\n paint_inventory  collection. To reduce customer confusion, the store\nwants to remove the colors that are out of stock. To remove the out of stock colors, query the  paint_inventory \ncollection where the  qty  is  0  and pass the query to the\n deleteMany()  method: The following shows the documents remaining in the  paint_inventory \ncollection: The store is donating the remaining quantity of their yellow paint. This\nmeans that the  qty  for yellow is now  0  and we need to remove yellow\nfrom the collection. To remove yellow, query the  paint_inventory  collection where the\n color  is  \"yellow\"  and pass the query to the  deleteOne() \nmethod: The following shows the documents remaining in the  paint_inventory \ncollection: The store would like to raffle the remaining quantity of purple paint\nand remove purple from the  paint_inventory  collection. To pick a color, query the  paint_inventory  collection where the\n color  is  \"purple\"  and pass the query to the  findOneAndDelete() \nmethod. Unlike the other delete methods,  findOneAndDelete()  returns the\ndeleted document: The following shows the documents remaining in the  paint_inventory \ncollection: For more information about the methods and classes mentioned in this guide,\nsee the following resources: If there are no matches to your query filter, no document gets\ndeleted and the method returns  null . deleteOne()  API Documentation deleteMany()  API Documentation findOneAndDelete()  API Documentation DeleteOptions  API Documentation FindOneAndDeleteOptions  API Documentation db.collection.deleteOne()  Server Manual Entry db.collection.deleteMany()  Server Manual Entry db.collection.findOneAndDelete()  Server Manual Entry",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }\n{ \"_id\": 3, \"color\": \"blue\", \"qty\": 0 }\n{ \"_id\": 4, \"color\": \"white\", \"qty\": 0 }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 6 }\n{ \"_id\": 6, \"color\": \"pink\", \"qty\": 0 }\n{ \"_id\": 7, \"color\": \"green\", \"qty\": 0 }\n{ \"_id\": 8, \"color\": \"black\", \"qty\": 8 }"
        },
        {
          "lang": "kotlin",
          "value": "data class PaintOrder(\n    @BsonId val id: Int,\n    val qty: Int,\n    val color: String\n)\n"
        },
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }\n{ \"_id\": 5, \"color\": \"yellow\", \"qty\": 6 }\n{ \"_id\": 8, \"color\": \"black\", \"qty\": 8 }"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"qty\", 0)\ncollection.deleteMany(filter)\n"
        },
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }\n{ \"_id\": 8, \"color\": \"black\", \"qty\": 8 }"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"color\", \"yellow\")\ncollection.deleteOne(filter)\n"
        },
        {
          "lang": "json",
          "value": " { \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n { \"_id\": 8, \"color\": \"black\", \"qty\": 8 }"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"color\", \"purple\")\nval result = collection.findOneAndDelete(filter)\n\nprintln(\"The following was deleted: $result\")\n"
        },
        {
          "lang": "console",
          "value": "The following was deleted: PaintOrder(id=2, qty=8, color=purple)"
        }
      ],
      "preview": "In this guide, you can learn how to remove documents with the MongoDB Kotlin\ndriver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/write-operations/embedded-arrays",
      "title": "Update Arrays in a Document",
      "headings": [
        "Overview",
        "Sample Document",
        "Specifying an Update",
        "Specifying Array Elements",
        "The First Matching Array Element",
        "Example",
        "Matching All Array Elements",
        "Example",
        "Matching Multiple Array Elements",
        "Example"
      ],
      "paragraphs": "In this guide, you can learn how to update arrays in a document with the\nMongoDB Kotlin driver. To update an array, you must do the following: Specify the update you want to perform Specify what array elements to apply your update to Perform an update operation using these specifications The following sections feature examples that update this sample\ndocument: This data is modeled with the following Kotlin data class: The examples on this page use the  findOneAndUpdate()  method of the\n MongoCollection  class to retrieve and update the document. Each\nexample uses an instance of the  FindOneAndUpdateOptions  class to\nhave MongoDB retrieve the document after the update occurs. For\nmore information on the  findOneAndUpdate()  method, see our\n Compound Operations guide . To specify an update, use the  Updates  builder. The  Updates \nbuilder provides static utility methods to construct update\nspecifications. For more information on using the  Updates  builder with\narrays, see our  guide on the Updates builder . The following example performs these actions: Query for the sample document Append \"17\" to the  qty  array in the document that matches the query filter You can specify which array elements to update using a positional\noperator. Positional operators can specify the first, all, or certain\narray elements to update. To specify elements in an array with positional operators, use  dot\nnotation . Dot notation is a property access syntax for navigating BSON\nobjects. For additional information, see the Server Manual Entry on\n dot notation . To update the first array element that matches your query filter, use the\npositional  $  operator. The array field must appear as part of your\nquery filter to use the positional  $  operator. The following example performs these actions: For more information about the methods and operators mentioned in this section,\nsee the following resources: Query for a document with a  qty  field containing the value \"18\" Decrement the first array value in the document that matches the query filter by \"3\" Positional $ Operator  Server Manual Entry inc()  API Documentation To update all elements in an array, use the all positional  $[]  operator. The following example performs these actions: For more information about the methods and operators mentioned in this section,\nsee the following resources: Query for the sample document Multiply array elements matching the query filter by \"2\" All Positional $[] Operator  Server Manual Entry mul()  API Documentation To update array elements that match a filter, use the\nfiltered positional  $[<identifier>]  operator. You must include an\narray filter in your update operation to specify which array elements to\nupdate. The  <identifier>  is the name you give your array filter. This value\nmust begin with a lowercase letter and contain only alphanumeric\ncharacters. The following example performs these actions: For more information about the methods and operators mentioned in this section,\nsee the following resources: Query for the sample document Set an array filter to search for values less than \"15\" Increment array elements matching the query filter by \"5\" Filtered Positional $[<identifier>] Operator  Server Manual Entry inc()  API Documentation",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"color\": \"green\", \"qty\": [8, 12, 18] }"
        },
        {
          "lang": "kotlin",
          "value": "data class PaintOrder(\n    @BsonId val id: Int,\n    val qty: List<Int>,\n    val color: String\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.push(PaintOrder::qty.name, 17)\nval options = FindOneAndUpdateOptions()\n    .returnDocument(ReturnDocument.AFTER)\nval result = collection.findOneAndUpdate(filter, update, options)\n\nprint(result)\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=1, qty=[8, 12, 18, 17], color=green)"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(PaintOrder::qty.name, 18)\nval update = Updates.inc(\"${PaintOrder::qty.name}.$\", -3)\nval options = FindOneAndUpdateOptions()\n    .returnDocument(ReturnDocument.AFTER)\nval result = collection.findOneAndUpdate(filter, update, options)\n\nprint(result)\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=1, qty=[8, 12, 15], color=green)"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval update = Updates.mul(\"${PaintOrder::qty.name}.$[]\", 2)\nval options = FindOneAndUpdateOptions()\n    .returnDocument(ReturnDocument.AFTER)\nval result = collection.findOneAndUpdate(filter, update, options)\n\nprintln(result)\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=1, qty=[16, 24, 36], color=green)"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(\"_id\", 1)\nval smallerFilter = Filters.lt(\"smaller\", 15)\nval options = FindOneAndUpdateOptions()\n    .returnDocument(ReturnDocument.AFTER)\n    .arrayFilters(listOf(smallerFilter))\nval update = Updates.inc(\"${PaintOrder::qty.name}.$[smaller]\", 5)\nval result = collection.findOneAndUpdate(filter, update, options)\n\nprintln(result)\n"
        },
        {
          "lang": "console",
          "value": "PaintOrder(id=1, qty=[13, 17, 18], color=green)"
        }
      ],
      "preview": "In this guide, you can learn how to update arrays in a document with the\nMongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/write-operations/insert",
      "title": "Insert Operations",
      "headings": [
        "Overview",
        "A Note About _id",
        "Insert a Single Document",
        "Example",
        "Insert Multiple Documents",
        "Example",
        "Summary"
      ],
      "paragraphs": "In this guide, you can learn how to insert documents with the MongoDB Kotlin\ndriver. You can use MongoDB to retrieve, update, and delete information. To\nperform any of those operations, that information, such as user profiles\nand orders, needs to exist in MongoDB. For that information to exist,\nyou need to first perform an insert operation. An insert operation inserts a single or multiple documents into MongoDB\nusing the   insertOne() ,  insertMany() , and  bulkWrite() \nmethods. The following sections focus on  insertOne()  and\n insertMany() . For information on how to use the  bulkWrite() \nmethod, see our\n guide on Bulk Operations . In the following examples, a paint store has an inventory of different colors\nof paint. This data is modeled with the following Kotlin data class: When inserting a document, MongoDB enforces one constraint on your\ndocuments by default: each document  must  contain a unique  _id \nfield. There are two ways to manage this field: Unless you have provided strong guarantees for uniqueness, we recommend\nyou let the driver automatically generate  _id  values. For additional information on unique indexes, see the manual entry on\n Unique Indexes . You can manage this field yourself, ensuring each value you use is unique. You can let the driver automatically generate unique ObjectId values. Duplicate  _id  values violate unique index constraints, resulting\nin a  WriteError . Use the  insertOne()  method when you want to insert a single\ndocument. On successful insertion, the method returns an  InsertOneResult \ninstance representing the  _id  of the new document. The following example creates and inserts a document using the\n insertOne()  method: For more information about the methods and classes mentioned in this section,\nsee the following resources: insertOne()  API Documentation InsertOneResult  API Documentation Manual Explanation on  insertOne() Runnable  Insert a Document example Use the  insertMany()  method when you want to insert multiple\ndocuments. This method inserts documents in the order specified until an\nexception occurs, if any. For example, assume you want to insert the following documents: If you attempt to insert these documents, a  WriteError  occurs at the\nthird document and the documents prior to the error get inserted into\nyour collection. On successful insertion, the method returns an  InsertManyResult \ninstance representing the  _id  of each new document. Use a try-catch block to get an acknowledgment for successfully\nprocessed documents before the error occurs. The output consists of\ndocuments MongoDB can process: If you look inside your collection, you should see the following documents: The following example creates and adds two documents to a  List , and\ninserts the  List  using the  insertMany()  method: For more information about the methods and classes mentioned in this section,\nsee the following resources: insertMany()  API Documentation InsertManyResult  API Documentation Manual Explanation on  insertMany() Runnable  Insert Multiple Documents example There are three ways to perform an insert operation, but we focused on two: Both methods automatically generate an  _id  if you omit the field in\nyour document. If the insertion is successful, both methods return an instance\nrepresenting the  _id  of each new document. The  insertOne()  method inserts a single document. The  insertMany()  method inserts multiple documents.",
      "code": [
        {
          "lang": "kotlin",
          "value": "data class PaintOrder(\n    @BsonId val id: ObjectId? = null,\n    val qty: Int,\n    val color: String\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val paintOrder = PaintOrder(ObjectId(), 5, \"red\")\nval result = collection.insertOne(paintOrder)\n\nval insertedId = result.insertedId?.asObjectId()?.value\n\nprintln(\"Inserted a document with the following id: $insertedId\")\n"
        },
        {
          "lang": "console",
          "value": "Inserted a document with the following id: 60930c39a982931c20ef6cd6"
        },
        {
          "lang": "json",
          "value": "{ \"color\": \"red\", \"qty\": 5 }\n{ \"color\": \"purple\", \"qty\": 10 }\n{ \"color\": \"yellow\", \"qty\": 3 }\n{ \"color\": \"blue\", \"qty\": 8 }"
        },
        {
          "lang": "json",
          "value": "{ \"color\": \"red\", \"qty\": 5 }\n{ \"color\": \"purple\", \"qty\": 10 }"
        },
        {
          "lang": "kotlin",
          "value": "val result = collection.insertMany(paintOrders)\ntry {\n    println(\"Inserted documents with the following ids: ${result.insertedIds}\")\n} catch(e: MongoBulkWriteException){\n    val insertedIds = e.writeResult.inserts.map { it.id.asInt32().value }\n    println(\n        \"A MongoBulkWriteException occurred, but there are \" +\n        \"successfully processed documents with the following ids: $insertedIds\"\n    )\n    collection.find().collect { println(it) }\n}\n"
        },
        {
          "lang": "console",
          "value": "A MongoBulkWriteException occurred, but there are successfully processed\ndocuments with the following ids: [60930c3aa982931c20ef6cd7, 644ad1378ea29443837a14e9, 60930c3aa982931c20ef6cd8]"
        },
        {
          "lang": "kotlin",
          "value": "val paintOrders = listOf(\n    PaintOrder(ObjectId(), 5, \"red\"),\n    PaintOrder(ObjectId(), 10, \"purple\")\n)\nval result = collection.insertMany(paintOrders)\n\nprintln(\"Inserted a document with the following ids: ${result.insertedIds.toList()}\")\n"
        },
        {
          "lang": "console",
          "value": "Inserted documents with the following ids: [60930c3aa982931c20ef6cd7, 60930c3aa982931c20ef6cd8]"
        }
      ],
      "preview": "In this guide, you can learn how to insert documents with the MongoDB Kotlin\ndriver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/write-operations/modify",
      "title": "Modify Documents",
      "headings": [
        "Overview",
        "Update",
        "Update Operation Parameters",
        "Example",
        "Replace",
        "Replace Operation Parameters",
        "Example"
      ],
      "paragraphs": "In this guide, you can learn how to modify documents in a MongoDB\ncollection using two distinct operation types: Update operations specify the fields and values to change in one or more\ndocuments. A replace operation specifies the fields and values to replace\na single document from your collection. In the following examples, a paint store sells five different\ncolors of paint. The  paint_inventory  collection represents their\ncurrent inventory: This data is modeled with the following Kotlin data class: Update Replace Update operations can modify fields and values. They apply changes\nspecified in an update document to one or more documents that match your\nquery filter. The  updateOne() \nmethod changes the first document your query filter matches and the\n updateMany() \nmethod changes all the documents your query filter matches. You can call the  updateOne()  and  updateMany()  methods on a\n MongoCollection  instance as follows: The  updateOne()  and  updateMany()  methods both have the following\nparameters: You can create the  updateDocument  using an  Updates  builder as\nfollows: See the MongoDB API documentation for a  complete list of\nUpdates builders and their usage . query  specifies a query filter with the criteria to match documents to update in your collection updateDocument  specifies the fields and values to modify in the matching document or documents. For this example, we use the  Updates builder  to create the update document. The paint store needs to update their inventory after a customer returns a\ncan of yellow paint. To update the single can of paint, call the  updateOne()  method specifying\nthe following: The paint store then receives a fresh shipment and needs to update their\ninventory again. The shipment contains 20 cans of each paint color. To update the inventory, call the  updateMany()  method specifying the\nfollowing: The following shows the updated documents in the  paint_inventory  collection: If zero documents match the query filter in the update operation,\n updateMany()  makes no changes to documents in the collection. See\nour  upsert guide  to\nlearn how to insert a new document instead of updating one if no\ndocuments match. A query filter that matches the yellow color An update document that contains instructions to increment the  qty  field by \"1\" A query filter that matches all the colors An update document that contains instructions to increment the  qty  field by \"20\" The  updateOne()  and  updateMany()  methods cannot make changes\nto a document that violate unique index constraints on the\ncollection. See the MongoDB server manual for more information on\n unique indexes . A replace operation substitutes one document from your collection. The\nsubstitution occurs between a document your query filter matches and a\nreplacement document. The  replaceOne() \nmethod removes all the existing fields and values in the\nmatching document (except the  _id  field) and substitutes it with the\nreplacement document. You can call the  replaceOne()  method on a  MongoCollection \ninstance as follows: The  replaceOne()  method has the following parameters: query  specifies a query filter with the criteria to match a document to replace in your collection replacementDocument  specifies fields and values of a new  Document  object to replace in the matched document The paint store realizes they need to update their inventory again.  What they\nthought was 20 cans of pink paint is actually 25 cans of orange paint. To update the inventory, call the  replaceOne()  method specifying the\nfollowing: The following shows the updated document: If zero documents match the query filter in the replace operation,\n replaceOne()  makes no changes to documents in the collection. See\nour  upsert guide  to\nlearn how to insert a new document instead of replacing one if no\ndocuments match. If multiple documents match the query filter specified in\nthe  replaceOne()  method, it replaces the first result. A query filter that matches documents where the  color  is \"pink\" A replacement document where the  color  is \"orange\" and the  qty  is \"25\" The  replaceOne()  method cannot make changes to a document that\nviolate unique index constraints on the collection. See the MongoDB\nserver manual for more information on  unique indexes .",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": 1, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }\n{ \"_id\": 3, \"color\": \"yellow\", \"qty\": 0 }\n{ \"_id\": 4, \"color\": \"green\", \"qty\": 6 }\n{ \"_id\": 5, \"color\": \"pink\", \"qty\": 0 }"
        },
        {
          "lang": "kotlin",
          "value": "data class PaintOrder(\n    @BsonId val id: Int,\n    val color: String,\n    val qty: Int\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.updateOne(query, updateDocument)\n\ncollection.updateMany(query, updateDocument)"
        },
        {
          "lang": "kotlin",
          "value": "val updateDocument = Updates.operator(field, value)"
        },
        {
          "lang": "json",
          "value": " { \"_id\": 1, \"color\": \"red\", \"qty\": 25 }\n { \"_id\": 2, \"color\": \"purple\", \"qty\": 28 }\n { \"_id\": 3, \"color\": \"yellow\", \"qty\": 20 }\n { \"_id\": 4, \"color\": \"green\", \"qty\": 26 }\n { \"_id\": 5, \"color\": \"pink\", \"qty\": 20 }"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(PaintOrder::color.name, \"yellow\")\nval update = Updates.inc(PaintOrder::qty.name, 1)\nval result = collection.updateOne(filter, update)\n\nprintln(\"Matched document count: $result.matchedCount\")\nprintln(\"Modified document count: $result.modifiedCount\")\n"
        },
        {
          "lang": "console",
          "value": "  Matched document count: 1\n  Modified document count: 1"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.empty()\nval update = Updates.inc(PaintOrder::qty.name, 20)\nval result = collection.updateMany(filter, update)\n\nprintln(\"Matched document count: $result.matchedCount\")\nprintln(\"Modified document count: $result.modifiedCount\")\n"
        },
        {
          "lang": "console",
          "value": "  Matched document count: 5\n  Modified document count: 5"
        },
        {
          "lang": "kotlin",
          "value": "collection.replaceOne(query, replacementDocument)"
        },
        {
          "lang": "json",
          "value": " { \"_id\": 5, \"color\": \"orange\", \"qty\": 25 }"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(PaintOrder::color.name, \"pink\")\nval update = PaintOrder(5, \"orange\", 25)\nval result = collection.replaceOne(filter, update)\n\nprintln(\"Matched document count: $result.matchedCount\")\nprintln(\"Modified document count: $result.modifiedCount\")\n"
        },
        {
          "lang": "console",
          "value": "  Matched document count: 1\n  Modified document count: 1"
        }
      ],
      "preview": "In this guide, you can learn how to modify documents in a MongoDB\ncollection using two distinct operation types:",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/write-operations/upsert",
      "title": "Insert or Update in a Single Operation",
      "headings": ["Overview", "Specify an Upsert"],
      "paragraphs": "In this guide, you can learn how to perform an  upsert  with the\nMongoDB Kotlin driver. Applications use insert and update operations to store and modify data.\nSometimes, you need to choose between an insert and update depending on\nwhether the document exists. MongoDB simplifies this decision for us\nwith an  upsert  option. An  upsert : Updates documents that match your query filter Inserts a document if there are no matches to your query filter To specify an upsert with the  updateOne()  or  updateMany() \nmethods, pass  true  to  UpdateOptions.upsert() . To specify an upsert with the  replaceOne()  method, pass  true  to\n ReplaceOptions.upsert() . In the following example, a paint store sells eight different\ncolors of paint. The store had their annual online sale. Their\n paint_inventory  collection now shows the following documents: This data is modeled with the following Kotlin data class: The store received a fresh shipment and needs to update their inventory.\nThe first item in the shipment is ten cans of orange paint. To update the inventory, query the  paint_inventory  collection\nwhere the  color  is  \"orange\" , specify an update to  increment  the\n qty  field by  10 , and specify  true  to\n UpdateOptions.upsert() : This  AcknowledgedUpdateResult  tells us: The following shows the documents in the  paint_inventory  collection: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Zero documents matched our query filter Zero documents in our collection got modified A document with an  _id  of   606b4cfc1601f9443b5d6978  got upserted Not including  UpdateOptions  results in no change to the collection. UpdateOptions.upsert() ReplaceOptions.upsert()",
      "code": [
        {
          "lang": "json",
          "value": "{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958da\" }, \"color\": \"red\", \"qty\": 5 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958db\" }, \"color\": \"purple\", \"qty\": 8 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dc\" }, \"color\": \"blue\", \"qty\": 0 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dd\" }, \"color\": \"white\", \"qty\": 0 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958de\" }, \"color\": \"yellow\", \"qty\": 6 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958df\" }, \"color\": \"pink\", \"qty\": 0 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e0\" }, \"color\": \"green\", \"qty\": 0 }\n{ \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e1\" }, \"color\": \"black\", \"qty\": 8 }"
        },
        {
          "lang": "json",
          "value": " { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958da\" }, \"color\": \"red\", \"qty\": 5 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958db\" }, \"color\": \"purple\", \"qty\": 8 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dc\" }, \"color\": \"blue\", \"qty\": 0 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dd\" }, \"color\": \"white\", \"qty\": 0 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958de\" }, \"color\": \"yellow\", \"qty\": 6 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958df\" }, \"color\": \"pink\", \"qty\": 0 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e0\" }, \"color\": \"green\", \"qty\": 0 }\n { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e1\" }, \"color\": \"black\", \"qty\": 8 }\n { \"_id\": { \"$oid\": \"606b4cfc1601f9443b5d6978\" }, \"color\": \"orange\", \"qty\": 10 }]"
        },
        {
          "lang": "kotlin",
          "value": "data class PaintOrder(\n    @BsonId val id: ObjectId = ObjectId(),\n    val qty: Int,\n    val color: String\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(PaintOrder::color.name, \"orange\")\nval update = Updates.inc(PaintOrder::qty.name, 10)\nval options = UpdateOptions().upsert(true)\n\nval results = collection.updateOne(filter, update, options)\n\nprintln(results)\n"
        },
        {
          "lang": "console",
          "value": "  AcknowledgedUpdateResult{ matchedCount=0, modifiedCount=0, upsertedId=BsonObjectId{ value=606b4cfc1601f9443b5d6978 }}"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(PaintOrder::color.name, \"orange\")\nval update = Updates.inc(PaintOrder::qty.name, 10)\n\nval results = collection.updateOne(filter, update)\n\nprintln(results)\n"
        },
        {
          "lang": "console",
          "value": "AcknowledgedUpdateResult{ matchedCount=0, modifiedCount=0, upsertedId=null }"
        }
      ],
      "preview": "In this guide, you can learn how to perform an upsert with the\nMongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud/write-operations",
      "title": "Write Operations",
      "headings": [],
      "paragraphs": "Insert Operations Delete Documents Modify Documents Update Arrays in a Document Insert or Update in a Single Operation Bulk Operations",
      "code": [],
      "preview": null,
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/crud",
      "title": "CRUD Operations",
      "headings": [],
      "paragraphs": "CRUD (Create, Read, Update, Delete) operations enable you to work with\ndata stored in MongoDB. Some operations combine aspects of read and write operations. See our\nguide on  compound operations \nto learn more about these hybrid methods. Read Operations  find and return\ndocuments stored in your database. Write Operations  insert, modify,\nor delete documents in your database.",
      "code": [],
      "preview": "CRUD (Create, Read, Update, Delete) operations enable you to work with\ndata stored in MongoDB.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/data-formats/codecs",
      "title": "Codecs",
      "headings": [
        "Overview",
        "Codec",
        "CodecRegistry",
        "CodecProvider",
        "Default Codec Registry",
        "BsonTypeClassMap",
        "Custom Codec Example"
      ],
      "paragraphs": "In this guide, you can learn about  Codecs  and the supporting classes that\nhandle the encoding and decoding of Kotlin objects to and from BSON data\nin the MongoDB Kotlin driver. The  Codec  abstraction allows you to map any Kotlin type to\na corresponding BSON type. You can use this to map your domain objects\ndirectly to and from BSON instead of using data classes or an intermediate\nmap-based object such as  Document  or  BsonDocument . You can learn how to specify custom encoding and decoding logic using\nthe  Codec  abstraction and view example implementations in the following\nsections: Codec CodecRegistry CodecProvider Custom Codec Example The  Codec  interface contains abstract methods for serializing and\ndeserializing Kotlin objects to BSON data. You can define your conversion logic\nbetween BSON and your Kotlin object in your implementation of this interface. To implement the  Codec  interface, override the  encode() ,  decode() ,\nand  getEncoderClass()  abstract methods. The  encode()  method requires the following parameters: This method uses the  BsonWriter  instance to send the encoded value to\nMongoDB and does not return a value. The  decode()  method returns your Kotlin object instance populated with the\nvalue from the BSON data. This method requires the following parameters: The  getEncoderClass()  method returns a class instance of the Kotlin class\nsince Kotlin cannot infer the type due to type erasure. See the following code examples that show how you can implement a custom\n Codec . The  PowerStatus  enum contains the values \"ON\" and \"OFF\" to represent\nthe states of an electrical switch. The  PowerStatusCodec  class implements  Codec  in order to convert\nthe Kotlin  enum  values to corresponding BSON boolean values. The\n encode()  method converts a  PowerStatus  to a BSON boolean and the\n decode()  method performs the conversion in the opposite direction. You can add an instance of the  PowerStatusCodec  to your  CodecRegistry \nwhich contains a mapping between your  Codec  and the Kotlin object type to\nwhich it applies. Continue to the  CodecRegistry \nsection of this page to see how you can include your  Codec . For more information about the classes and interfaces in this section, see the\nfollowing API Documentation: Parameter Type Description writer An instance of a class that implements  BsonWriter , an interface type\nthat exposes methods for writing a BSON document. For example, the\n BsonBinaryWriter  implementation writes to a binary stream of data.\nUse this instance to write your BSON value using the appropriate\nwrite method. value The data that your implementation encodes. The type must match the type\nvariable assigned to your implementation. encoderContext Contains meta information about the Kotlin object data that it encodes\nto BSON including whether to store the current value in a\nMongoDB collection. Parameter Type Description bsonReader An instance of a class that implements  BsonReader , an interface type\nthat exposes methods for reading a BSON document. For example, the\n BsonBinaryReader  implementation reads from a binary stream of data. decoderContext Contains information about the BSON data that it decodes to a Kotlin\nobject. Codec BsonWriter BsonBinaryWriter EncoderContext BsonReader DecoderContext BsonBinaryReader A  CodecRegistry  is an immutable collection of  Codec  instances that\nencode and decode the Kotlin classes they specify. You can use any of the\nfollowing  CodecRegistries  class static factory methods to construct a\n CodecRegistry  from the  Codec  instances contained in the associated\ntypes: The following code snippet shows how to construct a  CodecRegistry  using\nthe  fromCodecs()  method: In the preceding example, we assign the  CodecRegistry  the following  Codec \nimplementations: You can retrieve the  Codec  instances from the  CodecRegistry  instance\nfrom the prior example using the following code: If you attempt to retrieve a  Codec  instance for a class that is not\nregistered, the  get()  method throws a  CodecConfigurationException \nexception. For more information about the classes and interfaces in this section, see the\nfollowing API Documentation: fromCodecs() fromProviders() fromRegistries() IntegerCodec , a  Codec  that converts  Integers  and is part of the BSON package. PowerStatusCodec , our sample  Codec \nthat converts Kotlin enum values to BSON booleans. CodecRegistries IntegerCodec A  CodecProvider  is an interface that contains abstract methods that create\n Codec  instances and assign them to a  CodecRegistry  instance. Similar\nto the  CodecRegistry , the BSON library uses the  Codec  instances\nretrieved by the  get()  method to convert between Kotlin and BSON data types. However, in cases in which you add a class that contains fields that require\ncorresponding  Codec  objects, you need to ensure that you instantiate the\n Codec  objects for the class' fields before you instantiate the\n Codec  for the class. You can use the  CodecRegistry  parameter in\nthe  get()  method to pass any of the  Codec  instances that the\n Codec  relies on. The following code example shows how you can implement  CodecProvider  to\npass the  MonolightCodec  any  Codec  instances it needs in a\n CodecRegistry  instance such as the  PowerStatusCodec  from our prior\nexample: To see a runnable example that demonstrates read and write operations using\nthese  Codec  classes, see the  Custom Codec Example \nsection of this guide. The default codec registry is a set of  CodecProvider  classes that\nspecify conversion between commonly-used Kotlin and MongoDB types. The\ndriver automatically uses the default codec registry unless you specify\na different one. If you need to override the behavior of one or more  Codec  classes, but\nkeep the behavior from the default codec registry for the other classes,\nyou can specify all of the registries in order of precedence. For example,\nsuppose you wanted to override the default provider behavior of a  Codec  for\nenum types with your custom  MyEnumCodec , you must add it to the registry\nlist prior to the default codec registry as shown in the example below: For more information about the classes and interfaces in this section, see\nthe following API documentation sections: CodecProvider Default codec registry The  BsonTypeClassMap  class contains a recommended mapping between BSON\nand Kotlin types. You can use this class in your custom  Codec  or\n CodecProvider  to help you manage which Kotlin types to decode your BSON\ntypes to container classes that implement  Iterable  or  Map  such as\nthe  Document  class. You can add or modify the  BsonTypeClassMap  default mapping by passing a\n Map  containing new or replacement entries. The following code snippet shows how you can retrieve the Kotlin class type\nthat corresponds to the BSON type in the default  BsonTypeClassMap \ninstance: You can modify these mappings in your instance by specifying replacements in the\n BsonTypeClassMap  constructor. The following code snippet shows how\nyou can replace the mapping for  ARRAY  in your  BsonTypeClassMap \ninstance with the  Set  class: For a complete list of the default mappings, refer to the\n BsonTypeClassMap  API Documentation. For an example of how the  Document  class uses  BsonTypeClassMap , see\nthe driver source code for the following classes: DocumentCodecProvider DocumentCodec In this section, we show how you can implement  Codec  and  CodecProvider \nto define the encoding and decoding logic for a custom Kotlin class. We also show\nhow you can specify and use your custom implementations to perform insert\nand retrieve operations. The following code snippet shows our example custom class called  Monolight \nand its fields that we want to store and retrieve from a MongoDB collection: This class contains the following fields, each of which we need to assign a\n Codec : The following code example shows how we can implement a  Codec  for the\n Monolight  class. Note that the constructor expects an instance of\n CodecRegistry  from which it retrieves the  Codec  instances it needs\nto encode and decode its fields: To ensure we make the  Codec  instances for the fields available for\n Monolight , we implement a custom  CodecProvider  shown in the following\ncode example: After defining the conversion logic, we can perform the following: The following example class contains code that assigns the\n MonolightCodecProvider  to the  MongoCollection  instance by passing it\nto the  withCodecRegistry()  method. The example class also inserts and\nretrieves data using the  Monolight  class and associated codecs: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: As an alternative to implementing custom codecs, you can use\nKotlin serialization to handle your data encoding and decoding with\n @Serializable  classes. You might choose Kotlin serialization if you are\nalready familiar with the framework or prefer to use an idiomatic Kotlin approach.\nSee the  Kotlin Serialization \ndocumentation for more information. powerStatus  describes whether the light is switched \"on\" or \"off\" for\nwhich we use the  PowerStatusCodec  that\nconverts specific enum values to BSON booleans. colorTemperature  describes the color of the light and contains an\n Int  value for which we use the  IntegerCodec  included in the\nBSON library. Store data from instances of  Monolight  into MongoDB Retrieve data from MongoDB into instances of  Monolight withCodecRegistry() MongoClientSettings.getDefaultCodecRegistry() Codec CodecProvider",
      "code": [
        {
          "lang": "kotlin",
          "value": "enum class PowerStatus {\n    ON,\n    OFF\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "class PowerStatusCodec : Codec<PowerStatus> {\n    override fun encode(writer: BsonWriter, value: PowerStatus, encoderContext: EncoderContext) = writer.writeBoolean(value == PowerStatus.ON)\n\n    override fun decode(reader: BsonReader, decoderContext: DecoderContext): PowerStatus {\n        return when (reader.readBoolean()) {\n            true -> PowerStatus.ON\n            false -> PowerStatus.OFF\n        }\n    }\n\n    override fun getEncoderClass(): Class<PowerStatus> = PowerStatus::class.java\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val codecRegistry = CodecRegistries.fromCodecs(IntegerCodec(), PowerStatusCodec())\n"
        },
        {
          "lang": "kotlin",
          "value": "val powerStatusCodec = codecRegistry.get(PowerStatus::class.java)\nval integerCodec = codecRegistry.get(Integer::class.java)\n"
        },
        {
          "lang": "kotlin",
          "value": "class MonolightCodec(registry: CodecRegistry) : Codec<Monolight> {\n    private val powerStatusCodec: Codec<PowerStatus>\n    private val integerCodec: Codec<Int>\n\n    init {\n        powerStatusCodec = registry[PowerStatus::class.java]\n        integerCodec = IntegerCodec()\n    }\n\n    override fun encode(writer: BsonWriter, value: Monolight, encoderContext: EncoderContext) {\n        writer.writeStartDocument()\n        writer.writeName(\"powerStatus\")\n        powerStatusCodec.encode(writer, value.powerStatus, encoderContext)\n        writer.writeName(\"colorTemperature\")\n        integerCodec.encode(writer, value.colorTemperature, encoderContext)\n        writer.writeEndDocument()\n    }\n\n    override fun decode(reader: BsonReader, decoderContext: DecoderContext): Monolight {\n        val monolight = Monolight()\n        reader.readStartDocument()\n        while (reader.readBsonType() != BsonType.END_OF_DOCUMENT) {\n            when (reader.readName()) {\n                \"powerStatus\" -> monolight.powerStatus = powerStatusCodec.decode(reader, decoderContext)\n                \"colorTemperature\" -> monolight.colorTemperature = integerCodec.decode(reader, decoderContext)\n                \"_id\" -> reader.readObjectId()\n            }\n        }\n        reader.readEndDocument()\n        return monolight\n    }\n\n    override fun getEncoderClass(): Class<Monolight> = Monolight::class.java\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val newRegistry = CodecRegistries.fromRegistries(\n    CodecRegistries.fromCodecs(MyEnumCodec()),\n    MongoClientSettings.getDefaultCodecRegistry()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val bsonTypeClassMap = BsonTypeClassMap()\nval clazz = bsonTypeClassMap[BsonType.ARRAY]\nprintln(\"Class name: \" + clazz.name)\n"
        },
        {
          "lang": "console",
          "value": "Java type: java.util.List"
        },
        {
          "lang": "kotlin",
          "value": "val replacements = mutableMapOf<BsonType, Class<*>>(BsonType.ARRAY to MutableSet::class.java)\nval bsonTypeClassMap = BsonTypeClassMap(replacements)\nval clazz = bsonTypeClassMap[BsonType.ARRAY]\nprintln(\"Class name: \" + clazz.name)\n"
        },
        {
          "lang": "console",
          "value": "Java type: java.util.Set"
        },
        {
          "lang": "kotlin",
          "value": "data class Monolight(\n    var powerStatus: PowerStatus = PowerStatus.OFF,\n    var colorTemperature: Int? = null\n) {\n    override fun toString(): String = \"Monolight [powerStatus=$powerStatus, colorTemperature=$colorTemperature]\"\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "class MonolightCodec(registry: CodecRegistry) : Codec<Monolight> {\n    private val powerStatusCodec: Codec<PowerStatus>\n    private val integerCodec: Codec<Int>\n\n    init {\n        powerStatusCodec = registry[PowerStatus::class.java]\n        integerCodec = IntegerCodec()\n    }\n\n    override fun encode(writer: BsonWriter, value: Monolight, encoderContext: EncoderContext) {\n        writer.writeStartDocument()\n        writer.writeName(\"powerStatus\")\n        powerStatusCodec.encode(writer, value.powerStatus, encoderContext)\n        writer.writeName(\"colorTemperature\")\n        integerCodec.encode(writer, value.colorTemperature, encoderContext)\n        writer.writeEndDocument()\n    }\n\n    override fun decode(reader: BsonReader, decoderContext: DecoderContext): Monolight {\n        val monolight = Monolight()\n        reader.readStartDocument()\n        while (reader.readBsonType() != BsonType.END_OF_DOCUMENT) {\n            when (reader.readName()) {\n                \"powerStatus\" -> monolight.powerStatus = powerStatusCodec.decode(reader, decoderContext)\n                \"colorTemperature\" -> monolight.colorTemperature = integerCodec.decode(reader, decoderContext)\n                \"_id\" -> reader.readObjectId()\n            }\n        }\n        reader.readEndDocument()\n        return monolight\n    }\n\n    override fun getEncoderClass(): Class<Monolight> = Monolight::class.java\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "class MonolightCodecProvider : CodecProvider {\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T> get(clazz: Class<T>, registry: CodecRegistry): Codec<T>? {\n        return if (clazz == Monolight::class.java) {\n            MonolightCodec(registry) as Codec<T>\n        } else null // Return null when not a provider for the requested class\n    }\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "fun main() = runBlocking {\n    val mongoClient = MongoClient.create(\"<connection string uri>\")\n    val codecRegistry = CodecRegistries.fromRegistries(\n        CodecRegistries.fromCodecs(IntegerCodec(), PowerStatusCodec()),\n        CodecRegistries.fromProviders(MonolightCodecProvider()),\n        MongoClientSettings.getDefaultCodecRegistry()\n    )\n    val database = mongoClient.getDatabase(\"codecs_example_products\")\n    val collection = database.getCollection<Monolight>(\"monolights\")\n        .withCodecRegistry(codecRegistry)\n\n    // Construct and insert an instance of Monolight\n    val myMonolight = Monolight(PowerStatus.ON, 5200)\n    collection.insertOne(myMonolight)\n\n    // Retrieve one or more instances of Monolight\n    val lights =  collection.find().toList()\n    println(lights)\n}\n"
        },
        {
          "lang": "none",
          "value": "[Monolight [powerStatus=ON, colorTemperature=5200]]"
        }
      ],
      "preview": "In this guide, you can learn about Codecs and the supporting classes that\nhandle the encoding and decoding of Kotlin objects to and from BSON data\nin the MongoDB Kotlin driver. The Codec abstraction allows you to map any Kotlin type to\na corresponding BSON type. You can use this to map your domain objects\ndirectly to and from BSON instead of using data classes or an intermediate\nmap-based object such as Document or BsonDocument.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/data-formats/document-data-format-bson",
      "title": "Document Data Format: BSON",
      "headings": [
        "Overview",
        "BSON Data Format",
        "MongoDB and BSON",
        "Install the BSON Library"
      ],
      "paragraphs": "In this guide, you can learn about the BSON data format, how MongoDB\nuses it, and how to install the BSON library independently of the\nMongoDB Kotlin driver. BSON , or Binary JSON, is the data format that MongoDB uses to organize\nand store data. This data format includes all JSON data structure types and\nadds support for types including dates, different size integers, ObjectIds, and\nbinary data. For a complete list of supported types, see the\n BSON Types  server manual page. The binary format is not human-readable, but you can use the\n BSON library  to convert it to a JSON\nrepresentation. You can read more about the relationship between these\nformats in our article on  JSON and BSON . The MongoDB Kotlin driver, which uses the BSON library, allows you to work\nwith BSON data by using one of the object types that implements the\n BSON interface ,\nincluding: For more information on using these object types, see our\n Documents guide . Document  (BSON library package) BsonDocument  (BSON library package) RawBsonDocument  (BSON library package) JsonObject  (BSON library package) These instructions show you how to add the BSON library as a dependency to\nyour project. If you added the MongoDB Kotlin driver as a dependency to your\nproject, you can skip this step since the BSON library is already included\nas a required dependency of the driver. For instructions on how to add the\nMongoDB Kotlin driver as a dependency to your project, see the\n driver installation  section of our Quick Start\nguide. We recommend that you use the  Maven  or\n Gradle  build automation tool to manage your project's\ndependencies. Select from the following tabs to see the dependency declaration\nfor that tool: If you are not using one of the preceding tools, you can include it in\nyour project by downloading the JAR file directly from the\n sonatype repository . The following snippet shows the dependency declaration in the\n dependencies  section of your  pom.xml  file. The following snippet shows the dependency declaration in the\n dependencies  object in your  build.gradle  file.",
      "code": [
        {
          "lang": "xml",
          "value": "<dependencies>\n    <dependency>\n        <groupId>org.mongodb</groupId>\n        <artifactId>bson</artifactId>\n        <version>5.1.2</version>\n    </dependency>\n</dependencies>"
        },
        {
          "lang": "kotlin",
          "value": "dependencies {\n   implementation(\"org.mongodb:bson:5.1.2\")\n}"
        }
      ],
      "preview": "In this guide, you can learn about the BSON data format, how MongoDB\nuses it, and how to install the BSON library independently of the\nMongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/data-formats/document-data-format-data-class",
      "title": "Document Data Format: Data Classes",
      "headings": [
        "Overview",
        "Serialize and Deserialize a Data Class",
        "Example Data Class",
        "Insert a Data Class",
        "Retrieve a Data Class",
        "Specify Component Conversion Using Annotations",
        "Example Annotated Data Class",
        "Insert an Annotated Data Class",
        "Retrieve an Annotated Data Class",
        "Operations with Recursive Types"
      ],
      "paragraphs": "In this guide, you can learn how to store and retrieve data in the\nMongoDB Kotlin Driver using  Kotlin data classes . The driver natively supports encoding and decoding Kotlin data classes for\nMongoDB read and write operations using the  default codec registry . The\ndefault codec registry is a collection of classes called  codecs  that\ndefine how to encode and decode Kotlin and Java types. The code examples in this section reference the following sample data class, which\ndescribes a data storage device: You can insert a  DataStorage  instance as shown in the following code: You can retrieve documents as  DataStorage  instances and print them\nas shown in the following code: You specify a class for documents returned from a collection, even if it\nis different than the class you specified when retrieving the\ncollection. The following example performs an update to the document\nrepresented by the  DataStorage  data class in the previous example\nand returns the updated document as a  NewDataStorage  type. The\noperation adds the  releaseDate  field to the document with a\n name  value of  tape : For more information about this feature, see  Specify Return Type  in the Databases and Collections guide. This section describes the annotations you can use to configure the\nserialization behavior of data classes and provides an example to\ndemonstrate the annotation behavior. You can use the following annotations on data classes: For reference information on these property annotations,\nrefer to the  org.bson.codecs.pojo.annotations \npackage. Annotation Name Description BsonId Marks a property to serialize as the _id property. BsonProperty Specifies a custom document field name when converting the data class\nfield to BSON. BsonRepresentation Specifies the BSON type MongoDB uses to store the value. Use this\nannotation only when you need to store a value as a different\nBSON type than the data class property. Your code might throw an exception if you include the\n BsonRepresentation  annotation on a property that you store\nas the same type as the data class property. The code examples in this section reference the following sample data class, which\ndescribes a network device: You can insert a  NetworkDevice  instance as shown in the following code: The inserted document in MongoDB should resemble the following: You can retrieve documents as  NetworkDevice  instances and print them\nas shown in the following code: The driver natively supports encoding and decoding of recursively\ndefined data classes without causing runtime recursion. This support extends\nto cycles of multiple data class types in type definitions. The following\ncode provides an example of a recursive data class design: You can perform read and write operations on recursively defined data classes the same\nway you would for other data classes. The following code shows how you can\nexecute a find operation on a collection of  DataClassTree  types:",
      "code": [
        {
          "lang": "kotlin",
          "value": "data class DataStorage(val productName: String, val capacity: Double)\n"
        },
        {
          "lang": "kotlin",
          "value": "val collection = database.getCollection<DataStorage>(\"data_storage\")\nval record = DataStorage(\"tape\", 5.0)\ncollection.insertOne(record)\n"
        },
        {
          "lang": "kotlin",
          "value": "val collection = database.getCollection<DataStorage>(\"data_storage_devices\")\n\n// Retrieve and print the documents as data classes\nval resultsFlow = collection.find()\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "DataStorage(productName=tape, capacity=5.0)"
        },
        {
          "lang": "kotlin",
          "value": "// Define a data class for returned documents\ndata class NewDataStorage(\n    val productName: String,\n    val capacity: Double,\n    val releaseDate: LocalDate\n)\n\nval filter = Filters.eq(DataStorage::productName.name, \"tape\")\nval update = Updates.currentDate(\"releaseDate\")\nval options = FindOneAndUpdateOptions().returnDocument(ReturnDocument.AFTER)\n\n// Specify the class for returned documents as the type parameter in withDocumentClass()\nval result = collection\n    .withDocumentClass<NewDataStorage>()\n    .findOneAndUpdate(filter, update, options)\n\nprintln(\"Updated document: ${result}\")\n"
        },
        {
          "lang": "console",
          "value": "Updated document: NewDataStorage(productName=tape, capacity=5.0, releaseDate=2023-06-15)"
        },
        {
          "lang": "kotlin",
          "value": "data class NetworkDevice(\n    @BsonId\n    @BsonRepresentation(BsonType.OBJECT_ID)\n    val deviceId: String,\n    val name: String,\n    @BsonProperty(\"type\")\n    val deviceType: String\n)\n"
        },
        {
          "lang": "json",
          "value": "{\n  _id: ObjectId(\"fedc...\"),\n  name: 'Enterprise Wi-fi',\n  type: 'router'\n}"
        },
        {
          "lang": "kotlin",
          "value": "val collection = database.getCollection<NetworkDevice>(\"network_devices\")\n\n// Insert the record\nval deviceId = ObjectId().toHexString()\nval device = NetworkDevice(deviceId, \"Enterprise Wi-fi\", \"router\")\ncollection.insertOne(device)\n"
        },
        {
          "lang": "kotlin",
          "value": "val collection = database.getCollection<NetworkDevice>(\"network_devices\")\n\n// Return all documents in the collection as data classes\nval resultsFlow = collection.find()\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "NetworkDevice(deviceId=645cf..., name=Enterprise Wi-fi, deviceType=router)"
        },
        {
          "lang": "kotlin",
          "value": "data class DataClassTree(\n    val content: String,\n    val left: DataClassTree?,\n    val right: DataClassTree?\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val collection = database.getCollection<DataClassTree>(\"myCollection\")\n\nval filter = Filters.eq(\"left.left.right.content\", \"high german\")\nval resultsFlow = collection.find(filter)\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "DataClassTree(content=indo-european, left=DataClassTree(content=germanic, left=DataClassTree(content=german, left=null, right=DataClassTree(content=high german, ...)), right=...)"
        }
      ],
      "preview": "In this guide, you can learn how to store and retrieve data in the\nMongoDB Kotlin Driver using Kotlin data classes.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/data-formats/document-data-format-extended-json",
      "title": "Document Data Format: Extended JSON",
      "headings": [
        "Overview",
        "Extended JSON Formats",
        "Extended JSON Examples",
        "Read Extended JSON",
        "Using the Document Classes",
        "Using the BSON Library",
        "Write Extended JSON",
        "Using the Document Classes",
        "Using the BSON Library",
        "Custom BSON Type Conversion"
      ],
      "paragraphs": "In this guide, you can learn how to use the Extended JSON format in the\nMongoDB Kotlin driver. JSON is a data format that represents the values of objects, arrays, numbers,\nstrings, booleans, and nulls. The  Extended JSON  format defines a reserved\nset of keys prefixed with \" $ \" to represent field type information that\ndirectly corresponds to each type in BSON, the format that MongoDB uses to\nstore data. This guide explains the following topics: For more information on the difference between these formats, see our\n article on JSON and BSON . The different MongoDB Extended JSON formats How to use the BSON library to convert between Extended JSON and Kotlin objects How to create a custom conversion of BSON types MongoDB Extended JSON features different string formats to represent BSON data.\nEach of the different formats conform to the JSON RFC\nand meet specific use cases. The  extended  format, also known as the\n canonical  format, features specific representations for every BSON type\nfor bidirectional conversion without loss of information. The  Relaxed mode \nformat is more concise and closer to ordinary JSON, but does not represent\nall the type information such as the specific byte size of number fields. See the following table to see a description of each format: For more detailed information on these formats, see the following\nresources: Name Description Extended Relaxed Mode Shell Strict The driver parses the  $uuid  Extended JSON type from a string to a\n BsonBinary  object of binary subtype 4. For more information about  $uuid  field\nparsing, see the\n special rules for parsing $uuid fields \nsection in the extended JSON specification. JSON RFC  Official Documentation MongoDB Extended JSON  Server Manual Entry BsonBinary  API Documentation Extended JSON specification  GitHub Documentation The following examples show a document containing an ObjectId, date, and long\nnumber field represented in each Extended JSON format. Click the tab that\ncorresponds to the format of the example you want to see: You can read an Extended JSON string into a Kotlin document object by calling\nthe  parse()  static method from either the  Document  or  BsonDocument \nclass, depending on which object type you need. This method parses the Extended\nJSON string in any of the formats and returns an instance of that class\ncontaining the data. The following example shows how you can use the  Document  class to read\nan example Extended JSON string into a  Document  object using the\n parse()  method: For more information, see our Fundamentals page\non  Documents . You can also read an Extended JSON string into Kotlin objects without using\nthe MongoDB Kotlin driver's document classes by using the  JsonReader  class.\nThis class contains methods to sequentially parse the fields and values\nin any format of the Extended JSON string, and returns them as Kotlin objects.\nThe driver's document classes also use this class to parse Extended JSON. The following code example shows how you can use the  JsonReader  class to convert\nan Extended JSON string into Kotlin objects: For more information, see the  JsonReader  API Documentation. You can write an Extended JSON string from an instance of  Document  or\n BsonDocument  by calling the  toJson()  method, optionally passing it an\ninstance of  JsonWriterSettings  to specify the Extended JSON format. In this example, we output the Extended JSON in the Relaxed mode format. You can also output an Extended JSON string from data in Kotlin objects using\nthe BSON library with the  JsonWriter  class. To construct an instance\nof  JsonWriter , pass a subclass of a Java  Writer  to specify how\nyou want to output the Extended JSON. You can optionally pass a  JsonWriterSettings \ninstance to specify options such as the Extended JSON format. By default, the\n JsonWriter  uses the Relaxed mode format. The MongoDB Kotlin driver's\ndocument classes also use this class to convert BSON to Extended JSON. The following code example shows how you can use  JsonWriter  to create an\nExtended JSON string and output it to  System.out . We specify the format\nby passing the  outputMode()  builder method the  JsonMode.EXTENDED  constant: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: JsonWriter JsonWriterSettings outputMode() In addition to specifying the  outputMode()  to format the JSON output, you\ncan further customize the output by adding converters to your\n JsonWriterSettings.Builder . These converter methods detect the Kotlin types\nand execute the logic defined by the  Converter  passed to them. The following sample code shows how to append converters, defined as lambda\nexpressions, to simplify the Relaxed mode JSON output. For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: Converter JsonWriterSettings.Builder",
      "code": [
        {
          "lang": "json",
          "value": "{\n  \"_id\": { \"$oid\": \"573a1391f29313caabcd9637\" },\n  \"createdAt\": { \"$date\": { \"$numberLong\": \"1601499609\" }},\n  \"numViews\": { \"$numberLong\": \"36520312\" }\n}"
        },
        {
          "lang": "json",
          "value": "{\n  \"_id\": { \"$oid\": \"573a1391f29313caabcd9637\" },\n  \"createdAt\": { \"$date\": \"2020-09-30T18:22:51.648Z\" },\n  \"numViews\": 36520312\n}"
        },
        {
          "lang": "json",
          "value": "{\n  \"_id:\": ObjectId(\"573a1391f29313caabcd9637\"),\n  \"createdAt\": ISODate(\"2020-09-30T18:22:51.648Z\"),\n  \"numViews\": NumberLong(\"36520312\")\n}"
        },
        {
          "lang": "json",
          "value": "{\n  \"_id:\": { \"$oid\": \"573a1391f29313caabcd9637\" },\n  \"createdAt\": { \"$date\": 1601499609 },\n  \"numViews\": { \"$numberLong\": \"36520312\" }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val ejsonStr = \"\"\"\n        { \"_id\": { \"${\"$\"}oid\": \"507f1f77bcf86cd799439011\"},\n        \"myNumber\": {\"${\"$\"}numberLong\": \"4794261\" }}\n    \"\"\".trimIndent()\n\nval doc = Document.parse(ejsonStr)\n\nprintln(doc)\n"
        },
        {
          "lang": "console",
          "value": "Document{{_id=507f1f77bcf86cd799439011, myNumber=4794261}}"
        },
        {
          "lang": "kotlin",
          "value": "val ejsonStr = \"\"\"\n    { \"_id\": { \"${\"$\"}oid\": \"507f1f77bcf86cd799439011\"},\n      \"myNumber\": {\"${\"$\"}numberLong\": \"4794261\" }}\n    \"\"\".trimIndent()\n\nval jsonReader = JsonReader(ejsonStr)\n\njsonReader.readStartDocument()\n\njsonReader.readName(\"_id\")\nval id = jsonReader.readObjectId()\njsonReader.readName(\"myNumber\")\nval myNumber = jsonReader.readInt64()\n\njsonReader.readEndDocument()\n\nprintln(id.toString() + \" is type: \" + id.javaClass.name)\nprintln(myNumber.toString() + \" is type: \" + myNumber.javaClass.name)\n\njsonReader.close()\n"
        },
        {
          "lang": "console",
          "value": "507f1f77bcf86cd799439011 is type: org.bson.types.ObjectId\n4794261 is type: java.lang.Long"
        },
        {
          "lang": "kotlin",
          "value": "val myDoc = Document().append(\"_id\", ObjectId(\"507f1f77bcf86cd799439012\"))\n    .append(\"myNumber\", 11223344)\n\nval settings = JsonWriterSettings.builder().outputMode(JsonMode.RELAXED).build()\nmyDoc.toJson(settings)\n"
        },
        {
          "lang": "javascript",
          "value": "{\"_id\": {\"$oid\": \"507f1f77bcf86cd799439012\"}, \"myNumber\": 11223344}"
        },
        {
          "lang": "kotlin",
          "value": "val settings = JsonWriterSettings.builder().outputMode(JsonMode.EXTENDED).build()\n\nJsonWriter(BufferedWriter(OutputStreamWriter(System.out)), settings).use { jsonWriter ->\n    jsonWriter.writeStartDocument()\n    jsonWriter.writeObjectId(\"_id\", ObjectId(\"507f1f77bcf86cd799439012\"))\n    jsonWriter.writeInt64(\"myNumber\", 11223344)\n    jsonWriter.writeEndDocument()\n    jsonWriter.flush()\n}\n"
        },
        {
          "lang": "javascript",
          "value": "{\"_id\": {\"$oid\": \"507f1f77bcf86cd799439012\"}, \"myNumber\": {\"$numberLong\": \"11223344\"}}"
        },
        {
          "lang": "kotlin",
          "value": "val settings = JsonWriterSettings.builder()\n    .outputMode(JsonMode.RELAXED)\n    .objectIdConverter { value, writer -> writer.writeString(value.toHexString()) }\n    .timestampConverter { value, writer ->\n        val ldt = LocalDateTime.ofInstant(Instant.ofEpochSecond(value.time.toLong()), ZoneOffset.UTC)\n        writer.writeString(ldt.format(DateTimeFormatter.ISO_DATE_TIME))\n    }\n    .build()\n\nval doc = Document()\n    .append(\"_id\", ObjectId(\"507f1f77bcf86cd799439012\"))\n    .append(\"createdAt\", BsonTimestamp(1601516589,1))\n    .append(\"myNumber\", 4794261)\n\nprintln(doc.toJson(settings))\n"
        },
        {
          "lang": "javascript",
          "value": "{\"_id\": \"507f1f77bcf86cd799439012\", \"createdAt\": \"2020-10-01T01:43:09\", \"myNumber\": 4794261}\n\n// Without specifying the converters, the Relaxed mode JSON output\n// should look something like this:\n{\"_id\": {\"$oid\": \"507f1f77bcf86cd799439012\"}, \"createdAt\": {\"$timestamp\": {\"t\": 1601516589, \"i\": 1}}, \"myNumber\": 4794261}"
        }
      ],
      "preview": "In this guide, you can learn how to use the Extended JSON format in the\nMongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/data-formats/documents",
      "title": "Documents",
      "headings": [
        "Overview",
        "Document",
        "BsonDocument",
        "JsonObject",
        "Summary"
      ],
      "paragraphs": "In this guide, you can learn how to use  documents  in the\nMongoDB Kotlin driver. A MongoDB document is a data structure that contains key/value fields in\nbinary JSON (BSON) format. You can use documents and the data they contain\nin their fields to store data as well as issue commands or queries in\nMongoDB. For more information on the terminology, structure, and limitations of documents,\nread our page on  Documents  in the MongoDB manual. The MongoDB Kotlin driver and BSON library include the following classes that help you\naccess and manipulate the BSON data in documents: While you can use any of these classes in your application, we recommend\nthat you use the  Document  class since it can concisely represent\ndynamically structured documents of any complexity. It implements the\n Map<String, Object>  interface which enables it to use loosely-typed\nvalues. Name Package Implements Map Recommended Usage Document org.bson Yes, implements  Map<String, Object> When you want a flexible and concise data representation. BsonDocument org.bson Yes, implements  Map<String, BsonValue> When you need a type-safe API. JsonObject org.bson.json No When you only want to work with JSON strings. The  Document  class offers a flexible representation of a BSON document.\nYou can access and manipulate fields using Kotlin types from the standard\nlibrary with this class. See the following table for mappings between\nfrequently-used BSON and Kotlin types: In the following code snippet, we show how to instantiate and build a sample\n Document  instance representing a document containing several\ndifferent field types: To insert this document into a collection, instantiate a collection\nusing the  getCollection()  method and call the  insertOne  operation as follows: Once you perform a successful insert, you can retrieve the sample document\ndata from the collection using the following code: For more information on retrieving and manipulating MongoDB data, see our\n CRUD guide . For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: BSON type Kotlin type Array kotlin.collections.List Binary org.bson.types.Binary Boolean kotlin.Boolean Date java.time.LocalDateTime Document org.bson.Document Double kotlin.Double Int32 kotlin.Int Int64 kotlin.Long Null null ObjectId org.bson.types.ObjectId String kotlin.String The preceding code sample uses helper methods that check the returned type\nand throw an exception if it is unable to cast the field value.\nYou can call the  get()  method to retrieve values as type\n Object  and to skip type checking. Document getCollection() get() The  BsonDocument  class provides a type-safe API to access and manipulate\na BSON document. You need to specify the BSON type from the BSON\nlibrary for each field. See the following table for mappings between\nfrequently-used BSON and BSON library types: In the following code snippet, we show how to instantiate and build a sample\n BsonDocument  instance representing a document containing several\ndifferent field types: To insert this document into a collection, instantiate a collection\nusing the  getCollection()  method specifying the  BsonDocument \nclass as the  documentClass  parameter. Then, call the\n insertOne  operation as follows: Once you perform a successful insert, you can retrieve the sample document\ndata from the collection using the following code: For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: BSON type BSON library type Array org.bson.BsonArray Binary org.bson.BsonBinary Boolean org.bson.Boolean Date (long value) org.bson.BsonDateTime Document org.bson.BsonDocument Double org.bson.BsonDouble Int32 org.bson.BsonInt32 Int64 org.bson.BsonInt64 Null org.bson.BsonNull ObjectId org.bson.BsonObjectId String org.bson.BsonString The preceding code sample uses helper methods that check the returned type\nand throw a  BsonInvalidOperationException  if it is unable to cast\nthe field value. You can call the  get()  method to retrieve values as type\n BsonValue  and to skip type checking. BsonDocument getCollection() BsonInvalidOperationException get() BsonValue The  JsonObject  class acts as a wrapper for JSON strings.\nIf you only want to work with JSON data, you can use  JsonObject \nto avoid unnecessary data conversion to a  Map  object. By default,  JsonObject  stores  Extended JSON .\nYou can customize the format of JSON in  JsonObject  by specifying a\n JsonObjectCodec  and passing it a  JsonWriterSettings \nobject. For more information on JSON formats, see\nour  Extended JSON guide . In the following code snippet, we show how to instantiate a sample  JsonObject \ninstance wrapping an Extended JSON string containing different types of key value pairs: To insert this document into a collection, instantiate a collection\nusing the  getCollection()  method specifying the  JsonObject  class\nas the  documentClass  parameter. Then, call the\n insertOne  operation as follows: Once you perform a successful insert, you can retrieve the sample JSON data from the\ncollection. While you can use any class that extends  Bson  to specify your query,\nhere is how to query your data using a  JsonObject : For more information about the methods and classes mentioned in this section,\nsee the following API Documentation: JsonObject JsonObjectCodec JsonWriterSettings getCollection() In this guide, we covered the following topics on classes you can use to\nwork with BSON data: Described Kotlin classes you can use to work with MongoDB documents and\nwhy you might prefer one over the other. Provided usage examples for each class on building documents containing\nmultiple types, inserting them into a collection, and\nretrieving/accessing their typed fields.",
      "code": [
        {
          "lang": "kotlin",
          "value": "val author = Document(\"_id\", ObjectId())\n    .append(\"name\", \"Gabriel Garc\u00eda M\u00e1rquez\")\n    .append(\n        \"dateOfDeath\",\n        LocalDateTime.of(2014, 4, 17, 4, 0)\n    )\n    .append(\n        \"novels\", listOf(\n            Document(\"title\", \"One Hundred Years of Solitude\").append(\"yearPublished\", 1967),\n            Document(\"title\", \"Chronicle of a Death Foretold\").append(\"yearPublished\", 1981),\n            Document(\"title\", \"Love in the Time of Cholera\").append(\"yearPublished\", 1985)\n        )\n    )\n"
        },
        {
          "lang": "kotlin",
          "value": "// val mongoClient = <code to instantiate your client>\n\nval database = mongoClient.getDatabase(\"fundamentals_data\")\nval collection = database.getCollection<Document>(\"authors\")\nval result = collection.insertOne(author)\n"
        },
        {
          "lang": "kotlin",
          "value": "val doc = collection.find(Filters.eq(\"name\", \"Gabriel Garc\u00eda M\u00e1rquez\")).firstOrNull()\ndoc?.let {\n    println(\"_id: ${it.getObjectId(\"_id\")}, name: ${it.getString(\"name\")}, dateOfDeath: ${it.getDate(\"dateOfDeath\")}\")\n\n    it.getList(\"novels\", Document::class.java).forEach { novel ->\n        println(\"title: ${novel.getString(\"title\")}, yearPublished: ${novel.getInteger(\"yearPublished\")}\")\n    }\n}\n"
        },
        {
          "lang": "none",
          "value": "_id: 5fb5fad05f734e3794741a35, name: Gabriel Garc\u00eda M\u00e1rquez, dateOfDeath: Thu Apr 17 00:00:00 EDT 2014\ntitle: One Hundred Years of Solitude, yearPublished: 1967\ntitle: Chronicle of a Death Foretold, yearPublished: 1981\ntitle: Love in the Time of Cholera, yearPublished: 1985"
        },
        {
          "lang": "kotlin",
          "value": "val author = BsonDocument()\n    .append(\"_id\", BsonObjectId())\n    .append(\"name\", BsonString(\"Gabriel Garc\u00eda M\u00e1rquez\"))\n    .append(\n        \"dateOfDeath\",\n        BsonDateTime(\n            LocalDateTime.of(2014, 4, 17, 0, 0).atZone(ZoneId.of(\"America/New_York\")).toInstant().toEpochMilli()\n        )\n    )\n    .append(\n        \"novels\", BsonArray(\n            listOf(\n                BsonDocument().append(\"title\", BsonString(\"One Hundred Years of Solitude\"))\n                    .append(\"yearPublished\", BsonInt32(1967)),\n                BsonDocument().append(\"title\", BsonString(\"Chronicle of a Death Foretold\"))\n                    .append(\"yearPublished\", BsonInt32(1981)),\n                BsonDocument().append(\"title\", BsonString(\"Love in the Time of Cholera\"))\n                    .append(\"yearPublished\", BsonInt32(1985))\n            )\n        )\n    )\n"
        },
        {
          "lang": "kotlin",
          "value": "// val mongoClient = <code to instantiate your client>\n\nval database = mongoClient.getDatabase(\"fundamentals_data\")\nval collection = database.getCollection<BsonDocument>(\"authors\")\n\nval result: InsertOneResult = collection.insertOne(author)\n"
        },
        {
          "lang": "kotlin",
          "value": "// <MongoCollection setup code here>\n\nval doc = collection.find(Filters.eq(\"name\", \"Gabriel Garc\u00eda M\u00e1rquez\")).firstOrNull()\ndoc?.let {\n    println(\"_id: ${it.getObjectId(\"_id\").value}, name: ${it.getString(\"name\").value}, dateOfDeath: ${Instant.ofEpochMilli(it.getDateTime(\"dateOfDeath\").value).atZone(ZoneId.of(\"America/New_York\")).toLocalDateTime()}\")\n\n    it.getArray(\"novels\").forEach { novel ->\n        val novelDocument = novel.asDocument()\n        println(\"title: ${novelDocument.getString(\"title\").value}, yearPublished: ${novelDocument.getInt32(\"yearPublished\").value}\")\n    }\n}\n"
        },
        {
          "lang": "none",
          "value": "_id: 5fb5fad05f734e3794741a35, name: Gabriel Garc\u00eda M\u00e1rquez, dateOfDeath: 2014-04-17T00:00\ntitle: One Hundred Years of Solitude, yearPublished: 1967\ntitle: Chronicle of a Death Foretold, yearPublished: 1981\ntitle: Love in the Time of Cholera, yearPublished: 1985"
        },
        {
          "lang": "kotlin",
          "value": "val ejsonStr = \"\"\"\n    {\"_id\": {\"${\"$\"}oid\": \"6035210f35bd203721c3eab8\"},\n    \"name\": \"Gabriel Garc\u00eda M\u00e1rquez\",\n    \"dateOfDeath\": {\"${\"$\"}date\": \"2014-04-17T04:00:00Z\"},\n    \"novels\": [\n        {\"title\": \"One Hundred Years of Solitude\",\"yearPublished\": 1967},\n        {\"title\": \"Chronicle of a Death Foretold\",\"yearPublished\": 1981},\n        {\"title\": \"Love in the Time of Cholera\",\"yearPublished\": 1985}]}\n    \"\"\".trimIndent()\n\nval author = JsonObject(ejsonStr)\n"
        },
        {
          "lang": "kotlin",
          "value": "// val mongoClient = <code to instantiate your client>;\n\nval database = mongoClient.getDatabase(\"fundamentals_data\")\nval collection= database.getCollection<JsonObject>(\"authors\")\n\nval result = collection.insertOne(author)\n"
        },
        {
          "lang": "kotlin",
          "value": "// val mongoClient = <code to instantiate your client>;\n\nval query = JsonObject(\"{\\\"name\\\": \\\"Gabriel Garc\\\\u00eda M\\\\u00e1rquez\\\"}\")\nval jsonResult = collection.find(query).firstOrNull()\njsonResult?.let {\n    println(\"query result in extended json format: \" + jsonResult.json)\n}\n"
        },
        {
          "lang": "none",
          "value": "query result in extended json format: {\"_id\": {\"$oid\": \"6035210f35bd203721c3eab8\"}, \"name\": \"Gabriel Garc\u00eda M\u00e1rquez\", \"dateOfDeath\": {\"$date\": \"2014-04-17T04:00:00Z\"}, \"novels\": [{\"title\": \"One Hundred Years of Solitude\", \"yearPublished\": 1967}, {\"title\": \"Chronicle of a Death Foretold\", \"yearPublished\": 1981}, {\"title\": \"Love in the Time of Cholera\", \"yearPublished\": 1985}]}"
        }
      ],
      "preview": "In this guide, you can learn how to use documents in the\nMongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/data-formats/serialization",
      "title": "Kotlin Serialization",
      "headings": [
        "Overview",
        "Supported Types",
        "Add Kotlin Serialization to Your Project",
        "Annotate Data Classes",
        "Custom Serializer Example",
        "Customize the Serializer Configuration",
        "Custom Codec Example",
        "Polymorphic Serialization",
        "Polymorphic Data Classes Example"
      ],
      "paragraphs": "The Kotlin driver supports the  kotlinx.serialization  library for\nserializing and deserializing Kotlin objects. The driver provides an efficient  Bson  serializer that you can use with\nclasses marked as  @Serializable  to handle the serialization of Kotlin objects\nto BSON data. You can also install the  bson-kotlinx  library to support\n custom codecs  with configurations to encode\ndefaults, encode nulls, and define class discriminators. Although you can use the Kotlin driver with the Kotlin serialization  Json \nlibrary, the  Json  serializer does  not  directly support BSON value types such\nas  ObjectId . You must provide a custom serializer that can handle the\nconversion between BSON and JSON. To learn how to use the  Codec  interface instead of the\nKotlin serialization library to specify custom encoding and decoding\nof Kotlin objects to BSON data, see the  Codecs  guide. You might choose Kotlin serialization if you are already familiar\nwith the framework or if you prefer to use an idiomatic Kotlin approach. The Kotlin driver supports: All Kotlin types that are supported by the Kotlin serialization library All available  BSON types Support for serialization in the Kotlin driver depends on the official  Kotlin\nserialization library . Select from the following tabs to see how to add the serialization\ndependencies to your project by using the  Gradle  and\n Maven  package managers: If you are using  Gradle  to manage your\ndependencies, add the following to your  build.gradle.kts  dependencies list: If you are using  Maven  to manage your\ndependencies, add the following to your  pom.xml  dependencies list: To declare a class as serializable, annotate your Kotlin data classes with the\n @Serializable  annotation from the Kotlin serialization framework. You can use your data classes in your code as normal after you mark them as serializable.\nThe Kotlin driver and the Kotlin serialization framework handle the\nBSON serialization and deserialization. This example shows a simple data class annotated with the following: For more information on serializable classes and available annotation classes,\nsee the  official Kotlin Serialization \ndocumentation. @Serializable  to mark the class as serializable. @SerialName  to specify the name of the  id  and  manufacturer  properties\nin the BSON document. This can be used in place of the  @BsonId  and\n @BsonProperty  annotations, which are unsupported in serializable classes. @Contextual  to mark the BSON  id  property to use the built-in  ObjectIdSerializer .\nThis annotation is required for BSON types to be serialized correctly. You cannot use  annotations \nfrom the  org.bson.codecs.pojo.annotations  package on  @Serializable  data classes. You can create a custom serializer to handle how your data is\nrepresented in BSON. The Kotlin driver uses the  KSerializer \ninterface from the  kotlinx.serialization  package to implement custom\nserializers. You can specify the custom serializer as the parameter to\nthe  @Serializable  annotation for a specific field. The following example shows how to create a custom\n KSerializer  instance to convert a  kotlinx.datetime.Instant  to a\n BsonDateTime : The following code shows the  PaintOrder  data class in which the\n orderDate  field has an annotation that specifies the custom\nserializer class defined in the preceding code: For more information about the methods and classes mentioned in this section,\nsee the following API documentation: KSerializer Instant BsonEncoder BsonDecoder You can use the  KotlinSerializerCodec  class from the  org.bson.codecs.kotlinx \npackage to create a codec for your  @Serializable  data classes and\ncustomize what is stored. Use the  BsonConfiguration  class to define the configuration,\nincluding whether to encode defaults, encode nulls, or define class discriminators. To create a custom codec, install the  bson-kotlinx \ndependency to your project. Select from the following tabs to see how to\nadd the dependency to your project by using the  Gradle  and\n Maven  package managers: Then, you can define your codec using the\n KotlinSerializerCodec.create() \nmethod and add it to the registry. If you are using  Gradle  to manage your\ndependencies, add the following to your  build.gradle.kts  dependencies list: If you are using  Maven  to manage your\ndependencies, add the following to your  pom.xml  dependencies list: You can also optionally install the  bson-kotlin  dependency\nthrough the default codec registry. This dependency uses reflection\nand the codec registry to support Kotlin data classes, but it does\nnot support certain POJO annotations such as  BsonDiscriminator ,\n BsonExtraElements , and  BsonConstructor . To learn more, see\nthe  bson-kotlin API documentation . Generally, we recommend that you install and use the faster\n bson-kotlinx  library for codec configuration. The following example shows how to create a codec using the\n KotlinSerializerCodec.create()  method and configure it to not encode defaults: For more information about the methods and classes mentioned in this section,\nsee the following API documentation: KotlinSerializerCodec KotlinSerializerCodec.create() BsonConfiguration The Kotlin driver natively supports serialization and deserialization\nof polymorphic classes. When you mark a sealed interface and data\nclasses that inherit that interface with the  @Serializable \nannotation, the driver uses a  KSerializer  implementation to handle\nconversion of your types to and from BSON. When you insert an instance of a polymorphic data class into MongoDB,\nthe driver adds the field  _t , the\ndiscriminator field. The value of this field is the data class name. The following example creates an interface and two data classes that\ninherit that interface. In the data classes, the  id  field is marked\nwith the annotations described in the\n Annotate Data Classes  section: Then, you can perform operations with data classes as usual. The\nfollowing example parametrizes the collection with the  Person \ninterface, then performs operations with the polymorphic classes\n Teacher  and  Student . When you retrieve documents, the driver\nautomatically detects the type based on the discriminator value and\ndeserializes them accordingly.",
      "code": [
        {
          "lang": "kotlin",
          "value": "implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-core:1.5.1\")\nimplementation(\"org.mongodb:bson-kotlinx:5.1.2\")"
        },
        {
          "lang": "kotlin",
          "value": "<dependency>\n    <groupId>org.jetbrains.kotlinx</groupId>\n    <artifactId>kotlinx-serialization-core</artifactId>\n    <version>1.5.1</version>\n</dependency>\n<dependency>\n    <groupId>org.mongodb</groupId>\n    <artifactId>bson-kotlinx</artifactId>\n    <version>5.1.2</version>\n</dependency>"
        },
        {
          "lang": "kotlin",
          "value": "@Serializable\ndata class PaintOrder(\n    @SerialName(\"_id\") // Use instead of @BsonId\n    @Contextual val id: ObjectId?,\n    val color: String,\n    val qty: Int,\n    @SerialName(\"brand\")\n    val manufacturer: String = \"Acme\" // Use instead of @BsonProperty\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "object InstantAsBsonDateTime : KSerializer<Instant> {\n    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor(\"InstantAsBsonDateTime\", PrimitiveKind.LONG)\n\n    override fun serialize(encoder: Encoder, value: Instant) {\n        when (encoder) {\n            is BsonEncoder -> encoder.encodeBsonValue(BsonDateTime(value.toEpochMilliseconds()))\n            else -> throw SerializationException(\"Instant is not supported by ${encoder::class}\")\n        }\n    }\n\n    override fun deserialize(decoder: Decoder): Instant {\n        return when (decoder) {\n            is BsonDecoder -> Instant.fromEpochMilliseconds(decoder.decodeBsonValue().asDateTime().value)\n            else -> throw SerializationException(\"Instant is not supported by ${decoder::class}\")\n        }\n    }\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "@Serializable\ndata class PaintOrder(\n    val color: String,\n    val qty: Int,\n    @Serializable(with = InstantAsBsonDateTime::class)\n    val orderDate: Instant,\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "implementation(\"org.mongodb:bson-kotlinx:5.1.2\")"
        },
        {
          "lang": "kotlin",
          "value": "<dependency>\n    <groupId>org.jetbrains.kotlinx</groupId>\n    <artifactId>bson-kotlinx</artifactId>\n    <version>5.1.2</version>\n</dependency>"
        },
        {
          "lang": "kotlin\n :copyable: true",
          "value": "import org.bson.codecs.configuration.CodecRegistries\nimport org.bson.codecs.kotlinx.BsonConfiguration\nimport org.bson.codecs.kotlinx.KotlinSerializerCodec"
        },
        {
          "lang": "kotlin",
          "value": "val myCustomCodec = KotlinSerializerCodec.create<PaintOrder>(\n    bsonConfiguration = BsonConfiguration(encodeDefaults = false)\n)\n\nval registry = CodecRegistries.fromRegistries(\n    CodecRegistries.fromCodecs(myCustomCodec), collection.codecRegistry\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "@Serializable\nsealed interface Person {\n    val name: String\n}\n\n@Serializable\ndata class Student(\n    @Contextual\n    @SerialName(\"_id\")\n    val id: ObjectId,\n    override val name: String,\n    val grade: Int,\n) : Person\n\n@Serializable\ndata class Teacher(\n    @Contextual\n    @SerialName(\"_id\")\n    val id: ObjectId,\n    override val name: String,\n    val department: String,\n) : Person\n"
        },
        {
          "lang": "kotlin",
          "value": "val collection = database.getCollection<Person>(\"school\")\n\nval teacherDoc = Teacher(ObjectId(), \"Vivian Lee\", \"History\")\nval studentDoc = Student(ObjectId(), \"Kate Parker\", 10)\n\ncollection.insertOne(teacherDoc)\ncollection.insertOne(studentDoc)\n\nprintln(\"Retrieving by using data classes\")\ncollection.withDocumentClass<Teacher>()\n    .find(Filters.exists(\"department\"))\n    .first().also { println(it) }\n\ncollection.withDocumentClass<Student>()\n    .find(Filters.exists(\"grade\"))\n    .first().also { println(it) }\n\nprintln(\"\\nRetrieving by using Person interface\")\nval resultsFlow = collection.withDocumentClass<Person>().find()\nresultsFlow.collect { println(it) }\n\nprintln(\"\\nRetrieving as Document type\")\nval resultsDocFlow = collection.withDocumentClass<Document>().find()\nresultsDocFlow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Retrieving by using data classes\nTeacher(id=..., name=Vivian Lee, department=History)\nStudent(id=..., name=Kate Parker, grade=10)\n\nRetrieving by using Person interface\nTeacher(id=..., name=Vivian Lee, department=History)\nStudent(id=..., name=Kate Parker, grade=10)\n\nRetrieving as Document type\nDocument{{_id=..., _t=Teacher, name=Vivian Lee, department=History}}\nDocument{{_id=..., _t=Student, name=Kate Parker, grade=10}}"
        }
      ],
      "preview": "The Kotlin driver supports the kotlinx.serialization library for\nserializing and deserializing Kotlin objects.",
      "tags": "code example, data model, conversion, polymorphism",
      "facets": {
        "genre": ["reference"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/data-formats",
      "title": "Data Formats",
      "headings": [],
      "paragraphs": "Document Data Format: Data Classes Document Data Format: BSON Document Data Format: Extended JSON Documents Kotlin Serialization Codecs",
      "code": [],
      "preview": null,
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/databases-collections",
      "title": "Databases and Collections",
      "headings": [
        "Overview",
        "Access a Database",
        "Access a Collection",
        "Specify Return Type",
        "Create a Collection",
        "Document Validation",
        "Get a List of Collections",
        "Drop a Collection",
        "Specify Read Preferences, Read Concerns, and  Write Concerns"
      ],
      "paragraphs": "In this guide, you can learn how to use MongoDB databases and\ncollections with the MongoDB Kotlin driver. MongoDB organizes data into a hierarchy of the following levels: With the MongoDB Kotlin driver, you can model data by using Kotlin data\nclasses or by using the  Document  class to store and\nretrieve data from MongoDB. To learn more about using data classes, see\nthe guide on the  Data Class Data Format . To learn more about using the  Document \nclass, see the guide on the  Document Data Format . Databases : Databases are the top level of data organization in a MongoDB instance. Collections : Databases are organized into collections which contain  documents . Documents : Documents contain literal data such as strings, numbers, and dates, as well as other embedded documents. For more information on document field types and structure, see the  Server documentation on documents . Use the  getDatabase()  method of\na  MongoClient  instance to access a  MongoDatabase  in a MongoDB\ninstance. The following example accesses a database named  testDatabase : Use the  getCollection() \nmethod of a  MongoDatabase  instance to access a\n MongoCollection  in a database of your connected MongoDB instance. The following example accesses a collection named  testCollection  from a\n MongoDatabase  that contains documents of type  ExampleDataClass : If the provided collection name does not already exist in the database,\nMongoDB implicitly creates the collection when you first insert data\ninto that collection. The driver provides a way for you to specify a class for documents\nreturned from a collection, even if it is different than the class you\nspecified when retrieving the collection. You can specify a return class\nby using the  MongoCollection.withDocumentClass() \nmethod. Specifying a different return class could be useful in the following\nsituations: The following example retrieves a collection that\ncontains data represented by the  Fruit  data class but returns the result\nof a  findOneAndUpdate()  operation as an instance of the  NewFruit \nclass. The operation changes the name of the  qty  field to\n quantity  and adds an item to the  seasons  array field in the\ndocument with a  name  value of  \"strawberry\" : Your collection contains multiple data types. You specify a projection that changes your data fields. You cannot directly specify a return type on a method that changes the data,\nsuch as  findOneAndUpdate()  or  findOneAndReplace() . Use the  createCollection() \nmethod of a  MongoDatabase  instance to create a collection\nin a database of your connected MongoDB instance. The following example creates a collection called  exampleCollection : You can specify collection options like maximum size and document\nvalidation rules using the  CreateCollectionOptions \nclass. The  createCollection()  method accepts an instance of\n CreateCollectionOptions  as an optional second parameter. Document validation  provides the ability to validate documents\nagainst a series of filters during writes to a collection. You can\nspecify these filters using the  ValidationOptions \nclass, which accepts a series of  Filters  instances\nthat specify the validation rules and expressions: For more information, see the server documentation for  document\nvalidation . You can query for a list of collections in a database using the\n MongoDatabase.listCollectionNames()  method: You can remove a collection from the database using the\n MongoCollection.drop()  method: Dropping a collection from your database also permanently deletes all\ndocuments within that collection and all indexes on that collection.\nOnly drop collections that contain data that is no longer needed. Read preferences ,  read concerns , and  write concerns  control\nhow the driver routes read operations and waits for acknowledgment for\nread and write operations when connected to a MongoDB replica set.\nRead preferences and read concerns apply to all read operations;\nwrite concerns apply to all write operations. MongoDatabase  instances inherit their write concern, read concern,\nand write preference settings from the  MongoClient  used to create\nthem.  MongoCollection  instances inherit their write concern, read concern,\nand write preference settings from the  MongoDatabase  used to create\nthem. However, you can use the following methods to obtain an instance\nof a  MongoDatabase  or  MongoCollection  with a read preference,\nread concern, or write concern that differs from the setting they would\nnormally inherit: For more information on these topics, see the following pages in the\nServer manual: MongoDatabase.withReadConcern() MongoDatabase.withReadPreference() MongoDatabase.withWriteConcern() MongoCollection.withReadConcern() MongoCollection.withReadPreference() MongoCollection.withWriteConcern() The  withReadConcern() ,  withReadPreference() , and\n withWriteConcern  methods create a new instance of a\n MongoDatabase  or  MongoCollection  with the desired preference\nor concern. The  MongoDatabase  or  MongoCollection  upon which\nthe method is called retains its original preference and concern\nsettings. Read Preference Read Concern Write Concern",
      "code": [
        {
          "lang": "kotlin",
          "value": "val database = client.getDatabase(\"testDatabase\")\n"
        },
        {
          "lang": "kotlin",
          "value": "data class ExampleDataClass(\n    @BsonId val id: ObjectId = ObjectId(),\n    val exampleProperty: String,\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val collection = database.getCollection<ExampleDataClass>(\"testCollection\")\n"
        },
        {
          "lang": "kotlin",
          "value": "data class Fruit(\n    @BsonId val id: Int,\n    val name: String,\n    val qty: Int,\n    val seasons: List<String>\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val collection =\n    database.getCollection<Fruit>(\"fruits\")\n\n// Define a data class for returned documents\ndata class NewFruit(\n    @BsonId val id: Int,\n    val name: String,\n    val quantity: Int,\n    val seasons: List<String>\n)\n\nval filter = Filters.eq(Fruit::name.name, \"strawberry\")\nval update = Updates.combine(\n    Updates.rename(Fruit::qty.name, \"quantity\"),\n    Updates.push(Fruit::seasons.name, \"fall\"),\n)\nval options = FindOneAndUpdateOptions()\n    .returnDocument(ReturnDocument.AFTER)\n\n// Specify the class for returned documents as the type parameter in withDocumentClass()\nval result = collection\n    .withDocumentClass<NewFruit>()\n    .findOneAndUpdate(filter, update, options)\nprintln(result)\n"
        },
        {
          "lang": "console",
          "value": "NewFruit(id=1, name=strawberry, quantity=205, seasons=[summer, fall])"
        },
        {
          "lang": "kotlin",
          "value": "database.createCollection(\"exampleCollection\")\n"
        },
        {
          "lang": "kotlin",
          "value": "val collOptions: ValidationOptions = ValidationOptions().validator(\n    Filters.or(\n        Filters.exists(\"title\"),\n        Filters.exists(\"name\")\n    )\n)\ndatabase.createCollection(\n    \"movies\",\n    CreateCollectionOptions().validationOptions(collOptions)\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val collectionList = database.listCollectionNames().toList()\n\nprintln(collectionList)\n"
        },
        {
          "lang": "console",
          "value": "[movies, exampleCollection]"
        },
        {
          "lang": "kotlin",
          "value": "val collection =\n    database.getCollection<ExampleDataClass>(\"movies\")\ncollection.drop()\n"
        }
      ],
      "preview": "In this guide, you can learn how to use MongoDB databases and\ncollections with the MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/encrypt-fields",
      "title": "In-Use Encryption",
      "headings": [
        "Overview",
        "Queryable Encryption",
        "Client-side Field Level Encryption"
      ],
      "paragraphs": "You can use the Kotlin driver to encrypt specific document fields by using a\nset of features called  in-use encryption . In-use encryption allows\nyour application to encrypt data  before  sending it to MongoDB\nand query documents with encrypted fields. In-use encryption prevents unauthorized users from viewing plaintext\ndata as it is sent to MongoDB or while it is in an encrypted database. To\nenable in-use encryption in an application and authorize it to decrypt\ndata, you must create encryption keys that only your application can\naccess. Only applications that have access to your encryption\nkeys can access the decrypted, plaintext data. If an attacker gains\naccess to the database, they can only see the encrypted ciphertext data\nbecause they lack access to the encryption keys. You might use in-use encryption to encrypt fields in your MongoDB\ndocuments that contain the following types of sensitive data: MongoDB offers the following features to enable in-use encryption: Credit card numbers Addresses Health information Financial information Any other sensitive or personally identifiable information (PII) Queryable Encryption Client-side Field Level Encryption Queryable Encryption is the next-generation in-use encryption feature,\nfirst introduced as a preview feature in MongoDB Server version 6.0 and\nas a generally available (GA) feature in MongoDB 7.0. Queryable\nEncryption supports searching encrypted fields for equality and encrypts\neach value uniquely. To learn more about Queryable Encryption, see  Queryable\nEncryption  in the Server manual. The implementation of Queryable Encryption in MongoDB 6.0 is incompatible with the GA version introduced in MongoDB 7.0. The Queryable Encryption preview feature is no longer supported. Client-side Field Level Encryption (CSFLE) was introduced in MongoDB\nServer version 4.2 and supports searching encrypted fields for equality.\nCSFLE differs from Queryable Encryption in that you can select either a\ndeterministic or random encryption algorithm to encrypt fields. You can only\nquery encrypted fields that use a deterministic encryption algorithm when\nusing CSFLE. When you use a random encryption algorithm to encrypt\nfields in CSFLE, they can be decrypted, but you cannot perform equality\nqueries on those fields. When you use Queryable Encryption, you cannot\nspecify the encryption algorithm, but you can query all encrypted\nfields. When you deterministically encrypt a value, the same input value\nproduces the same output value. While deterministic encryption allows\nyou to perform queries on those encrypted fields, encrypted data with\nlow cardinality is susceptible to code breaking by frequency analysis. To learn more about CSFLE, see  CSFLE  in the\nServer manual. To learn more about these concepts, see the following Wikipedia\nentries: Cardinality Frequency Analysis",
      "code": [],
      "preview": "You can use the Kotlin driver to encrypt specific document fields by using a\nset of features called in-use encryption. In-use encryption allows\nyour application to encrypt data before sending it to MongoDB\nand query documents with encrypted fields.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/enterprise-auth",
      "title": "Enterprise Authentication Mechanisms",
      "headings": [
        "Overview",
        "Specify an Authentication Mechanism",
        "Mechanisms",
        "Kerberos (GSSAPI)",
        "LDAP (PLAIN)",
        "MONGODB-OIDC",
        "Azure IMDS",
        "GCP IMDS",
        "Custom Callback"
      ],
      "paragraphs": "In this guide, you can learn how to authenticate with MongoDB using each\n authentication mechanism  available exclusively in the MongoDB Enterprise\nEdition. You can use the following mechanisms with the latest version of MongoDB\nEnterprise Edition: Authentication Mechanisms guide . For more\ninformation on establishing a connection to your MongoDB cluster, read our\n Connection Guide . Kerberos (GSSAPI) LDAP (PLAIN) MONGODB-OIDC You can specify your authentication mechanism and credentials when connecting\nto MongoDB using either of the following: A  connection string  (also known as a  connection URI ) specifies how to\nconnect and authenticate to your MongoDB cluster. To authenticate using a connection string, include your settings in your\nconnection string and pass it to the  MongoClient.create()  method to\ninstantiate your  MongoClient . The  Connection String \ntab in each section provides the syntax for authenticating using a\n connection string . Alternatively, you can use the  MongoCredential  class to specify your\nauthentication details. The  MongoCredential  class contains static factory\nmethods that construct instances containing your authentication mechanism and\ncredentials. When you use the  MongoCredential  helper class, you need\nto use the  MongoClientSettings.Builder  class to configure your\nconnection settings when constructing your  MongoClient .  The\n MongoCredential  tab in each section provides the syntax for\nauthenticating using a  MongoCredential . For more information on these classes and methods, refer to the following API\ndocumentation: A connection string A  MongoCredential  factory method MongoClient.create() MongoClient MongoClientSettings.Builder MongoCredential The Generic Security Services API ( GSSAPI ) authentication mechanism\nallows the user to authenticate to a Kerberos service using the user's\nprincipal name. The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: In order to acquire a\n Kerberos ticket ,\nthe GSSAPI Java libraries require you to specify the realm and Key Distribution\nCenter (KDC) system properties. See the sample settings in the following example: You may need to specify one or more of the following additional\n MongoCredential  mechanism properties depending on your Kerberos setup: By default, the Kotlin driver caches Kerberos tickets by  MongoClient  instance.\nIf your deployment needs to frequently create and destroy  MongoClient  instances,\nyou can change the default Kerberos ticket caching behavior to cache by process\nto improve performance. The method refers to the  GSSAPI  authentication mechanism instead\nof  Kerberos  because the driver authenticates using the\n GSSAPI RFC-4652   SASL\nmechanism. Kerberos principal  - your URL-encoded principal name, e.g. \"username%40REALM.ME\" hostname  - network address of your MongoDB server, accessible by your client port  - port number of your MongoDB server To specify the GSSAPI authentication mechanism using a connection\nstring: Your code to instantiate a  MongoClient  should resemble the following: Assign the  authMechanism  URL parameter to the value  GSSAPI (optional)  Assign the  authSource  URL parameter to the value  $external If you specify the  GSSAPI  mechanism, you cannot assign\n authSource  to any value other than  $external . To specify the GSSAPI authentication mechanism using the\n MongoCredential  class, use the  createGSSAPICredential() \nmethod. Your code to instantiate a  MongoClient  should resemble the following: SERVICE_NAME CANONICALIZE_HOST_NAME JAVA_SUBJECT JAVA_SASL_CLIENT_PROPERTIES JAVA_SUBJECT_PROVIDER To specify one of the GSSAPI additional properties, include it in the\nconnection string as a URL parameter using the format:\n <PROPERTY_NAME>:<value> . Your code to instantiate a  MongoClient  using GSSAPI and additional\nproperties might resemble the following: You can only specify the following GSSAPI properties using the\n MongoCredential : Select the  MongoCredential  tab to see how to specify\nthem. JAVA_SUBJECT JAVA_SASL_CLIENT_PROPERTIES JAVA_SUBJECT_PROVIDER To specify one of the GSSAPI additional properties, call the\n withMechanismProperty()  method on your  MongoCredential \ninstance and pass the property name and value as parameters. Use the\nproperty name constants defined in the  MongoCredential  class: Select the  SERVICE_NAME_KEY  or  JAVA_SUBJECT_KEY  tab to\nsee sample code to instantiate a  MongoCredential  that uses GSSAPI and\nthe selected property: SERVICE_NAME_KEY CANONICALIZE_HOST_NAME_KEY JAVA_SUBJECT_KEY JAVA_SASL_CLIENT_PROPERTIES_KEY JAVA_SUBJECT_PROVIDER_KEY To cache Kerberos tickets by process, you must use the  MongoCredential  authentication\nmechanism, as the connection string authentication mechanism does not support the  JAVA_SUBJECT_PROVIDER \nmechanism property. If you would like to cache Kerberos tickets by process, select the  MongoCredential \ntab to learn how to accomplish this. To cache Kerberos tickets by process, you must specify the  JAVA_SUBJECT_PROVIDER \nmechanism property and provide a\n KerberosSubjectProvider \nin your  MongoCredential  instance. The code to configure the Kotlin driver to cache Kerberos tickets\nby process should resemble the following: On Windows, Oracle\u2019s JRE uses  LSA \nrather than  SSPI \nin its implementation of GSSAPI which limits interoperability with\nWindows Active Directory and implementations of single sign-on. See the\nfollowing articles for more information: JDK-8054026 JDK-6722928 SO 23427343 Available in MongoDB Enterprise Edition 3.4 and later. You can authenticate to a Lightweight Directory Access Protocol (LDAP)\nserver using your directory server username and password. You can specify this authentication mechanism by setting the  authMechanism \nparameter to  PLAIN  and including your LDAP username and password in the\n connection string . The following code snippets show how to specify the authentication mechanism,\nusing the following placeholders: Select the  Connection String  or the  MongoCredential \ntab below for instructions and sample code for specifying this authentication\nmechanism: The authentication mechanism is named  PLAIN  instead of  LDAP  since it\nauthenticates using the  PLAIN Simple Authentication and Security Layer\n(SASL) defined in RFC-4616 . LDAP username  - your LDAP username password  - your LDAP user's password hostname  - network address of your MongoDB server, accessible by your client port  - port number of your MongoDB server To specify the LDAP (PLAIN) authentication mechanism using a connection\nstring: Your code to instantiate a  MongoClient  should resemble the following: Assign the  authMechanism  URL parameter to the value  PLAIN (optional)  Assign the  authSource  URL parameter to the value  $external If you specify the  PLAIN  mechanism, you cannot assign\n authSource  to any value other than  $external . To specify the LDAP (PLAIN) authentication mechanism using the\n MongoCredential  class, use the  createPlainCredential() \nmethod. Your code to instantiate a  MongoClient  should resemble the following: The following sections describe how to use the MONGODB-OIDC\nauthentication mechanism to authenticate to various platforms. For more information about the MONGODB-OIDC authentication mechanism, see\n OpenID Connect Authentication  and\n MongoDB Server Parameters \nin the MongoDB Server manual. The MONGODB-OIDC authentication mechanism requires MongoDB server v7.0 or later running\non a Linux platform. If your application runs on an Azure VM, or otherwise uses the\n Azure Instance Metadata Service \n(IMDS), you can authenticate to MongoDB by using the Kotlin driver's built-in Azure\nsupport. You can specify Azure IMDS OIDC authentication either by\nusing a  MongoCredential  instance or by specifying your credentials\nin the connection string. Select from the  Connection String  or  MongoCredential  tabs to\nsee the corresponding syntax. Replace the  <percent-encoded audience>  placeholder in the\nfollowing code with the percent-encoded value of the audience server\nparameter configured on your MongoDB deployment. The comma ( , ) character and its encoding ( %2C ) are\nreserved, and using these characters in a value causes the\ndriver to interpret commas as delimiters of key-value pairs.\nYou must specify values that contain commas in a  MongoCredential  instance, as\ndemonstrated in the  MongoCredential  tab. Replace the  <OIDC principal>  placeholder with the client ID or application ID of the\nAzure managed identity or enterprise application. Replace the  <audience> \nplaceholder with the value of the\n audience  server parameter configured on your MongoDB deployment. If your application runs on a Google Compute Engine VM, or otherwise uses the\n GCP Instance Metadata Service ,\nyou can authenticate to MongoDB by using the Kotlin driver's built-in GCP\nsupport. You can specify GCP IMDS OIDC authentication either by\nusing a  MongoCredential  instance or by specifying your credentials\nin the connection string. Select from the  Connection String  or  MongoCredential  tabs to\nsee the corresponding syntax. Replace the  <percent-encoded audience>  placeholder in the\nfollowing code with the percent-encoded value of the audience server\nparameter configured on your MongoDB deployment. The comma ( , ) character and its encoding ( %2C ) are\nreserved, and using these characters in a value causes the\ndriver to interpret commas as delimiters of key-value pairs.\nYou must specify values that contain commas in a  MongoCredential  instance, as\ndemonstrated in the  MongoCredential  tab. Replace the  <audience>  placeholder with the value of the\n audience  server parameter configured on your MongoDB deployment. The Kotlin driver doesn't offer built-in support for all platforms, including\nAzure Functions and Azure Kubernetes Service (AKS). Instead, you\nmust define a custom callback to use OIDC to authenticate from these platforms.\nTo do so, use the  \"OIDC_CALLBACK\"  authentication property, as shown in the following\ncode example: The value of the  \"OIDC_CALLBACK\"  property must be a lambda or other implementation\nof the  OidcCallback  functional interface that accepts an  OidcCallbackContext \nas a parameter and returns an  OidcCallbackResult . The following example uses an example callback to retrieve an OIDC token from a file\nnamed  \"access-token.dat\"  in the local file system:",
      "code": [
        {
          "lang": "none",
          "value": "java.security.krb5.realm=MYREALM.ME\njava.security.krb5.kdc=mykdc.myrealm.me"
        },
        {
          "lang": "kotlin",
          "value": "val connectionString = ConnectionString(\"<Kerberos principal>@<hostname>:<port>/?authSource=$external&authMechanism=GSSAPI\")\nval mongoClient = MongoClient.create(connectionString)\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createGSSAPICredential(\"<Kerberos principal>\")\n\nval settings = MongoClientSettings.builder()\n        .applyToClusterSettings { builder ->\n            builder.hosts(listOf(ServerAddress(\"<hostname>\", <port>)))\n        }\n        .credential(credential)\n        .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val connectionString = ConnectionString(\"<Kerberos principal>@<hostname>:<port>/?authSource=$external&authMechanism=GSSAPI&authMechanismProperties=SERVICE_NAME:myService\")\nval mongoClient = MongoClient.create(connectionString)\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createGSSAPICredential(\"<Kerberos principal>\")\n    .withMechanismProperty(MongoCredential.SERVICE_NAME_KEY, \"myService\")\n"
        },
        {
          "lang": "kotlin",
          "value": "val loginContext = LoginContext(\"<LoginModule implementation from JAAS config>\")\nloginContext.login()\nval subject: Subject = loginContext.subject\n\nval credential = MongoCredential.createGSSAPICredential(\"<Kerberos principal>\")\n    .withMechanismProperty(MongoCredential.JAVA_SUBJECT_KEY, subject)\n"
        },
        {
          "lang": "kotlin",
          "value": "/* All MongoClient instances sharing this instance of KerberosSubjectProvider\nwill share a Kerberos ticket cache */\nval myLoginContext = \"myContext\"\n/* Login context defaults to \"com.sun.security.jgss.krb5.initiate\"\nif unspecified in KerberosSubjectProvider */\nval credential = MongoCredential.createGSSAPICredential(\"<Kerberos principal>\")\n    .withMechanismProperty(\n        MongoCredential.JAVA_SUBJECT_PROVIDER_KEY,\n        KerberosSubjectProvider(myLoginContext)\n    )\n"
        },
        {
          "lang": "kotlin",
          "value": "val connectionString = ConnectionString(\"<LDAP username>:<password>@<hostname>:<port>/?authSource=$external&authMechanism=PLAIN\")\nval mongoClient = MongoClient.create(connectionString)\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createPlainCredential(\"<LDAP username>\", \"$external\", \"<password>\".toCharArray())\n\nval settings = MongoClientSettings.builder()\n    .applyToClusterSettings { builder ->\n        builder.hosts(listOf(ServerAddress(\"<hostname>\", <port>)))\n    }\n    .credential(credential)\n    .build()\n\nval mongoClient = MongoClient.create(settings)\n"
        },
        {
          "lang": "kotlin",
          "value": "val connectionString = ConnectionString(\n    \"mongodb://<OIDC principal>@<hostname>:<port>/?\" +\n        \"?authMechanism=MONGODB-OIDC\" +\n        \"&authMechanismProperties=ENVIRONMENT:azure,TOKEN_RESOURCE:<percent-encoded audience>\")\nval mongoClient = MongoClient.create(connectionString)\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createOidcCredential(\"<OIDC principal>\")\n    .withMechanismProperty(\"ENVIRONMENT\", \"azure\")\n    .withMechanismProperty(\"TOKEN_RESOURCE\", \"<audience>\")\n\nval mongoClient = MongoClient.create(\n        MongoClientSettings.builder()\n            .applyToClusterSettings { builder ->\n                builder.hosts(listOf(ServerAddress(\"<hostname>\", <port>)))\n            }\n        .credential(credential)\n        .build())\n"
        },
        {
          "lang": "kotlin",
          "value": "val connectionString = ConnectionString(\n    \"mongodb://<OIDC principal>@<hostname>:<port>/?\" +\n            \"authMechanism=MONGODB-OIDC\" +\n            \"&authMechanismProperties=ENVIRONMENT:gcp,TOKEN_RESOURCE:<percent-encoded audience>\")\nval mongoClient = MongoClient.create(connectionString)\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createOidcCredential(\"<OIDC principal>\")\n    .withMechanismProperty(\"ENVIRONMENT\", \"gcp\")\n    .withMechanismProperty(\"TOKEN_RESOURCE\", \"<audience>\")\n\nval mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyToClusterSettings { builder ->\n            builder.hosts(listOf(ServerAddress(\"<hostname>\", <port>)))\n        }\n        .credential(credential)\n        .build())\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createOidcCredential(null)\n    .withMechanismProperty(\"OIDC_CALLBACK\") { context: Context ->\n        val accessToken = \"...\"\n        OidcCallbackResult(accessToken)\n    }\n"
        },
        {
          "lang": "kotlin",
          "value": "val credential = MongoCredential.createOidcCredential(null)\n    .withMechanismProperty(\"OIDC_CALLBACK\") { context: Context ->\n        val accessToken = String(Files.readAllBytes(Paths.get(\"access-token.dat\")))\n        OidcCallbackResult(accessToken)\n    }\n\nval mongoClient = MongoClient.create(\n    MongoClientSettings.builder()\n        .applyToClusterSettings { builder ->\n            builder.hosts(listOf(ServerAddress(\"<hostname>\", <port>)))\n        }\n        .credential(credential)\n        .build()\n)\n"
        }
      ],
      "preview": "In this guide, you can learn how to authenticate with MongoDB using each\nauthentication mechanism available exclusively in the MongoDB Enterprise\nEdition.",
      "tags": "ldap, encryption, principal, tls",
      "facets": {
        "genre": ["reference"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/indexes",
      "title": "Indexes",
      "headings": [
        "Overview",
        "Query Coverage and Performance",
        "Operational Considerations",
        "Index Types",
        "Single Field and Compound Indexes",
        "Single Field Indexes",
        "Compound Indexes",
        "Multikey Indexes (Indexes on Array Fields)",
        "Atlas Search and Vector Search Indexes",
        "Create a Search Index",
        "List Search Indexes",
        "Update a Search Index",
        "Drop a Search Index",
        "Text Indexes",
        "Single Field",
        "Multiple Fields",
        "Geospatial Indexes",
        "Unique Indexes",
        "Clustered Indexes",
        "Remove an Index",
        "Remove an Index Using an Index Specification Document",
        "Remove an Index Using a Name Field",
        "Remove an Index Using a Wildcard Character"
      ],
      "paragraphs": "In this guide, you can learn how to create and manage  indexes  by\nusing the MongoDB Kotlin Driver. Indexes support the efficient execution of queries in MongoDB. Without\nindexes, MongoDB must scan  every  document in a collection (a\n collection scan ) to find the documents that match each query. These\ncollection scans are slow and can negatively affect the performance of\nyour application. If an appropriate index exists for a query, MongoDB\ncan use the index to limit the documents that the query must inspect. Indexes also have the following benefits: To learn more, see  Indexes  in the Server manual. Indexes allow efficient sorting. Indexes enable special capabilities such as  geospatial queries . Indexes allow the creation of constraints to ensure a field value is  unique . Update operations use indexes when finding documents to update, and\ndelete operations use indexes when finding documents to delete.\n Certain stages  in\nthe aggregation pipeline also use indexes to improve performance. When you execute a query against MongoDB, your command can include various elements: When all the fields specified in the query, projection, and sort are in the same index, MongoDB returns results directly\nfrom the index, also called a  covered query . For more information on how to ensure your index covers your query criteria and projection, see the Server manual\narticles on  query coverage . Query criteria that specify fields and values you are looking for Options that affect the query's execution, such as the read concern Projection criteria to specify the fields MongoDB returns (optional) Sort criteria to specify the order of documents returned from MongoDB (optional) Sort criteria must match or invert the order of the index. Consider an index on the field  name  in ascending order (A-Z) and  age  in descending order (9-0): MongoDB uses this index when you sort your data in either of the\nfollowing ways: Specifying a sort order of  name  and  age  ascending or  name  and  age \ndescending requires an in-memory sort. name  ascending,  age  descending name  descending,  age  ascending The following guidelines describe how you can optimize the way\nyour application uses indexes: Since MongoDB supports dynamic schemas, applications can query against fields whose names cannot be known in advance or\nare arbitrary. MongoDB 4.2 introduced  wildcard indexes  to help support these queries.\nWildcard indexes are not designed to replace workload-based index planning. For more information on designing your data model and choosing indexes appropriate for your application, see the MongoDB\nserver documentation on  Indexing Strategies  and\n Data Modeling and Indexes . To improve query performance, build indexes on fields that appear often in\nyour application's queries and operations that return sorted results. Track index memory and disk usage for capacity planning, because each\nindex that you add consumes disk space and memory when active. Avoid adding indexes that you infrequently use. Note that when a write\noperation updates an indexed field, MongoDB updates the related index. MongoDB supports several different index types to support querying your data. The following sections describe the\nmost common index types and provide sample code for creating each index type. For a full list of index types, see\n Indexes  in the Server manual. The following examples use the\n createIndex() \nmethod to create various indexes, and the following data classes to model data\nin MongoDB: The Kotlin driver provides the  Indexes \nclass to create and manage indexes. This class includes static\nfactory methods to create index specification documents for different\nMongoDB index key types. Single field indexes  are indexes with a reference to a single field within a collection's\ndocuments. They improve single field query and sort performance, and support  TTL Indexes  that\nautomatically remove documents from a collection after a certain amount of time or at a specific clock time. The following example creates an index in ascending order on the  title  field: The following is an example of a query that is covered by the index\ncreated in the preceding code snippet: See the MongoDB server manual section on  single field indexes  for more information. The  _id_  index is an example of a single field index. This index is automatically created on the  _id  field\nwhen a new collection is created. Compound  indexes hold references to multiple fields within a collection's documents,\nimproving query and sort performance. The following example creates a compound index on the  type  and  rated  fields: The following is an example of a query that is covered by the index\ncreated in the preceding code snippet: See the MongoDB server manual section on  Compound indexes  for more information. Read more about compound indexes,  index prefixes , and sort order  here . Multikey indexes  are indexes that improve performance for queries that specify a field with an index that contains\nan array value. You can define a multikey index using the same syntax as a single field or compound index. The following example creates a compound, multikey index on the  rated ,  genres  (an array of\nStrings), and  title  fields: The following is an example of a query that is covered by the index\ncreated in the preceding code snippet: Multikey indexes behave differently from other indexes in terms of query coverage, index-bound computation, and\nsort behavior. To learn more about multikey indexes, including a discussion of their behavior and limitations,\nsee  Multikey Indexes  in the Server manual. You can programmatically manage your Atlas Search and Atlas Vector\nSearch indexes by using the Kotlin driver. The Atlas Search feature enables you to perform full-text searches on\ncollections hosted on MongoDB Atlas. To learn more about MongoDB Atlas\nSearch, see the  Atlas Search Indexes  documentation. Atlas Vector Search enables you to perform semantic searches on vector\nembeddings stored in MongoDB Atlas. To learn more about Atlas Vector Search, see the\n Atlas Vector Search  section in the Aggregates Builder guide. You can call the following methods on a collection to manage your Atlas\nSearch and Vector Search indexes: The following sections provide code examples that demonstrate how to use\neach of the preceding methods. createSearchIndex() createSearchIndexes() listSearchIndexes() updateSearchIndex() dropSearchIndex() The Atlas Search index-management methods run asynchronously. The\ndriver methods can return before confirming that they ran\nsuccessfully. To determine the current status of the indexes, call the\n listSearchIndexes()  method. You can use the  createSearchIndex() \nand  createSearchIndexes() \nmethods to create Atlas Search and Vector Search indexes on a\ncollection. The following code example shows how to create an Atlas Search index: The following code example shows how to create Search and\nVector Search indexes in one call: You can use the\n listSearchIndexes() \nmethod to return a list of the Atlas Search indexes on a collection. The following code example shows how to print a list of the search indexes on\na collection: You can use the\n updateSearchIndex() \nmethod to update an Atlas Search index. The following code shows how to update a search index: You can use the\n dropSearchIndex() \nmethod to remove an Atlas Search index. The following code shows how to delete a search index from a collection: Text indexes  support text search queries on string content. These indexes can include any field whose value is a\nstring or an array of string elements. MongoDB supports text search for various languages. You can specify the default\nlanguage as an option when creating the index. MongoDB offers an improved full-text search solution,\n Atlas Search . To learn more about Atlas Search\nindexes and how to use them, see the  Atlas Search and Vector Search Indexes  section of this\nguide. The following example creates a text index on the  plot  field: The following is an example of a query that is covered by the index\ncreated in the preceding code snippet. Note that the  sort  is\nomitted because text indexes do not contain sort order. A collection can only contain one text index. If you want to create a\ntext index for multiple text fields, you must create a compound\nindex. A text search runs on all the text fields within the compound\nindex. The following snippet creates a compound text index for the  title  and  genre \nfields: For more information, see the following Server Manual Entries: Compound Text Index Restrictions Text Indexes MongoDB supports queries of geospatial coordinate data using  2dsphere indexes . With a  2dsphere  index, you can query\nthe geospatial data for inclusion, intersection, and proximity. For more information on querying geospatial data, see\n Geospatial Queries  in the Server manual. To create a  2dsphere  index, you must specify a field that contains\nonly  GeoJSON objects . To learn more about this type, see\n GeoJSON objects  in the Server manual. The  location.geo  field in the following sample document from the  theaters  collection in the  sample_mflix \ndatabase is a GeoJSON Point object that describes the coordinates of the theater: The following example creates a  2dsphere  index on the  location.geo  field: The following is an example of a geospatial query that is covered by the index\ncreated in the preceding code snippet: MongoDB also supports  2d  indexes for calculating distances on a\nEuclidean plane and for working with the \"legacy coordinate pairs\"\nsyntax used in MongoDB 2.2 and earlier. To learn more, see\n Geospatial Queries  in the Server manual. Attempting to create a geospatial index on a field that is already\ncovered by a geospatial index results in an error. Unique indexes ensure that the indexed fields do not store duplicate values. By default, MongoDB creates a unique index\non the  _id  field during the creation of a collection. To create a unique index, specify the field or combination of\nfields that you want to prevent duplication on and set the  unique  option to  true . The following example creates a unique, descending index on the  theaterId  field: Refer to the  Unique Indexes page  in the MongoDB server manual for more information. If you perform a write operation that stores a duplicate value that\nviolates the unique index, the driver raises a  DuplicateKeyException ,\nand MongoDB throws an error resembling the following: Clustered indexes  instruct a collection to store documents ordered\nby a key value. To create a clustered index, specify the clustered index\noption with the  _id  field as the key and the unique field as\n true  when you create your collection. The following example creates a clustered index on the  _id  field in\nthe  vendors  collection: See the MongoDB server manual sections for more information: Clustered Index Clustered Collections You can remove any unused index except the default unique index on the\n _id  field. The following sections show the ways to remove indexes: Using an index specification document Using an indexed name field Using a wildcard character to remove all indexes Pass an  index specification document  to the  dropIndex()  method to\nremove an index from a collection. An index specification document is\na  Bson  instance that specifies the type of index on a\nspecified field. The following snippet removes an ascending index on the  title  field\nin a collection: If you want to drop a text index, you must use the name of the index\ninstead. See the  Remove an Index Using a Name Field  section for details. Pass the  name  field of the index to the  dropIndex()  method to\nremove an index from a collection. If you must find the name of your index, use the  listIndexes() \nmethod to see the value of the  name  fields in your indexes. The following snippet retrieves and prints all the indexes in a\ncollection: If you call  listIndex()  on a collection that contains a text index,\nthe output might resemble the following: This output tells us the names of the existing indexes are \"_id\" and\n\"title_text\". The following snippet removes the \"title_text\" index from the collection: You cannot remove a single field from a compound text index. You must\ndrop the entire index and create a new one to update the indexed\nfields. Starting with MongoDB 4.2, you can drop all indexes by calling the\n dropIndexes()  method on your collection: For prior versions of MongoDB, pass \"*\" as a parameter to your call to\n dropIndex()  on your collection: For more information on the methods in this section, see the following API Documentation: dropIndex() dropIndexes()",
      "code": [
        {
          "lang": "none",
          "value": "name_1_age_-1"
        },
        {
          "lang": "kotlin",
          "value": "// Data class for the movies collection\ndata class Movie(\n    val title: String,\n    val year: Int,\n    val cast: List<String>,\n    val genres: List<String>,\n    val type: String,\n    val rated: String,\n    val plot: String,\n    val fullplot: String,\n)\n\n// Data class for the theaters collection\ndata class Theater(\n    val theaterId: Int,\n    val location: Location\n) {\n    data class Location(\n        val address: Address,\n        val geo: Point\n    ) {\n        data class Address(\n            val street1: String,\n            val city: String,\n            val state: String,\n            val zipcode: String\n        )\n    }\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultCreateIndex = moviesCollection.createIndex(Indexes.ascending(Movie::title.name))\nprintln(\"Index created: $resultCreateIndex\")\n"
        },
        {
          "lang": "console",
          "value": "Index created: title_1"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.eq(Movie::title.name, \"The Dark Knight\")\nval sort = Sorts.ascending(Movie::title.name)\nval projection = Projections.fields(\n    Projections.include(Movie::title.name),\n    Projections.excludeId()\n)\n\ndata class Results(val title: String)\n\nval resultsFlow = moviesCollection.find<Results>(filter).sort(sort).projection(projection)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultCreateIndex = moviesCollection.createIndex(Indexes.ascending(Movie::type.name, Movie::rated.name))\n\nprintln(\"Index created: $resultCreateIndex\")\n"
        },
        {
          "lang": "console",
          "value": "Index created: type_1_rated_1"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.and(\n    Filters.eq(Movie::type.name, \"movie\"),\n    Filters.eq(Movie::rated.name, \"G\")\n)\nval sort = Sorts.ascending(Movie::type.name, Movie::rated.name)\nval projection = Projections.fields(\n    Projections.include(Movie::type.name, Movie::rated.name),\n    Projections.excludeId()\n)\nval resultsFlow = moviesCollection.find(filter).sort(sort).projection(projection)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "kotlin",
          "value": "val resultCreateIndex =\n    moviesCollection.createIndex(Indexes.ascending(Movie::rated.name, Movie::genres.name, Movie::title.name))\n\nprintln(\"Index created: $resultCreateIndex\")\n"
        },
        {
          "lang": "console",
          "value": "Index created: rated_1_genres_1_title_1"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.and(\n    Filters.eq(Movie::genres.name, \"Animation\"),\n    Filters.eq(Movie::rated.name, \"G\")\n)\nval sort = Sorts.ascending(Movie::title.name)\nval projection = Projections.fields(\n    Projections.include(Movie::title.name, Movie::rated.name),\n    Projections.excludeId()\n)\nval resultsFlow = moviesCollection.find(filter).sort(sort).projection(projection)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "kotlin",
          "value": "val searchIdx = Document(\n    \"mappings\",\n    Document(\"dynamic\", true)\n)\nval resultCreateIndex = moviesCollection.createSearchIndex(\"myIndex\", searchIdx)\n"
        },
        {
          "lang": "kotlin",
          "value": "val searchIdxMdl = SearchIndexModel(\n    \"searchIdx\",\n    Document(\"analyzer\", \"lucene.standard\").append(\n        \"mappings\", Document(\"dynamic\", true)\n    ),\n    SearchIndexType.search()\n)\n\nval vectorSearchIdxMdl = SearchIndexModel(\n    \"vsIdx\",\n    Document(\n        \"fields\",\n        listOf(\n            Document(\"type\", \"vector\")\n                .append(\"path\", \"embeddings\")\n                .append(\"numDimensions\", 1536)\n                .append(\"similarity\", \"dotProduct\")\n        )\n    ),\n    SearchIndexType.vectorSearch()\n)\n\nval resultCreateIndexes = moviesCollection.createSearchIndexes(\n    listOf(searchIdxMdl, vectorSearchIdxMdl)\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val searchIndexesList = moviesCollection.listSearchIndexes().toList()\n"
        },
        {
          "lang": "kotlin",
          "value": "moviesCollection.updateSearchIndex(\n    \"myIndex\",\n    Document(\"analyzer\", \"lucene.simple\").append(\n        \"mappings\",\n        Document(\"dynamic\", false)\n            .append(\n                \"fields\",\n                Document(\n                    \"title\",\n                    Document(\"type\", \"string\")\n                )\n            )\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "moviesCollection.dropSearchIndex(\"myIndex\");\n"
        },
        {
          "lang": "kotlin",
          "value": "try {\n    val resultCreateIndex = moviesCollection.createIndex(Indexes.text(Movie::plot.name))\n    println(\"Index created: $resultCreateIndex\")\n} catch (e: MongoCommandException) {\n    if (e.errorCodeName == \"IndexOptionsConflict\") {\n        println(\"there's an existing text index with different options\")\n    }\n}\n"
        },
        {
          "lang": "console",
          "value": "Index created: plot_text"
        },
        {
          "lang": "kotlin",
          "value": "val filter = Filters.text(\"Batman\")\nval projection = Projections.fields(\n    Projections.include(Movie::fullplot.name),\n    Projections.excludeId()\n)\n\ndata class Results(val fullplot: String)\n\nval resultsFlow = moviesCollection.find<Results>(filter).projection(projection)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "kotlin",
          "value": "try {\n    val resultCreateIndex = moviesCollection.createIndex(\n        Indexes.compoundIndex(\n            Indexes.text(Movie::title.name), Indexes.text(Movie::genres.name)\n        )\n    )\n    println(\"Index created: $resultCreateIndex\")\n} catch (e: MongoCommandException) {\n    if (e.errorCodeName == \"IndexOptionsConflict\") {\n        println(\"there's an existing text index with different options\")\n    }\n}\n"
        },
        {
          "lang": "console",
          "value": "Index created: title_text_genre_text"
        },
        {
          "lang": "javascript",
          "value": "{\n   \"_id\" : ObjectId(\"59a47286cfa9a3a73e51e75c\"),\n   \"theaterId\" : 104,\n   \"location\" : {\n      \"address\" : {\n         \"street1\" : \"5000 W 147th St\",\n         \"city\" : \"Hawthorne\",\n         \"state\" : \"CA\",\n         \"zipcode\" : \"90250\"\n      },\n      \"geo\" : {\n         \"type\" : \"Point\",\n         \"coordinates\" : [\n            -118.36559,\n            33.897167\n         ]\n      }\n   }\n}"
        },
        {
          "lang": "kotlin",
          "value": "val resultCreateIndex = theatersCollection.createIndex(\n    Indexes.geo2dsphere(\"${Theater::location.name}.${Theater.Location::geo.name}\")\n)\n\nprintln(\"Index created: $resultCreateIndex\")\n"
        },
        {
          "lang": "console",
          "value": "Index created: location.geo_2dsphere"
        },
        {
          "lang": "kotlin",
          "value": "// MongoDB Headquarters in New York, NY.\nval refPoint = Point(Position(-73.98456, 40.7612))\nval filter = Filters.near(\n    \"${Theater::location.name}.${Theater.Location::geo.name}\",\n    refPoint, 1000.0, 0.0\n)\nval resultsFlow = theatersCollection.find(filter)\n\nresultsFlow.collect { println(it) }\n"
        },
        {
          "lang": "kotlin",
          "value": "try {\n    val indexOptions = IndexOptions().unique(true)\n    val resultCreateIndex = theatersCollection.createIndex(\n        Indexes.descending(Theater::theaterId.name), indexOptions\n    )\n    println(\"Index created: $resultCreateIndex\")\n} catch (e: DuplicateKeyException) {\n    println(\"duplicate field values encountered, couldn't create index: \\t${e.message}\")\n}\n"
        },
        {
          "lang": "console",
          "value": "Index created: theaterId_-1"
        },
        {
          "lang": "none",
          "value": "E11000 duplicate key error index"
        },
        {
          "lang": "kotlin",
          "value": "val clusteredIndexOptions = ClusteredIndexOptions(Document(\"_id\", 1), true)\nval createCollectionOptions = CreateCollectionOptions().clusteredIndexOptions(clusteredIndexOptions)\n\ndatabase.createCollection(\"vendors\", createCollectionOptions)\n"
        },
        {
          "lang": "kotlin",
          "value": "moviesCollection.dropIndex(Indexes.ascending(Movie::title.name));\n"
        },
        {
          "lang": "json",
          "value": "{ \"v\": 2, \"key\": {\"_id\": 1}, \"name\": \"_id_\" }\n{ \"v\": 2, \"key\": {\"_fts\": \"text\", \"_ftsx\": 1}, \"name\": \"title_text\", \"weights\": {\"title\": 1},\n\"default_language\": \"english\", \"language_override\": \"language\", \"textIndexVersion\": 3 }"
        },
        {
          "lang": "kotlin",
          "value": "val indexes = moviesCollection.listIndexes()\n\nindexes.collect { println(it.toJson()) }\n"
        },
        {
          "lang": "kotlin",
          "value": "moviesCollection.dropIndex(\"title_text\")\n"
        },
        {
          "lang": "kotlin",
          "value": "moviesCollection.dropIndexes()\n"
        },
        {
          "lang": "kotlin",
          "value": "moviesCollection.dropIndex(\"*\")\n"
        }
      ],
      "preview": "In this guide, you can learn how to create and manage indexes by\nusing the MongoDB Kotlin Driver.",
      "tags": "code example, optimization, atlas search",
      "facets": {
        "genre": ["reference"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/logging",
      "title": "Logging",
      "headings": [
        "Overview",
        "Set Up a Logger",
        "Background",
        "Example - Set Up",
        "Configure Your Logger",
        "Example - Configure",
        "Logger Names",
        "Example - Names"
      ],
      "paragraphs": "In this guide, you can learn how to set up and configure a logger in the\nMongoDB Kotlin driver. You will learn how to: This guide shows how to record events in the driver.\nIf you would like to learn how to use information about the activity of the\ndriver in code, consider reading our\n guide on monitoring . Set up a logger using the Simple Logging Facade For Java (SLF4J) Configure the log level of your logger This section gives background on the dependencies necessary to set up a\nlogger and provides an example logger setup. The MongoDB Kotlin driver uses the Simple Logging Facade For Java (SLF4J).\nSLF4J allows you to specify your logging framework of choice at deployment time.\nFor more information on SLF4J,\n see the SLF4J documentation . Setting up a logger is optional. When you start your application the MongoDB\nKotlin driver looks for the  slf4j-api  artifact in your classpath. If the driver\ncan't find the  slf4j-api  artifact, the driver logs the following warning with\n java.util.logging  and disables all further logging: To set up a logger, you must include the following in your project. A binding is a piece of code that connects the  slf4j-api  artifact with a\nlogging framework. The following example shows how to bind the  slf4j-api  artifact\nto the two most popular logging frameworks, Log4j2 and Logback. The  slf4j-api  artifact A logging framework A  binding For the most popular logging frameworks, there is often a single binding\nartifact that lists the  slf4j-api  and the logging framework as\ndependencies. This means that you can set up a logger by adding one artifact\nto your project's dependency list. You will see this in the example below. This example shows how to set up your logger. Click the\ntab corresponding to the logging framework you would like to use in your project. The following versions listed are illustrative rather than a\nsource of truth. You should check the official documentation for SLF4J and\nyour logging framework of choice for guaranteed up-to-date version\ninformation. SLF4J documentation Logback documentation Log4j2 documentation Select the build tool you are using in your project. Once you have included the preceding dependency, connect to your\nMongoDB instance and retrieve a document with the following code: For more information on Logback, see the\n Logback manual . Add the following dependency to your  pom.xml  file. Add the following dependency to your  build.gradle.kts  file: The default log level of Logback is DEBUG. To learn how to change your\nLogback logger's log level, see the\n example in the Configure Your Logger section of this page . Select the build tool you are using in your project. Once you have included the preceding dependency, log an error using the\nfollowing code: For more information on Log4j2, see the\n Log4j2 manual . Add the following dependency to your  pom.xml  file. Add the following dependency to your  build.gradle.kts  file. The default log level of Log4J2 is ERROR. This means that running\nstandard operations in the MongoDB Kotlin driver will not produce output\nfrom Log4J2 without configuration. To learn how to change your Log4J2\nlogger's log level, see the\n example in the Configure Your Logger section of this page . To configure your logger, you must use the configuration system of the logging\nframework bound to SLF4J. In the following example we show how you can use your logging framework's\nconfiguration system to set your logger's  log level . A logger's log level specifies a lower bound for how urgent a message must be\nfor the logger to output that message. This example shows how to configure your logger's log level to INFO.\nSelect the tab corresponding to the logging framework you are using in your\nproject. Specify Logback configurations in a file named  logback.xml . Your\n logback.xml  file does not have to be in a specific location, but it must\nbe accessible from your classpath. The Logback framework defines the following log levels. The\nfollowing lists the log levels, ordered from most urgent to least\nurgent: Set your  logback.xml  file to the following. To test that your logger configuration was successful, run the following\ncode. For more information on configuring Logback, see the\n the Logback Manual . ERROR WARN INFO DEBUG TRACE Specify Log4j2 configurations in a file named  log4j2.xml . Your\n log4j2.xml  file does not have to be in a specific location, but it must\nbe accessible from your classpath. The Log4j2 framework defines the following log levels. The following lists the\nlog levels, ordered from most urgent to least urgent: Set your  log4j2.xml  file to the following. To test that your logger configuration was successful, run the following\ncode. For more information on configuring Log4j2, see the official\n Log4j2 configuration guide . FATAL ERROR WARN INFO DEBUG TRACE ALL Your logger uses logger names to help organize different logging events. Logger\nnames are strings that form a hierarchy. A logger is an ancestor of another logger if\nits name followed by a  \".\"  is a prefix of the other logger's name. For example,\n \"grandparent\"  is an ancestor of  \"grandparent.parent\"  which is an\nancestor of  \"grandparent.parent.child\" . For a concrete example, this is what a logger hierarchy looks like in code. A logger inherits the properties of its ancestor logger and can define\nits own. You can think of this as similar to class inheritance in Kotlin. The MongoDB Kotlin driver defines the following logger names to organize different\nlogging events in the driver. Here are the logger names defined in the driver\nand the logging events they correspond to: org.mongodb.driver.authenticator  : authentication org.mongodb.driver.client  : events related to  MongoClient  instances org.mongodb.driver.cluster  : monitoring of MongoDB servers org.mongodb.driver.connection  : connections and connection pools org.mongodb.driver.connection.tls  : TLS/SSL org.mongodb.driver.operation  : operations, including logging related to automatic retries org.mongodb.driver.protocol  : commands sent to and replies received from MongoDB servers org.mongodb.driver.uri  : connection string parsing org.mongodb.driver.management  : JMX (Java Management Extensions) This example shows how to change the log level for a specific driver logger.\nWe set the root logger to OFF and the  org.mongodb.driver.connection  logger to\nINFO. This will cause the application to only log messages related to connecting\nto a MongoDB instance. Select the tab corresponding to the logging framework you are using in your\nproject. Set your  logback.xml  file to the following. To test that your logger configuration was successful, run the following\ncode: For more information on configuring Logback, see the\n official Logback configuration guide . Set your  log4j2.xml  file to the following. To test that your logger configuration was successful, run the following\ncode. For more information on configuring Log4j2, see the\n official Log4J2 configuration guide .",
      "code": [
        {
          "lang": "none",
          "value": "WARNING: SLF4J not found on the classpath.  Logging is disabled for the 'org.mongodb.driver' component"
        },
        {
          "lang": "xml",
          "value": "<dependencies>\n  <dependency>\n    <groupId>ch.qos.logback</groupId>\n    <artifactId>logback-classic</artifactId>\n    <version>1.2.11</version>\n  </dependency>\n</dependencies>"
        },
        {
          "lang": "kotlin",
          "value": "dependencies {\n   implementation(\"ch.qos.logback:logback-classic:1.2.11\")\n}"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\"<connection string>\");\nval database = mongoClient.getDatabase(DB_NAME_PLACEHOLDER);\nval collection = database.getCollection<Document>(COLLECTION_NAME_PLACEHOLDER);\ncollection.find().firstOrNull()\n"
        },
        {
          "lang": "console",
          "value": "...\n12:14:55.853 [main] DEBUG org.mongodb.driver.connection - Opened connection [connectionId{localValue:3, serverValue:3}] to <MongoDB hostname>\n12:14:55.861 [main] DEBUG org.mongodb.driver.protocol.command - Command \"find\" started on database <database> using a connection with driver-generated ID 3 and server-generated ID 3 to <MongoDB hostname>. The request ID is 5. Command: {\"find\": \"<collection>\", \"filter\": {}, \"limit\": 1, \"singleBatch\": true, \"$db\": \"<database>\", \"lsid\": {\"id\": {\"$binary\": {\"base64\": \"<_id>\", \"subType\": \"04\"}}}, \"$readPreference\": {\"mode\": \"primaryPreferred\"}}\n12:14:55.864 [main] DEBUG org.mongodb.driver.protocol.command - Command \"find\" succeeded in 4.34 ms using a connection with driver-generated ID 3 and server-generated ID 3 to <MongoDB hostname. The request ID is 5. Command reply: {\"cursor\": {\"id\": 0, \"ns\": \"<database>.<collection>\", \"firstBatch\": []}, \"ok\": 1.0, \"$clusterTime\": {\"clusterTime\": {\"$timestamp\": {\"t\": 1673778535, \"i\": 1}}, \"signature\": {\"hash\": {\"$binary\": {\"base64\": \"<_id>\", \"subType\": \"00\"}}, \"keyId\": 0}}, \"operationTime\": {\"$timestamp\": {\"t\": 1673778535, \"i\": 1}}}"
        },
        {
          "lang": "xml",
          "value": "<dependencies>\n  <dependency>\n    <groupId>org.apache.logging.log4j</groupId>\n    <artifactId>log4j-slf4j-impl</artifactId>\n    <version>2.17.1</version>\n  </dependency>\n</dependencies>"
        },
        {
          "lang": "groovy",
          "value": "dependencies {\n  implementation(\"org.apache.logging.log4j:log4j-slf4j-impl:2.17.1\")\n}"
        },
        {
          "lang": "kotlin",
          "value": "val loggerParent = LoggerFactory.getLogger(\"parent\")\nval loggerChild = LoggerFactory.getLogger(\"parent.child\")\n"
        },
        {
          "lang": "kotlin",
          "value": "val loggerParent = LoggerFactory.getLogger(\"parent\")\nval loggerChild = LoggerFactory.getLogger(\"parent.child\")\n"
        },
        {
          "lang": "console",
          "value": "12:35:00.438 [main] ERROR <my package path> - Logging an Error"
        },
        {
          "lang": "xml",
          "value": "<configuration>\n   <appender name=\"CONSOLE\"\n             class=\"ch.qos.logback.core.ConsoleAppender\">\n      <encoder>\n         <pattern>\n               %-4relative [%thread] %-5level %logger{30} - %msg%n\n         </pattern>\n      </encoder>\n   </appender>\n   <root level=\"INFO\">\n      <appender-ref ref=\"CONSOLE\" />\n   </root>\n</configuration>"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\"<connection string>\");\nval database = mongoClient.getDatabase(DB_NAME_PLACEHOLDER);\nval collection = database.getCollection<Document>(COLLECTION_NAME_PLACEHOLDER);\ncollection.find().firstOrNull()\n"
        },
        {
          "lang": "console",
          "value": "...\n1317 [cluster-ClusterId{value='<your cluster id>', description='null'}-<your connection uri>] INFO  org.mongodb.driver.cluster - Discovered replica set primary <your connection uri>\n1568 [main] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:7, serverValue:<server value>}] to <your connection uri>"
        },
        {
          "lang": "xml",
          "value": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration status=\"INFO\">\n   <Appenders>\n      <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n      </Console>\n   </Appenders>\n   <Loggers>\n      <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n      </Root>\n   </Loggers>\n</Configuration>"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\"<connection string>\");\nval database = mongoClient.getDatabase(DB_NAME_PLACEHOLDER);\nval collection = database.getCollection<Document>(COLLECTION_NAME_PLACEHOLDER);\ncollection.find().firstOrNull()\n"
        },
        {
          "lang": "console",
          "value": "...\n10:14:57.633 [cluster-ClusterId{value=<your cluster id>, description='null'}-<your connection uri>] INFO  org.mongodb.driver.cluster - Discovered replica set primary <your connection uri>\n10:14:57.790 [main] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:7, serverValue:<your server value>}] to <your connection uri>"
        },
        {
          "lang": "kotlin",
          "value": "import org.slf4j.LoggerFactory\n"
        },
        {
          "lang": "kotlin",
          "value": "val loggerParent = LoggerFactory.getLogger(\"parent\")\nval loggerChild = LoggerFactory.getLogger(\"parent.child\")\n"
        },
        {
          "lang": "xml",
          "value": "<configuration>\n   <appender name=\"CONSOLE\"\n             class=\"ch.qos.logback.core.ConsoleAppender\">\n      <encoder>\n         <pattern>\n               %-4relative [%thread] %-5level %logger{30} - %msg%n\n         </pattern>\n      </encoder>\n   </appender>\n   <logger name=\"org.mongodb.driver.connection\" level=\"INFO\" additivity=\"true\"/>\n   <root level=\"OFF\">\n      <appender-ref ref=\"CONSOLE\" />\n   </root>\n</configuration>"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\"<connection string>\");\nval database = mongoClient.getDatabase(DB_NAME_PLACEHOLDER);\nval collection = database.getCollection<Document>(COLLECTION_NAME_PLACEHOLDER);\ncollection.find().firstOrNull()\n"
        },
        {
          "lang": "console",
          "value": "...\n829  [cluster-rtt-ClusterId{value='<some value>', description='null'}-<your connection URI>] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:2, serverValue:<your server value>}] to <your connection uri>\n977  [main] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:7, serverValue:<your server value>}] to <your connection uri>"
        },
        {
          "lang": "xml",
          "value": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration status=\"INFO\">\n   <Appenders>\n      <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n      </Console>\n   </Appenders>\n   <Loggers>\n      <Logger name=\"org.mongodb.driver.connection\" level=\"INFO\"/>\n      <Root level=\"OFF\">\n            <AppenderRef ref=\"Console\"/>\n      </Root>\n   </Loggers>\n</Configuration>"
        },
        {
          "lang": "kotlin",
          "value": "val mongoClient = MongoClient.create(\"<connection string>\");\nval database = mongoClient.getDatabase(DB_NAME_PLACEHOLDER);\nval collection = database.getCollection<Document>(COLLECTION_NAME_PLACEHOLDER);\ncollection.find().firstOrNull()\n"
        },
        {
          "lang": "console",
          "value": "...\n15:40:23.005 [cluster-ClusterId{value='<some value>', description='null'}-<your connection uri>] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:3, serverValue:<your server value>}] to <your connection uri>\n15:40:23.159 [main] INFO  org.mongodb.driver.connection - Opened connection [connectionId{localValue:7, serverValue:<your server value>}] to <your connection uri>"
        }
      ],
      "preview": "In this guide, you can learn how to set up and configure a logger in the\nMongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/monitoring",
      "title": "Monitoring",
      "headings": [
        "Overview",
        "Monitor Events",
        "Command Events",
        "Example",
        "Server Discovery and Monitoring Events",
        "Example",
        "Connection Pool Events",
        "Example",
        "Monitor Connection Pool Events with JMX",
        "JMX Support",
        "JMX and JConsole Example",
        "Include the Driver in Your Distributed Tracing System"
      ],
      "paragraphs": "In this guide, you can learn how to set up and configure  monitoring  in the\nMongoDB Kotlin driver. Monitoring is the process of getting information about the activities a running\nprogram performs for use in an application or an application performance\nmanagement library. Monitoring the MongoDB Kotlin driver lets you understand the\ndriver's resource usage and performance, and can help you make informed\ndecisions when designing and debugging your application. In this guide you will learn how to perform these tasks: This guide shows how to use information about the activity of the driver in code.\nIf you would like to learn how to record events in the driver,\nconsider reading our  guide on logging . Monitor different types of events in the MongoDB Kotlin driver Monitor connection pool events with Java Management Extensions (JMX) and JConsole To monitor an  event , you must register a  listener  on your  MongoClient \ninstance. An event is any action that happens in a running program. The driver includes functionality\nfor listening to a subset of the events that occur when the driver is running. A listener is a class that performs some action when certain events occur.\nA listener's API defines the events it can respond to. Each method of a listener class represents a response to a certain event. Each\nmethod receives one argument: an object representing the event the method\nresponds to. The MongoDB Kotlin driver organizes the events it defines into three categories: The following sections show how to monitor each event category. For a full list of the events you can monitor,\n see the event package of the MongoDB Kotlin driver . Command Events Server Discovery and Monitoring Events Connection Pool Events A command event is an event related to a MongoDB database command. Some\nexamples of database commands that produce command events are  find ,\n insert ,  delete , and  count . To monitor command events, write a class that implements the\n CommandListener  interface and register an instance of that class with your\n MongoClient  instance. For more information on MongoDB database commands, see the\n MongoDB manual entry on database commands . The driver does not publish events for commands it calls internally. This\nincludes database commands the driver uses to monitor your cluster and\ncommands related to connection establishment (such as the initial  hello \ncommand). As a security measure, the driver redacts the contents of some command events. This\nprotects the sensitive information contained in these command events. For a\nfull list of redacted command events, see the\n MongoDB command logging and monitoring specification . This example shows how to make a counter for database commands. The counter\nkeeps track of the number of times the driver successfully executes each database\ncommand, and prints this information every time a database command finishes. To make a counter, do the following: The following code defines the  CommandCounter  class which implements the\n CommandListener  interface: The following code adds an instance of the  CommandCounter  class to a\n MongoClientSettings  object, and configures a  MongoClient  instance with the\n MongoClientSettings  object. The code then runs some database commands to test the\ncounter. For more information on the classes and methods mentioned in this section, see\nthe following API Documentation: Make a class with counter functionality that implements the  CommandListener  interface. Add an instance of the new class that implements  CommandListener  to a  MongoClientSettings  object. Configure a  MongoClient  instance with the  MongoClientSettings  object. CommandListener MongoClientSettings MongoClient CommandStartedEvent CommandSucceededEvent CommandFailedEvent A server discovery and monitoring (SDAM) event is an event related to a change\nin the state of the MongoDB instance or cluster you have connected the driver to. The driver defines nine SDAM events. The driver divides these nine events\nbetween three separate listener interfaces which each listen for three of the\nnine events. Here are the three interfaces and the events they listen for: To monitor a type of SDAM event, write a class that\nimplements one of the three preceding interfaces and register an instance of that\nclass with your  MongoClient  instance. For a detailed description of each SDAM event, see the  MongoDB SDAM monitoring events specification . ClusterListener : topology-related events ServerListener : events related to  mongod  or  mongos  processes ServerMonitorListener : heartbeat related events This example shows how to make a listener class that prints a message that lets\nyou know if the driver can write to your MongoDB instance. The following code defines the  IsWritable  class which implements the\n ClusterListener  interface. The following code adds an instance of the  IsWritable  class to a\n MongoClient  object. The code then runs a find operation to test the\n IsWritable  class. For more information on the classes and methods mentioned in this section, see\nthe following API Documentation: ClusterListener ServerListener ServerMonitorListener MongoClientSettings MongoClient ClusterDescriptionChangedEvent A connection pool event is an event related to a  connection pool  held by the driver.\nA connection pool is a set of open TCP connections your driver maintains with\na MongoDB instance. Connection pools help reduce the number of network handshakes\nyour application needs to perform with a MongoDB instance, and can help your\napplication run faster. To monitor connection pool events, write a class that implements the\n ConnectionPoolListener  interface and register an instance of that class with your\n MongoClient  instance. This example shows how to make a listener class that prints a message each time\nyou check out a connection from your connection pool. The following code defines the  ConnectionPoolLibrarian  class which implements the\n ConnectionPoolListener  interface. The following code adds an instance of the  ConnectionPoolLibrarian  class to a\n MongoClient  object. The code then runs a database command to test the\nlibrarian. For more information on the classes and methods mentioned in this section, see\nthe following API Documentation: ConnectionPoolListener MongoClientSettings MongoClient ConnectionCheckedOutEvent ConnectionCheckOutFailedEvent You can monitor connection pool events using  Java Management Extensions (JMX) .\nJMX provides tools to monitor applications and devices. For more information on JMX, see\n the official Oracle JMX documentation . To enable JMX connection pool monitoring, add an instance of the\n JMXConnectionPoolListener  class to your  MongoClient  object. The  JMXConnectionPoolListener  class performs the following actions: MXBeans registered on the platform MBean server have the following properties: All MXBean instances created by the driver are under the domain\n \"org.mongodb.driver\" . For more information on the topics discussed in this subsection, see the\nfollowing resources from Oracle: Creates MXBean instances for each  mongod  or  mongos  process the driver\nmaintains a connection pool with. Registers these MXBean instances with the platform MBean server. Property Description clusterId A client-generated unique identifier. This identifier ensures that\neach MXBean the driver makes has a unique name when an application has\nmultiple  MongoClient  instances connected to the same MongoDB deployment. host The hostname of the machine running the  mongod  or  mongos  process. port The port on which the  mongod  or  mongos  process is listening. minSize The minimum size of the connection pool, including idle and in-use connections. maxSize The maximum size of the connection pool, including idle and in-use connections. size The current size of the connection pool, including idle and in-use connections. checkedOutCount The current count of connections that are in use. Platform MBean Server Reference Documentation MXBean Documentation MBean Documentation This example shows how you can monitor the driver's connection pools using JMX\nand  JConsole . JConsole is a JMX compliant GUI monitoring tool that comes with\nthe Java Platform. The following code snippet adds a  JMXConnectionPoolListener  to a\n MongoClient  instance. The code then pauses execution so you can\nnavigate to JConsole and inspect your connection pools. Once you have started your server, open JConsole in your terminal using the\nfollowing command: Once JConsole is open, perform the following actions in the GUI: When you no longer want to inspect your connection pools in JConsole, do the\nfollowing: For more information on JMX and JConsole, see the following resources from\nOracle: For more information on the  JMXConnectionPoolListener  class, see\nthe API Documentation for\n JMXConnectionPoolListener . The descriptions of JMX and JConsole in this example are illustrative\nrather than a source of truth. For guaranteed up to date information, consult\nthe following official Oracle resources: JConsole documentation . JMX documentation Select the process running the preceding example code. Press  Insecure Connection  in the warning dialog box. Click on the  MBeans  tab. Inspect your connection pool events under the  \"org.mongodb.driver\"  domain. Exit JConsole by closing the JConsole window Stop the program running the preceding code snippet JConsole Documentation . Monitoring and Management Guide If you use a  distributed tracing system , you can include event data from the\ndriver. A distributed tracing system is an application that\ntracks requests as they propagate throughout different services in a\nservice-oriented architecture. If you use the driver in a  Spring Cloud \napplication, use\n Spring Cloud Sleuth  to\ninclude MongoDB event data in the\n Zipkin  distributed tracing system. If you do not use Spring Cloud or need to include driver event data in a distributed\ntracing system other than Zipkin, you must write a command event listener that\nmanages  spans \nfor your desired distributed tracing system. To see an implementation of such a\nlistener, see the Java source code for the\n TraceMongoCommandListener \nclass in the Spring Cloud Sleuth source code. To learn more about Spring Cloud Sleuth, see\n Getting Started \nin the Spring Cloud Sleuth documentation. To view a detailed description of a distributed tracing system, see\n Dapper  from Google Research.",
      "code": [
        {
          "lang": "kotlin",
          "value": "class CommandCounter : CommandListener {\n    private val commands = mutableMapOf<String, Int>()\n\n\n    @Synchronized\n    override fun commandSucceeded(event: CommandSucceededEvent) {\n        val commandName = event.commandName\n        val count = commands[commandName] ?: 0\n        commands[commandName] = count + 1\n        println(commands.toString())\n    }\n\n    override fun commandFailed(event: CommandFailedEvent) {\n        println(\"Failed execution of command '${event.commandName}' with id ${event.requestId}\")\n    }\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val commandCounter = CommandCounter()\n\nval settings = MongoClientSettings.builder()\n    .applyConnectionString(URI)\n    .addCommandListener(commandCounter)\n    .build()\nval mongoClient = MongoClient.create(settings)\nval database = mongoClient.getDatabase(DATABASE)\nval collection = database.getCollection<Document>(COLLECTION)\n\n// Run some commands to test the counter\ncollection.find().firstOrNull()\ncollection.find().firstOrNull()\n"
        },
        {
          "lang": "console",
          "value": "{find=1}\n{find=2}\n{find=2, endSessions=1}"
        },
        {
          "lang": "kotlin",
          "value": "class IsWriteable : ClusterListener {\n    private var isWritable = false\n\n\n    @Synchronized\n    override fun clusterDescriptionChanged(event: ClusterDescriptionChangedEvent) {\n        if (!isWritable) {\n            if (event.newDescription.hasWritableServer()) {\n                isWritable = true\n                println(\"Able to write to cluster\")\n            }\n        } else {\n            if (!event.newDescription.hasWritableServer()) {\n                isWritable = false\n                println(\"Unable to write to cluster\")\n            }\n        }\n    }\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val clusterListener = IsWriteable()\nval settings = MongoClientSettings.builder()\n    .applyConnectionString(URI)\n    .applyToClusterSettings { builder ->\n        builder.addClusterListener(clusterListener)\n    }\n    .build()\nval mongoClient = MongoClient.create(settings)\nval database = mongoClient.getDatabase(DATABASE)\nval collection = database.getCollection<Document>(COLLECTION)\n// Run a command to trigger a ClusterDescriptionChangedEvent event\ncollection.find().firstOrNull()\n"
        },
        {
          "lang": "console",
          "value": "Able to write to server"
        },
        {
          "lang": "kotlin",
          "value": "class ConnectionPoolLibrarian : ConnectionPoolListener {\n\n    override fun connectionCheckedOut(event: ConnectionCheckedOutEvent) {\n        println(\"Let me get you the connection with id ${event.connectionId.localValue}...\")\n    }\n\n    override fun connectionCheckOutFailed(event: ConnectionCheckOutFailedEvent) {\n        println(\"Something went wrong! Failed to checkout connection.\")\n    }\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val cpListener = ConnectionPoolLibrarian()\nval settings = MongoClientSettings.builder()\n    .applyConnectionString(URI)\n    .applyToConnectionPoolSettings { builder ->\n        builder.addConnectionPoolListener(cpListener)\n    }\n    .build()\nval mongoClient = MongoClient.create(settings)\nval database = mongoClient.getDatabase(DATABASE)\nval collection = database.getCollection<Document>(COLLECTION)\n// Run a command to trigger connection pool events\ncollection.find().firstOrNull()\n"
        },
        {
          "lang": "console",
          "value": "Let me get you the connection with id 21..."
        },
        {
          "lang": "shell",
          "value": "jconsole"
        },
        {
          "lang": "kotlin",
          "value": "val connectionPoolListener = JMXConnectionPoolListener()\nval settings = MongoClientSettings.builder()\n    .applyConnectionString(uri)\n    .applyToConnectionPoolSettings {\n        it.addConnectionPoolListener(connectionPoolListener)\n    }\n    .build()\nval mongoClient: MongoClient = MongoClient.create(settings)\n\ntry {\n    println(\"Navigate to JConsole to see your connection pools...\")\n    Thread.sleep(Long.MAX_VALUE)\n} catch (e: Exception) {\n    e.printStackTrace()\n}\n"
        },
        {
          "lang": "console",
          "value": "Navigate to JConsole to see your connection pools..."
        }
      ],
      "preview": "In this guide, you can learn how to set up and configure monitoring in the\nMongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/stable-api",
      "title": "Stable API",
      "headings": [
        "Overview",
        "Enable the Stable API on a MongoDB Client",
        "Stable API Options"
      ],
      "paragraphs": "The Stable API feature requires MongoDB Server 5.0 or later. You should only use the Stable API feature if all the MongoDB\nservers you are connecting to support this feature. In this guide, you can learn how to specify the  Stable API  when connecting to\na MongoDB instance or replica set. You can use the Stable API feature to\nforce the server to run operations with behavior compatible with the\nspecified  API version . An API version defines the expected behavior of the\noperations it covers and the format of server responses. If you change to\na different API version, the operations are not guaranteed to be\ncompatible and the server responses are not guaranteed to be similar. When you use the Stable API feature with an official MongoDB driver, you\ncan update your driver or server without worrying about backward compatibility\nissues of the commands covered by the Stable API. See the MongoDB reference page on the  Stable API \nfor more information including a list of commands it covers. The following sections describe how you can enable the Stable API for\nyour MongoDB client and the options that you can specify. To enable the Stable API, you must specify an API version in the settings\nof your MongoDB client. Once you instantiate a  MongoClient  instance with\na specified API version, all commands you run with that client use that\nversion of the Stable API. The following example shows how you can instantiate a  MongoClient  that\nsets the Stable API version and connects to a server by performing the\nfollowing operations: For more information on the methods and classes referenced in this\nsection, see the following API Documentation: If you need to run commands using more than one version of the\nStable API, instantiate a separate client with that version. If you need to run commands not covered by the Stable API, make sure the\n\"strict\" option is disabled. See the section on\n Stable API Options  for more information. Construct a  ServerApi  instance using the  ServerApi.Builder \nhelper class. Specify a Stable API version using a constant from the\n ServerApiVersion  class. Construct a  MongoClientSettings  instance using the\n MongoClientSettings.Builder  class. Specify a server to connect to using a  ServerAddress  instance. Instantiate a  MongoClient  using the  MongoClient.create()  method\nand pass your  MongoClientSettings  instance as a parameter. If you specify an API version and connect to a MongoDB server that does\nnot support the Stable API, your application may raise an exception when\nexecuting a command on your MongoDB server. If you use a  MongoClient \nthat specifies the API version to query a server that does not support it,\nyour query could fail with an exception message that includes the\nfollowing text: ServerApi ServerApi.Builder ServerApiVersion ServerAddress MongoClientSettings MongoClientSettings.Builder MongoClient.create() MongoClient You can enable or disable optional behavior related to the Stable API as\ndescribed in the following table. The following example shows how you can set the two options on an instance\nof  ServerApi  by chaining methods on the  ServerApi.Builder : For more information on the options in this section, see the following\nAPI Documentation: Option Name Description Strict DeprecationErrors strict() deprecationErrors()",
      "code": [
        {
          "lang": "kotlin",
          "value": "val serverApi = ServerApi.builder()\n    .version(ServerApiVersion.V1)\n    .build()\n\n// Replace the uri string placeholder with your MongoDB deployment's connection string\nval uri = \"<connection string>\"\n\nval settings = MongoClientSettings.builder()\n    .applyConnectionString(ConnectionString(uri))\n    .serverApi(serverApi)\n    .build()\n\nval client = MongoClient.create(settings)\n"
        },
        {
          "lang": "none",
          "value": "'Unrecognized field 'apiVersion' on server..."
        },
        {
          "lang": "kotlin",
          "value": "val serverApi = ServerApi.builder()\n    .version(ServerApiVersion.V1)\n    .strict(true)\n    .deprecationErrors(true)\n    .build()\n"
        }
      ],
      "preview": "In this guide, you can learn how to specify the Stable API when connecting to\na MongoDB instance or replica set. You can use the Stable API feature to\nforce the server to run operations with behavior compatible with the\nspecified API version. An API version defines the expected behavior of the\noperations it covers and the format of server responses. If you change to\na different API version, the operations are not guaranteed to be\ncompatible and the server responses are not guaranteed to be similar.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals/time-series",
      "title": "Time Series Collections",
      "headings": [
        "Overview",
        "Create a Time Series Collection",
        "Query a Time Series Collection"
      ],
      "paragraphs": "In this guide, you can learn about  time series collections  in\nMongoDB, and how to interact with them in the MongoDB Kotlin driver. Time series collections efficiently store sequences of measurements over\na period of time. Time series data consists of any data collected over\ntime, metadata that describes the measurement, and the time of the\nmeasurement. Example Measurement Metadata Sales Data Revenue Company Infection Rates Amount of People Infected Location To create a time series collection, pass the following parameters to the\n createCollection() \nmethod: To check if you successfully created the collection, send the\n \"listCollections\"  command to the  runCommand()  method. The name of the new collection to create The  TimeSeriesOptions \nfor creating the collection in a  CreateCollectionOptions  object Versions prior to MongoDB 5.0 cannot create a time series collection. To query in a time series collection, use the same conventions as you\nwould for  retrieving \nand  aggregating data . For more information, see our\n Aggregates Builders guide . MongoDB version 5.0 introduces window functions into the aggregation\npipeline. You can use window functions to perform operations on a\ncontiguous span of time series data.",
      "code": [
        {
          "lang": "kotlin",
          "value": "val database = mongoClient.getDatabase(\"fall_weather\")\nval tsOptions = TimeSeriesOptions(\"temperature\")\nval collOptions = CreateCollectionOptions().timeSeriesOptions(tsOptions)\n\ndatabase.createCollection(\"september2021\", collOptions)\n"
        },
        {
          "lang": "kotlin",
          "value": "val commandResult = database.listCollections().toList()\n    .find { it[\"name\"] == \"september2021\" }\n\nprintln(commandResult?.toJson(JsonWriterSettings.builder().indent(true).build()))\n"
        },
        {
          "lang": "json",
          "value": "{\n  \"name\": \"september2021\",\n  \"type\": \"timeseries\",\n  \"options\": {\n    \"timeseries\": {\n      \"timeField\": \"temperature\",\n      \"granularity\": \"seconds\",\n      \"bucketMaxSpanSeconds\": 3600\n    }\n  },\n  \"info\": {\n    \"readOnly\": false\n  }\n}"
        }
      ],
      "preview": "In this guide, you can learn about time series collections in\nMongoDB, and how to interact with them in the MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "fundamentals",
      "title": "Fundamentals",
      "headings": [],
      "paragraphs": "Learn how to perform the following tasks using the Kotlin driver in the\nFundamentals section: Connect to MongoDB Use the Stable API Authenticate with MongoDB Convert between MongoDB Data Formats and Kotlin Objects Read from and Write to MongoDB Simplify your Code with Builders Transform your Data Create Aggregation Expressions Create Indexes to Speed Up Queries Sort Using Collations Log Events in the Driver Monitor Driver Events Use a Time Series Collection Encrypt Fields in a Document",
      "code": [],
      "preview": null,
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "",
      "title": "MongoDB Kotlin Driver",
      "headings": [
        "Introduction",
        "Quick Start",
        "Quick Reference",
        "What's New",
        "Usage Examples",
        "Fundamentals",
        "API Documentation",
        "FAQ",
        "Connection Troubleshooting",
        "Issues & Help",
        "Compatibility",
        "Migrate from KMongo",
        "Validate Driver Artifact Signatures",
        "Learn",
        "Developer Hub"
      ],
      "paragraphs": "Welcome to the documentation site for the Kotlin Driver, the official\nMongoDB driver for server-side Kotlin applications that use coroutines.\nDownload the driver by using  Maven  or  Gradle , or set up a runnable project by following our\nQuick Start guide. If your Kotlin application requires synchronous processing, use the\n Sync Driver , which uses synchronous operations\nto make blocking calls to MongoDB. If you are developing an Android or Kotlin Multiplatform (KMP)\napplication, you can use the  MongoDB Atlas Device Kotlin SDK \nto access Atlas App Services and to manage your Realm data. Learn how to establish a connection to MongoDB Atlas and begin\nworking with data in the  Quick Start  section. See driver syntax examples for common MongoDB commands in the\n Quick Reference  section. For a list of new features and changes in each version, see the\n What's New  section. For fully runnable code snippets and explanations for common\nmethods, see the  Usage Examples  section. Learn how to perform the following tasks using the Kotlin driver in the\nFundamentals section: Connect to MongoDB Use the Stable API Authenticate with MongoDB Convert between MongoDB Data Formats and Kotlin Objects Read from and Write to MongoDB Simplify your Code with Builders Transform your Data Create Aggregation Expressions Create Indexes to Speed Up Queries Sort Using Collations Log Events in the Driver Monitor Driver Events Use a Time Series Collection Encrypt Fields in a Document The MongoDB Kotlin driver API documentation contains several libraries\norganized by functionality. For detailed information about classes and\nmethods in each library, see the following table for their descriptions\nand links to the API documentation. Library Description BSON Base BSON classes BSON Record Codec Classes that support records Core Shared core classes Kotlin Driver API For answers to commonly asked questions about the MongoDB\nKotlin Driver, see the  Frequently Asked Questions (FAQ) \nsection. For solutions to some issues you might experience when connecting to a MongoDB\ndeployment while using the MongoDB Kotlin Driver, see the\n Connection Troubleshooting  section. Learn how to report bugs, contribute to the driver, and find\nadditional resources for asking questions and receiving help in the\n Issues & Help  section. For the compatibility charts that show the recommended Kotlin\nDriver version for each MongoDB Server version, see the\n Compatibility  section. Learn about the changes needed to migrate from the\ncommunity-developed KMongo driver to the MongoDB Kotlin Driver in the\n Migrate from KMongo  section. Learn about how to validate signatures of Kotlin driver artifacts\npublished on Maven in the  Validate Driver Artifact Signatures  section. Visit the Developer Hub to learn more about the MongoDB Kotlin driver. The Developer Hub provides tutorials and social engagement for\ndevelopers. To learn how to use MongoDB features with the Kotlin driver, see the\n Kotlin Tutorials and Articles  page, which\nfeatures our  Getting Started with the MongoDB Kotlin Driver \ndeveloper tutorial. To ask questions and engage in discussions with fellow developers using\nthe Kotlin Driver, visit the  MongoDB Developer Community .",
      "code": [],
      "preview": "Welcome to the documentation site for the Kotlin Driver, the official\nMongoDB driver for server-side Kotlin applications that use coroutines.\nDownload the driver by using Maven or Gradle, or set up a runnable project by following our\nQuick Start guide.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "issues-and-help",
      "title": "Issues & Help",
      "headings": ["Bugs / Feature Requests", "Pull Requests"],
      "paragraphs": "We are lucky to have a vibrant MongoDB Kotlin community that includes users\nwith varying levels of experience using the Kotlin driver. We find the quickest\nway to get support for general questions is through the  MongoDB Community Forums . Refer to our  support channels \ndocumentation for more information. If you think you've found a bug or want to see a new feature in the Kotlin\ndriver, please open a case in our issue management tool, JIRA: If you've identified a security vulnerability in a driver or any other\nMongoDB project, please report it according to the instructions found in the\n Create a Vulnerability Report page . Create an account and login . Navigate to  the JAVA project . Click  Create . Please provide as much information as possible\nabout the issue and the steps to reproduce it. Bug reports in JIRA for the Kotlin driver and the Core Server (i.e. SERVER)\nproject are public. We are happy to accept contributions to help improve the driver. We will guide\nuser contributions to ensure they meet the standards of the codebase. Please\nensure that any pull requests include documentation, tests, and pass the\n gradle  checks. To get started check out the source and work on a branch: Finally, ensure that the code passes gradle checks.",
      "code": [
        {
          "lang": "bash",
          "value": "$ git clone https://github.com/mongodb/mongo-java-driver.git\n$ cd mongo-java-driver\n$ git checkout -b myNewFeature"
        },
        {
          "lang": "bash",
          "value": "$ ./gradlew check"
        }
      ],
      "preview": "We are lucky to have a vibrant MongoDB Kotlin community that includes users\nwith varying levels of experience using the Kotlin driver. We find the quickest\nway to get support for general questions is through the MongoDB Community Forums.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "migrate-kmongo",
      "title": "Migrate from KMongo",
      "headings": [
        "Overview",
        "Connect to MongoDB Cluster",
        "CRUD and Aggregation",
        "Construct Queries",
        "Data Typing",
        "Data Serialization",
        "Synchronous and Asynchronous Support",
        "What Next?"
      ],
      "paragraphs": "This page contains a high-level comparison of most of the ways the official\nMongoDB Kotlin and the community-developed KMongo driver differ.\nYou can use this page to identify the changes you need to make to migrate from\nthe deprecated KMongo driver to the official MongoDB Kotlin driver. The MongoDB Kotlin driver is the officially supported and maintained MongoDB driver for\nKotlin. It is developed by the MongoDB team. Although both drivers  support synchronous and asynchronous operations ,\nthe examples on this page will use asynchronous coroutine-based operations. KMongo  is a popular community-developed library\nfor working with MongoDB from Kotlin applications.\nIt is a wrapper around the Java driver that was created prior to the creation of\nthe official Kotlin driver to serve the needs of the Kotlin community. As of July 2023, KMongo has been marked as deprecated. Both drivers let you connect to and communicate with MongoDB clusters from a\nKotlin application. To connect to a MongoDB cluster using the MongoDB Kotlin driver: See the  Connect to MongoDB  documentation for more\ninformation. To connect to a MongoDB cluster using KMongo with coroutines: Unlike the MongoDB Kotlin driver, KMongo allows the collection name to be\ninferred from the data class name. Both drivers provide support for all MongoDB CRUD APIs and aggregation\noperations. The MongoDB Kotlin driver also provides functions for all basic CRUD operations: Aggregation pipelines can be built using the  aggregate  method and the\n pipeline  function: See the  CRUD Operations  and\n Aggregation  documentation for more information. KMongo provides functions for all basic CRUD operations: Aggregation pipelines can be built using the  aggregate  method and the\n pipeline  function: For more information on available methods, see the\n Extensions Overview  KMongo\ndocumentation. Both drivers provide support for type-safe queries using property references. The MongoDB Kotlin driver uses the Builders API to construct queries.\nAlternatively, you can use the  Document  class. To map a KMongo string query to the Kotlin driver, you can use the  JsonObject  class. For more information, see the following Kotlin driver documentation: Builders Documents  guide JsonObject  API Documentation With KMongo, you can create queries using property references on the data class\nthat represents objects in a collection and infix operators that the library\nprovides. KMongo also supports string queries that let you construct queries with\nMongoDB Query Language: For more information, see the following KMongo documentation: Typed Queries Mongo Shell Queries Both drivers support the use of Kotlin data classes as well as the  Document  class to\nmodel the data stored in a MongoDB collection. The  Document \nclass lets you model data represented in a MongoDB collection in a flexible format. You can use data classes and  Document  classes to model data with the\nMongoDB Kotlin driver: You can use data classes and  Document  classes to model data in KMongo: Both drivers provide support for serializing and deserializing data objects\nin Kotlin to and from BSON. You can serialize data classes in the Kotlin driver using both automatic\ndata class codecs as well as the  kotlinx.serialization  library. The\ndriver provides an efficient  Bson  serializer that handles the\nserialization of Kotlin objects to BSON data. To learn more, see the  Kotlin Serialization \ndocumentation. If you use the  Document  class to represent your collection, you can\nserialize it to JSON and EJSON using the  .toJson()  method: To learn more about serializing data with the  Document  class, refer to\n Document Data Format - Extended JSON  documentation. You can serialize data in KMongo using the following serialization libraries: To learn more about the KMongo serialization methods, refer to the\n Object Mapping \nKMongo documentation. Jackson  (default) POJO Codec engine kotlinx.serialization Both drivers support synchronous and asynchronous operations. The MongoDB Kotlin driver also has separate libraries for synchronous and\nasynchronous operations. However, the Kotlin driver only has built-in support\nfor coroutines as an asynchronous paradigm. The MongoDB Kotlin driver does not\ncurrently provide support for other asynchronous paradigms such as Reactive\nStreams, Reactor, or RxJava2. Unlike KMongo, if you want to write asynchronous code, you only need to import\nthe relevant package. To write synchronous code: To write asynchronous coroutine code: Driver Package Sync Coroutines KMongo has a core library  org.litote.kmongo:kmongo  with main functionality and\nseparate companion libraries that provide asynchronous support to the core library. KMongo supports the following asynchronous paradigms: To write synchronous code with KMongo: To write async coroutine code with KMongo: To learn more, refer to the  Quick Start \nin the KMongo documentation. Async Style Package Reactive Streams Coroutines Reactor RxJava2 Now that you have learned about the differences between KMongo and the MongoDB\nKotlin driver, see the  Quick Start  to get\nstarted using the KMongo Kotlin driver.",
      "code": [
        {
          "lang": "kotlin",
          "value": "import com.mongodb.kotlin.client.coroutine.MongoClient\n\ndata class Jedi(val name: String, val age: Int)\n\n// Replace the placeholder with your MongoDB deployment's connection string\nval uri = CONNECTION_STRING_URI_PLACEHOLDER\n\nval mongoClient = MongoClient.create(uri)\n\nval database = mongoClient.getDatabase(\"test\")\n// Get a collection of documents of type Jedi\nval collection = database.getCollection<Jedi>(\"jedi\")"
        },
        {
          "lang": "kotlin",
          "value": "import org.litote.kmongo.reactivestreams.*\nimport org.litote.kmongo.coroutine.*\n\ndata class Jedi(val name: String, val age: Int)\n\n// Get new MongoClient instance using coroutine extension\nval client = KMongo.createClient().coroutine\n\nval database = client.getDatabase(\"test\")\n// Get a collection of documents of type Jedi\nval col = database.getCollection<Jedi>()"
        },
        {
          "lang": "kotlin",
          "value": "// Insert a document\n  val jedi =a Jedi(\"Luke Skywalker\", 19)\n  collection.insertOne(jedi)\n\n  // Find a document\n  val luke = collection.find(Jedi::name.name, \"Luke Skywalker\")\n  val jedis = collection.find(lt(Jedi::age.name, 30)).toList()\n\n  // Update a document\n  val filter = Filters.eq(Jedi::name.name, \"Luke Skywalker\")\n  val update = Updates.set(Jedi::age.name, 20)\n  collection.updateOne(filter, update)\n\n  // Delete a document\n  val filter = Filters.eq(Jedi::name.name, \"Luke Skywalker\")\n  collection.deleteOne(filter)"
        },
        {
          "lang": "kotlin",
          "value": "data class Results(val avgAge: Double)\n\nval resultsFlow = collection.aggregate<Results>(\n    listOf(\n      Aggregates.match(Filters.ne(Jedi::name.name, \"Luke Skywalker\")),\n      Aggregates.group(\"\\$${Jedi::name.name}\",\n          Accumulators.avg(\"avgAge\", \"\\$${Jedi::age.name}\"))\n    )\n)\nresultsFlow.collect { println(it) }"
        },
        {
          "lang": "kotlin",
          "value": "// Insert a document\nval jedi = Jedi(\"Luke Skywalker\", 19)\ncol.insertOne(jedi)\n\n// Find a document\nval luke = col.findOne(Jedi::name eq \"Luke Skywalker\")\nval jedis = col.find(Jedi::age lt 30).toList()\n\n// Update a document\ncol.updateOne(Jedi::name eq \"Luke Skywalker\", setValue(Jedi::age, 20))\n\n// Delete a document\ncol.deleteOne(Jedi::name eq \"Luke Skywalker\")"
        },
        {
          "lang": "kotlin",
          "value": "val avgAge = collection.aggregate<Double>(\n    pipeline(\n        match(Jedi::name ne \"Luke Skywalker\"),\n        group(Jedi::name, avg(Jedi::age))\n    )\n).toList()"
        },
        {
          "lang": "kotlin",
          "value": "data class Person(val name: String, val email: String, val gender: String, val age: Int)\ndata class Results(val email: String)\n\nval collection = database.getCollection<Person>(\"people\")\n\n// Using Builders\nval filter = and(eq(\"gender\", \"female\"), gt(\"age\", 29))\nval projection = fields(excludeId(), include(\"email\"))\nval results = collection.find<Results>(filter).projection(projection)\n\n// Using Document class\nval filter = Document().append(\"gender\", \"female\").append(\"age\", Document().append(\"\\$gt\", 29))\nval projection = Document().append(\"_id\", 0).append(\"email\", 1)\nval results = collection.find<Results>(filter).projection(projection)"
        },
        {
          "lang": "kotlin",
          "value": "val query = JsonObject(\"{\\\"name\\\": \\\"Gabriel Garc\\\\u00eda M\\\\u00e1rquez\\\"}\")\nval jsonResult = collection.find(query).firstOrNull()"
        },
        {
          "lang": "kotlin",
          "value": "data class Jedi(val name: String)\n\nval yoda = col.findOne(Jedi::name eq \"Yoda\")\n\n// Compile error (2 is not a String)\nval error = col.findOne(Jedi::name eq 2)\n\n// Use property reference with instances\nval yoda2 = col.findOne(yoda::name regex \"Yo.*\")"
        },
        {
          "lang": "kotlin",
          "value": "import org.litote.kmongo.MongoOperator.lt\nimport org.litote.kmongo.MongoOperator.match\nimport org.litote.kmongo.MongoOperator.regex\nimport org.litote.kmongo.MongoOperator.sample\n\nval yoda = col.findOne(\"{name: {$regex: 'Yo.*'}}\")!!\nval luke = col.aggregate<Jedi>(\"\"\"[ {$match:{age:{$lt : ${yoda.age}}}},\n                                    {$sample:{size:1}}\n                                ]\"\"\").first()"
        },
        {
          "lang": "kotlin",
          "value": "// With data class\ndata class Movie(val title: String, val year: Int, val rating: Float)\n\nval dataClassCollection = database.getCollection<Movie>(\"movies\")\nval movieDataClass = dataClassCollection.findOneOrNull()\nval movieNameDataClass = movieDataClass.title\n\n// With Document class\nval documentCollection = database.getCollection<Movie>(\"movies\")\nval movieDocument = documentCollection.findOneOrNull()\nval movieTitleDocument = movieDocument.getString(\"title\")"
        },
        {
          "lang": "kotlin",
          "value": "// With data class\ndata class Movie(val title: String, val year: Int, val rating: Float)\n\nval collection = database.getCollection<Movie>(\"movies\")\nval movieDataClass = dataClassCollection.findOne()\nval movieNameDataClass = movieDataClass.title\n\n// With Document class\nval documentCollection = database.getCollection(\"movies\")\nval movieDocument = documentCollection.findOne()\nval movieTitleDocument = movieDocument.getString(\"title\")"
        },
        {
          "lang": "kotlin",
          "value": "@Serializable\ndata class LightSaber(\n    @SerialName(\"_id\") // Use instead of @BsonId\n    @Contextual val id: ObjectId?,\n    val color: String,\n    val qty: Int,\n    @SerialName(\"brand\")\n    val manufacturer: String = \"Acme\" // Use instead of @BsonProperty\n)"
        },
        {
          "lang": "kotlin",
          "value": "val document = Document(\"_id\", 1).append(\"color\", \"blue\")\n\n// Serialize to JSON\ndocument.toJson()\n\n// Serialize to EJSON\nval settings = JsonWriterSettings.builder().outputMode(JsonMode.STRICT).build()\nval json = doc.toJson(settings)"
        },
        {
          "lang": "kotlin",
          "value": "// Using KotlinX Serialization\n@Serializable\ndata class Data(@Contextual val _id: Id<Data> = newId())\n\nval json = Json { serializersModule = IdKotlinXSerializationModule }\nval data = Data()\nval json = json.encodeToString(data)"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.kotlin.client.MongoClient\n\n// Instantiate your collection\ndata class Jedi(val name: String, val age: Int)\nval uri = \"<your-connection-string\">\nval mongoClient = MongoClient.create(uri)\nval database = mongoClient.getDatabase(\"test\")\nval collection = database.getCollection<Jedi>(\"jedi\")\n\n// Synchronous operations\nval jedi =a Jedi(\"Luke Skywalker\", 19)\ncollection.insertOne(jedi)"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.kotlin.client.coroutine.MongoClient\n\n// Instantiate your collection\ndata class Jedi(val name: String, val age: Int)\nval uri = \"<your-connection-string\">\nval mongoClient = MongoClient.create(uri)\nval database = mongoClient.getDatabase(\"test\")\nval collection = database.getCollection<Jedi>(\"jedi\")\n\nrunBlocking {\n\n  // Async operations\n  val jedi =a Jedi(\"Luke Skywalker\", 19)\n  collection.insertOne(jedi)\n}"
        },
        {
          "lang": "kotlin",
          "value": "import org.litote.kmongo.*\n\n// Instantiate your collection\ndata class Jedi(val name: String, val age: Int)\n\nval client = KMongo.createClient()\nval database = client.getDatabase(\"test\")\nval col = database.getCollection<Jedi>()\n\n// Synchronous operations\ncol.insertOne(Jedi(\"Luke Skywalker\", 19))\nval yoda : Jedi? = col.findOne(Jedi::name eq \"Yoda\")"
        },
        {
          "lang": "kotlin",
          "value": "import org.litote.kmongo.reactivestreams.*\nimport org.litote.kmongo.coroutine.*\n\n// Instantiate your collection\ndata class Jedi(val name: String, val age: Int)\n\nval client = KMongo.createClient()\nval database = client.getDatabase(\"test\")\nval col = database.getCollection<Jedi>()\n\nrunBlocking {\n\n  // Async operations\n  col.insertOne(Jedi(\"Luke Skywalker\", 19))\n  val yoda : Jedi? = col.findOne(Jedi::name eq \"Yoda\")\n}"
        }
      ],
      "preview": "This page contains a high-level comparison of most of the ways the official\nMongoDB Kotlin and the community-developed KMongo driver differ.\nYou can use this page to identify the changes you need to make to migrate from\nthe deprecated KMongo driver to the official MongoDB Kotlin driver.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "quick-reference",
      "title": "Quick Reference",
      "headings": [],
      "paragraphs": "This page shows the driver syntax for several MongoDB commands and links to\ntheir related reference and API documentation. The examples on the page use the following data class to represent MongoDB documents: Command Syntax",
      "code": [
        {
          "lang": "kotlin",
          "value": "data class Movie(\n    val title: String,\n    val year: Int,\n    val rated: String? = \"Not Rated\",\n    val genres: List<String>? = listOf()\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.find(\n    Filters.eq(Movie::title.name, \"Shrek\")\n).firstOrNull()\n"
        },
        {
          "lang": "console",
          "value": "Movie(title=Shrek, year=2001, ...)"
        },
        {
          "lang": "kotlin",
          "value": "collection.find(\n    Filters.eq(Movie::year.name, 2004)\n)\n"
        },
        {
          "lang": "console",
          "value": "[\n Movie(title=Shrek 2, year=2004, ...),\n Movie(title=Spider-Man 2, year=2004, ...),\n Movie(title=National Treasure, year=2004, ...),\n ...\n]"
        },
        {
          "lang": "kotlin",
          "value": "collection.insertOne(Movie(\"Shrek\", 2001))\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.insertMany(\n    listOf(\n        Movie(\"Shrek\", 2001),\n        Movie(\"Shrek 2\", 2004),\n        Movie(\"Shrek the Third\", 2007),\n        Movie(\"Shrek Forever After\", 2010),\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.updateOne(\n    Filters.eq(Movie::title.name, \"Shrek\"),\n    Updates.set(Movie::rated.name, \"PG\")\n)\n"
        },
        {
          "lang": "console",
          "value": "Movie(title=Shrek, year=2001, rated=PG, genres=[])"
        },
        {
          "lang": "kotlin",
          "value": "collection.updateMany(\n    Filters.regex(Movie::title.name, \"Shrek\"),\n    Updates.set(Movie::rated.name, \"PG\")\n)\n"
        },
        {
          "lang": "console",
          "value": "[\n  Movie(title=Shrek, year=2001, rated=PG, genres=[]),\n  Movie(title=Shrek 2, year=2004, rated=PG, genres=[]),\n  Movie(title=Shrek the Third, year=2007, rated=PG, genres=[]),\n  Movie(title=Shrek Forever After, year=2010, rated=PG, genres=[])\n]"
        },
        {
          "lang": "kotlin",
          "value": "collection.updateOne(\n    Filters.eq(Movie::title.name, \"Shrek\"),\n    Updates.addEachToSet(Movie::genres.name, listOf(\"Family\", \"Fantasy\"))\n)\n"
        },
        {
          "lang": "console",
          "value": "Movie(title=Shrek, year=2001, rated=Not Rated, genres=[Family, Fantasy])"
        },
        {
          "lang": "kotlin",
          "value": "collection.replaceOne(\n    Filters.eq(Movie::title.name, \"Shrek\"),\n    Movie(\"Kersh\", 1002, \"GP\")\n)\n"
        },
        {
          "lang": "console",
          "value": "Movie(title=Kersh, year=1002, rated=GP, genres=[])"
        },
        {
          "lang": "kotlin",
          "value": "collection.deleteOne(\n    Filters.eq(Movie::title.name, \"Shrek\")\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.deleteMany(\n    Filters.regex(Movie::title.name, \"Shrek\")\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.bulkWrite(\n    listOf(\n        InsertOneModel(Movie(\"Shrek\", 2001)),\n        DeleteManyModel(Filters.lt(Movie::year.name, 2004)),\n    )\n)\n"
        },
        {
          "lang": "kotlin",
          "value": "val changeStream = collection.watch()\nchangeStream.collect {\n    println(\"Change to ${it.fullDocument?.title}\")\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.find().toList()\n"
        },
        {
          "lang": "console",
          "value": "[\n  Movie(title=Shrek, year=2001, rated=Not Rated, genres=[]),\n  Movie(title=Shrek 2, year=2004, rated=Not Rated, genres=[]),\n  Movie(title=Shrek the Third, year=2007, rated=Not Rated, genres=[]),\n  Movie(title=Shrek Forever After, year=2010, rated=Not Rated, genres=[])\n]"
        },
        {
          "lang": "kotlin",
          "value": "collection.countDocuments(Filters.eq(\"year\", 2001))\n"
        },
        {
          "lang": "console",
          "value": "42"
        },
        {
          "lang": "kotlin",
          "value": "collection.distinct<String>(Movie::rated.name)\n"
        },
        {
          "lang": "console",
          "value": "[Not Rated, PG, PG-13]"
        },
        {
          "lang": "kotlin",
          "value": "collection.find()\n    .limit(2)\n"
        },
        {
          "lang": "console",
          "value": "[\n  Movie(title=Shrek, year=2001, rated=Not Rated, genres=[]),\n  Movie(title=Shrek 2, year=2004, rated=Not Rated, genres=[])\n]"
        },
        {
          "lang": "kotlin",
          "value": "collection.find()\n    .skip(2)\n"
        },
        {
          "lang": "console",
          "value": "[\n  Movie(title=Shrek the Third, year=2007, rated=Not Rated, genres=[]),\n  Movie(title=Shrek Forever After, year=2010, rated=Not Rated, genres=[])\n]"
        },
        {
          "lang": "kotlin",
          "value": "collection.find().sort(Sorts.descending(Movie::year.name))\n"
        },
        {
          "lang": "console",
          "value": "[\n  Movie(title=Shrek Forever After, year=2010, rated=Not Rated, genres=[]),\n  Movie(title=Shrek the Third, year=2007, rated=Not Rated, genres=[]),\n  Movie(title=Shrek 2, year=2004, rated=Not Rated, genres=[]),\n  Movie(title=Shrek, year=2001, rated=Not Rated, genres=[])\n]"
        },
        {
          "lang": "kotlin",
          "value": "data class Result(val title: String)\n    collection.find<Result>()\n        .projection(Projections.include(Movie::title.name))\n"
        },
        {
          "lang": "console",
          "value": "Result(title=Shrek)"
        },
        {
          "lang": "kotlin",
          "value": "collection.createIndex(Indexes.ascending(Movie::title.name))\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.find(Filters.text(\"Forever\"));\n"
        },
        {
          "lang": "console",
          "value": "[Movie(title=Shrek Forever After, year=2010, rated=Not Rated, genres=[])]"
        },
        {
          "lang": "xml",
          "value": "<dependencies>\n    <dependency>\n        <groupId>org.mongodb</groupId>\n        <artifactId>mongodb-driver-kotlin-coroutine</artifactId>\n        <version>5.1.2</version>\n    </dependency>\n</dependencies>"
        },
        {
          "lang": "kotlin",
          "value": "dependencies {\n    implementation(\"org.mongodb:mongodb-driver-kotlin-coroutine:5.1.2\")\n}"
        },
        {
          "lang": "kotlin",
          "value": "val flow = collection.find(\n    Filters.eq(Movie::year.name, 2004)\n)\nflow.collect { println(it) }\n"
        },
        {
          "lang": "console",
          "value": "Movie(title=2001: A Space Odyssey, ...)\nMovie(title=The Sound of Music, ...)"
        }
      ],
      "preview": "This page shows the driver syntax for several MongoDB commands and links to\ntheir related reference and API documentation.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "quick-start",
      "title": "Kotlin Driver Quick Start",
      "headings": [
        "Introduction",
        "Set up Your Project",
        "Install Kotlin",
        "Create the Project",
        "Add MongoDB as a Dependency",
        "Add Serialization Library Dependencies",
        "Create a MongoDB Cluster",
        "Connect to your Cluster",
        "Query Your MongoDB Cluster from Your Application",
        "Working with the Document Class (Alternative)",
        "Next Steps"
      ],
      "paragraphs": "This guide shows you how to create an application that uses the  Kotlin driver \nto connect to a  MongoDB Atlas cluster . If you prefer to connect to\nMongoDB by using a different driver or programming language, see the\n list of official MongoDB drivers . The Kotlin driver lets you connect to and communicate with MongoDB clusters\nfrom a Kotlin application. MongoDB Atlas is a fully managed cloud database service that hosts your data\non MongoDB clusters. In this guide, you can learn how to get started with your\nown free cluster. To view another example that demonstrates how to build an\napplication in Kotlin that connects to MongoDB Atlas, see the\n Getting Started with the MongoDB Kotlin Driver \ndeveloper tutorial. Make sure that your system has Kotlin installed and running on JDK 1.8 or later.\nFor more information on getting started with Kotlin/JVM development,\nrefer to  Get started with Kotlin/JVM \nin the Kotlin language documentation. This guide shows you how to add the MongoDB Kotlin driver dependencies\nby using Gradle or Maven. We recommend that you use an integrated development\nenvironment (IDE) such as IntelliJ IDEA or Eclipse IDE to configure\nGradle or Maven to build and run your project. If you are not using an IDE, see the\n Creating New Gradle Builds  guide\nor the  Building Maven  guide\nfor more information on how to set up your project. If you are using  Gradle  to manage your\npackages, add the following entry to your  build.gradle.kts \ndependencies list: If you are using  Maven  to manage your\npackages, add the following entry to your  pom.xml  dependencies list: After you configure your dependencies, ensure that they are available to your\nproject by running the dependency manager and refreshing the\nproject in your IDE. To enable the driver to convert between Kotlin objects and BSON, the\ndata format for documents in MongoDB, you must also add one or both of the\nfollowing serialization packages to your application: If you are using Gradle to manage your packages, add one of the following\nentries to your  build.gradle.kts  dependencies list: If you are using Maven to manage your packages, add one of the following\nentries to your  pom.xml  dependencies list: After you configure your dependencies, ensure that they are available to your\nproject by running the dependency manager and refreshing the\nproject in your IDE. To learn more about these packages, see\n Kotlin Serialization . bson-kotlinx   (Recommended) bson-kotlin After setting up your Kotlin project dependencies, create a MongoDB cluster\nin which you can store and manage your data. Complete the\n Get Started with Atlas  tutorial\nto set up a new Atlas account, create and launch a free tier MongoDB cluster,\nand load sample datasets. After you complete the steps in the Get Started with Atlas tutorial, you\nhave a new MongoDB cluster deployed in Atlas, a new database user, and\nsample data loaded into your cluster. This step shows how to create and run an application that uses the\nKotlin driver to connect to your MongoDB cluster and run a query on\nthe sample data. First, you must specify how the driver connects to your MongoDB cluster\nby including a  connection string  in your code. This string includes\ninformation on the hostname or IP address and port of your cluster,\nauthentication mechanism, user credentials, and other connection\noptions. If you are connecting to an instance or cluster that is not hosted on Atlas,\nsee the  Other Ways to Connect to MongoDB  section of the Connection Guide for\ninstructions on how to format your connection string. To retrieve your connection string for the cluster and user you created in\nthe previous step, log into your Atlas account and navigate to the\n Database  page under Deployment and click the\n Connect  button for your cluster, which is shown in the following\nimage: Select the  Drivers  option for connection and select\n Kotlin  from the list of drivers and  4.10 or\nlater  from the version dropdown. Next, click the  Copy  icon, which is highlighted in the\nfollowing image, to copy your  connection string  to\nyour clipboard: Save your Atlas connection string in a safe location that you can access\nfor the next step. Next, create a file called  QuickStartDataClassExample.kt  in your\nproject. Copy the following sample code into the file and replace the value of\nthe  uri  variable with your MongoDB Atlas connection string that you\nsaved in the preceding step. Replace the  \"<password>\"  placeholder of\nyour connection string with the password you set for your user that has\n atlasAdmin  permissions: When you run the  main  function, the application prints the details\nof a movie document that matches the query, as shown in the following output: If you don't see any output or receive an error, check whether you\nincluded the proper connection string in your application. Also, confirm\nthat you successfully loaded the sample dataset into your MongoDB Atlas cluster. After completing this step, you have a working application that uses\nthe Kotlin driver to connect to your MongoDB cluster, run a query on the\nsample data, and print out the result. This example uses a Kotlin data class to model MongoDB data. To learn more about using data classes to store and retrieve data,\nsee the  Document Data Format: Data Classes  guide. If you encounter the following error while connecting to your MongoDB\ninstance, you must update your JDK to the latest patch release: This exception is a known issue when using the TLS 1.3 protocol with\nspecific versions of JDK, but this issue is fixed for the following\nJDK versions: To resolve this error, update your JDK to one of the preceding patch\nversions or a newer one. JDK 11.0.7 JDK 13.0.3 JDK 14.0.2 The preceding section demonstrates how to run a query on a sample\ncollection to retrieve data by using a Kotlin data class. This section\nshows how to use the  Document  class\nto store and retrieve data from MongoDB. In a new file called  QuickStartDocumentExample.kt , paste the following sample\ncode to run a query on your sample dataset in MongoDB Atlas. Replace the\nvalue of the  uri  variable with your MongoDB Atlas connection string: When you run the  main  function, the application prints the details\nof a movie document that matches the query, as shown in the following output: If you don't see any output or receive an error, check whether you\nincluded the proper connection string in your application. Also, confirm\nthat you successfully loaded the sample dataset into your MongoDB Atlas cluster. To learn more about the Kotlin driver, see the\n Fundamentals  guides, which describe relevant\nconcepts in detail and provide code examples for performing different tasks.",
      "code": [
        {
          "lang": "kotlin",
          "value": "dependencies {\n    implementation(\"org.mongodb:mongodb-driver-kotlin-coroutine:5.1.2\")\n}"
        },
        {
          "lang": "xml",
          "value": "<dependencies>\n    <dependency>\n        <groupId>org.mongodb</groupId>\n        <artifactId>mongodb-driver-kotlin-coroutine</artifactId>\n        <version>5.1.2</version>\n    </dependency>\n</dependencies>"
        },
        {
          "lang": "kotlin",
          "value": "implementation(\"org.mongodb:bson-kotlinx:5.1.2\")\n// OR\nimplementation(\"org.mongodb:bson-kotlin:5.1.2\")"
        },
        {
          "lang": "xml",
          "value": "<dependency>\n    <groupId>org.mongodb</groupId>\n    <artifactId>bson-kotlinx</artifactId>\n    <version>5.1.2</version>\n</dependency>\n<!--OR-->\n<dependency>\n    <groupId>org.mongodb</groupId>\n    <artifactId>bson-kotlin</artifactId>\n    <version>5.1.2</version>\n</dependency>"
        },
        {
          "lang": "none",
          "value": "Movie(\n   title=Back to the Future,\n   year=1985,\n   cast=[Michael J. Fox, Christopher Lloyd, Lea Thompson, Crispin Glover]\n)"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Filters.eq\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport io.github.cdimascio.dotenv.dotenv\nimport kotlinx.coroutines.flow.firstOrNull\nimport kotlinx.coroutines.runBlocking\n\n// Create data class to represent a MongoDB document\ndata class Movie(val title: String, val year: Int, val cast: List<String>)\n\nfun main() {\n\n    // Replace the placeholder with your MongoDB deployment's connection string\n    val uri = CONNECTION_STRING_URI_PLACEHOLDER\n\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    // Get a collection of documents of type Movie\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    runBlocking {\n        val doc = collection.find(eq(\"title\", \"Back to the Future\")).firstOrNull()\n        if (doc != null) {\n            println(doc)\n        } else {\n            println(\"No matching documents found.\")\n        }\n    }\n\n    mongoClient.close()\n}\n\n"
        },
        {
          "lang": "none",
          "value": "javax.net.ssl.SSLHandshakeException: extension (5) should not be presented in certificate_request"
        },
        {
          "lang": "json",
          "value": "{\n  _id: ...,\n  plot: 'A young man is accidentally sent 30 years into the past...',\n  genres: [ 'Adventure', 'Comedy', 'Sci-Fi' ],\n  ...\n  title: 'Back to the Future',\n  ...\n}"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Filters.eq\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport io.github.cdimascio.dotenv.dotenv\nimport kotlinx.coroutines.flow.firstOrNull\nimport kotlinx.coroutines.runBlocking\nimport org.bson.Document\n\nfun main() {\n\n    // Replace the placeholder with your MongoDB deployment's connection string\n    val uri = CONNECTION_STRING_URI_PLACEHOLDER\n\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Document>(\"movies\")\n\n    runBlocking {\n        val doc = collection.find(eq(\"title\", \"Back to the Future\")).firstOrNull()\n        if (doc != null) {\n            println(doc.toJson())\n        } else {\n            println(\"No matching documents found.\")\n        }\n    }\n\n    mongoClient.close()\n}\n\n"
        }
      ],
      "preview": "This guide shows you how to create an application that uses the Kotlin driver\nto connect to a MongoDB Atlas cluster. If you prefer to connect to\nMongoDB by using a different driver or programming language, see the\nlist of official MongoDB drivers.",
      "tags": "code example, get started, runnable app",
      "facets": {
        "genre": ["tutorial"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/bulkWrite",
      "title": "Perform Bulk Operations",
      "headings": ["Example"],
      "paragraphs": "The  bulkWrite()  method performs batch write operations against a\n single  collection. This method reduces the number of network round trips from\nyour application to your MongoDB instance which increases the performance of your\napplication. Since you only receive the success status after\nall the operations return, we recommend you use this if that meets the\nrequirements of your use case. You can specify one or more of the following write operations in\n bulkWrite() : The  bulkWrite()  method accepts the following parameters: The  bulkWrite()  method returns a  BulkWriteResult  object that\ncontains information about the write operation results including the number\nof documents inserted, modified, and deleted. If one or more of your operations attempts to set a value that violates a\nunique index on your collection, an exception is raised that should look\nsomething like this: Similarly, if you attempt to perform a bulk write against a collection\nthat uses schema validation and one or more of your write operations\nprovide an unexpected format, you may encounter exceptions. insertOne updateOne updateMany deleteOne deleteMany replaceOne A  List  of objects that implement  WriteModel : the classes that\nimplement  WriteModel  correspond to the aforementioned write\noperations. For example, the  InsertOneModel  class wraps the  insertOne \nwrite operation. See the links to the API documentation at the bottom of this\npage for more information on each class. BulkWriteOptions :  optional  object that specifies settings such as\nwhether to ensure your MongoDB instance orders your write operations. Retryable writes run on MongoDB server versions 3.6 or later in bulk\nwrite operations unless they include one or more instances of\n UpdateManyModel  or  DeleteManyModel . By default, MongoDB executes bulk write operations one-by-one in the\nspecified order (i.e. serially). During an ordered bulk write, if\nan error occurs during the processing of an operation, MongoDB returns\nwithout processing the remaining operations in the list. In contrast,\nwhen you set  ordered  to  false , MongoDB continues to process remaining\nwrite operations in the list in the event of an error. Unordered operations\nare theoretically faster since MongoDB can execute them in parallel, but\nyou should only use them if your writes do not depend on order. The following code sample performs an ordered bulk write operation on the\n movies  collection in the  sample_mflix  database. The example call\nto  bulkWrite()  includes examples of the  InsertOneModel ,\n UpdateOneModel , and  DeleteOneModel . For additional information on the classes and methods mentioned on this\npage, see the following resources: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . Unique Index  Server Manual Entry Schema Validation  Server Manual Entry bulkWrite()  API Documentation BulkWriteOptions  API Documentation BulkWriteResult  API Documentation InsertOneModel  API Documentation UpdateOneModel  API Documentation UpdateManyModel  API Documentation DeleteOneModel  API Documentation DeleteManyModel  API Documentation ReplaceOneModel  API Documentation",
      "code": [
        {
          "lang": "sh",
          "value": "The bulk write operation failed due to an error: Bulk write operation error on server <hostname>. Write errors: [BulkWriteError{index=0, code=11000, message='E11000 duplicate key error collection: ... }]."
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.MongoException\nimport com.mongodb.client.model.DeleteOneModel\nimport com.mongodb.client.model.Filters\nimport com.mongodb.client.model.InsertOneModel\nimport com.mongodb.client.model.ReplaceOneModel\nimport com.mongodb.client.model.UpdateOneModel\nimport com.mongodb.client.model.UpdateOptions\nimport com.mongodb.client.model.Updates\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\n\ndata class Movie(val title: String, val runtime: Int? = null)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    try {\n        val result = collection.bulkWrite(\n            listOf(\n                InsertOneModel(Movie(\"A Sample Movie\")),\n                InsertOneModel(Movie(\"Another Sample Movie\")),\n                InsertOneModel(Movie(\"Yet Another Sample Movie\")),\n                UpdateOneModel(\n                    Filters.eq(Movie::title.name,\"A Sample Movie\"),\n                    Updates.set(Movie::title.name, \"An Old Sample Movie\"),\n                    UpdateOptions().upsert(true)\n                ),\n                DeleteOneModel(Filters.eq(\"title\", \"Another Sample Movie\")),\n                ReplaceOneModel(\n                    Filters.eq(Movie::title.name, \"Yet Another Sample Movie\"),\n                    Movie(\"The Other Sample Movie\", 42)\n                )\n            )\n        )\n        println(\n            \"\"\"\n            Result statistics:\n            inserted: ${result.insertedCount}\n            updated: ${result.modifiedCount}\n            deleted: ${result.deletedCount}\n            \"\"\".trimIndent()\n        )\n    } catch (e: MongoException) {\n        System.err.println(\"The bulk write operation failed due to an error: $e\")\n    }\n    mongoClient.close()\n}\n"
        },
        {
          "lang": "console",
          "value": "Result statistics:\ninserted: 3\nupdated: 2\ndeleted: 1"
        }
      ],
      "preview": "The bulkWrite() method performs batch write operations against a\nsingle collection. This method reduces the number of network round trips from\nyour application to your MongoDB instance which increases the performance of your\napplication. Since you only receive the success status after\nall the operations return, we recommend you use this if that meets the\nrequirements of your use case.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/command",
      "title": "Run a Command",
      "headings": ["Example"],
      "paragraphs": "You can run all raw database operations using the\n MongoDatabase.runCommand()  method. A raw database operation is a\ncommand you can execute directly on the MongoDB server CLI. These\ncommands include administrative and diagnostic tasks, such as fetching\nserver stats or initializing a replica set. Call the  runCommand() \nmethod with a  Bson  command object on an instance of a  MongoDatabase \nto run your raw database operation. The  runCommand()  method accepts a command in the form of a  Bson  object.\nBy default,  runCommand  returns an object of type\n org.bson.Document  containing the output of the database command. You\ncan specify a return type for  runCommand()  as an optional second\nparameter. Use the  MongoDB Shell  for\nadministrative tasks instead of the Kotlin driver whenever possible,\nsince these tasks are often quicker and easier to implement with the\nshell than in a Kotlin application. In the following sample code, we send the  dbStats  command to request\nstatistics from a specific MongoDB database. For additional information on the classes and methods mentioned on this\npage, see the following resources: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . runCommand()  API Documentation Database Commands  Server Manual Entry dbStats  Server Manual Entry",
      "code": [
        {
          "lang": "kotlin",
          "value": "\nimport com.mongodb.MongoException\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\nimport org.bson.BsonDocument\nimport org.bson.BsonInt64\nimport org.bson.json.JsonWriterSettings\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    try {\n        val command = BsonDocument(\"dbStats\", BsonInt64(1))\n        val commandResult = database.runCommand(command)\n        println(commandResult.toJson(JsonWriterSettings.builder().indent(true).build()))\n    } catch (me: MongoException) {\n        System.err.println(\"An error occurred: $me\")\n    }\n    mongoClient.close()\n}\n"
        },
        {
          "lang": "json",
          "value": "{\n  \"db\": \"sample_mflix\",\n  \"collections\": 5,\n  \"views\": 0,\n  \"objects\": 75595,\n  \"avgObjSize\": 692.1003770090614,\n  \"dataSize\": 52319328,\n  \"storageSize\": 29831168,\n  \"numExtents\": 0,\n  \"indexes\": 9,\n  \"indexSize\": 14430208,\n  \"fileSize\": 0,\n  \"nsSizeMB\": 0,\n  \"ok\": 1\n}"
        }
      ],
      "preview": "You can run all raw database operations using the\nMongoDatabase.runCommand() method. A raw database operation is a\ncommand you can execute directly on the MongoDB server CLI. These\ncommands include administrative and diagnostic tasks, such as fetching\nserver stats or initializing a replica set. Call the runCommand()\nmethod with a Bson command object on an instance of a MongoDatabase\nto run your raw database operation.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/count",
      "title": "Count Documents",
      "headings": ["Example"],
      "paragraphs": "There are two instance methods in the  MongoCollection  class that you can\ncall to count the number of documents in a collection: The  estimatedDocumentCount()  method returns more quickly than the\n countDocuments()  method because it uses the collection's metadata rather\nthan scanning the entire collection. The  countDocuments()  method returns\nan accurate count of the number of documents and supports specifying\na filter. When you call the  countDocuments()  method, you can optionally pass a\n query filter  parameter. You cannot pass any parameters when you call\n estimatedDocumentCount() . You can also pass an optional parameter to either of these methods to\nspecify the behavior of the call: Both methods return the number of matching documents as a  Long  primitive. countDocuments()  returns an  accurate  count of the number of documents\nin the collection that match a specified query. If you specify an empty query\nfilter, the method returns the total number of documents in the collection. estimatedDocumentCount()  returns an  estimation  of the number of\ndocuments in the collection based on the collection metadata. You cannot\nspecify a query when using this method. When using  countDocuments()  to return the total number of documents in a\ncollection, you can improve performance by avoiding a collection scan. To do\nthis, use a  hint  to take advantage\nof the built-in index on the  _id  field. Use this technique only when\ncalling  countDocuments()  with an empty query parameter: If you are using the Stable API  V1  with the \"strict\" option and a\nMongoDB server version between 5.0.0 and 5.0.8 inclusive, method calls to\n estimatedDocumentCount()  may error due to a server bug. Upgrade to MongoDB server 5.0.9 or set the Stable API \"strict\" option to\n false  to avoid this issue. Method Optional Parameter Class Description countDocuments() CountOptions You can specify a maximum number of documents to count by using the\n limit()  method or the maximum amount of execution time using the\n maxTime()  method. estimatedDocumentCount() EstimatedDocumentCountOptions You can specify the maximum execution time using the  maxTime() \nmethod. The following example estimates the number of documents in the\n movies  collection in the  sample_mflix  database, and then returns\nan accurate count of the number of documents in the  movies \ncollection with  Spain  in the  countries  field.\nIf you run the preceding sample code, you should see output that looks something\nlike this (exact numbers may vary depending on your data): For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . countDocuments() estimatedDocumentCount() CountOptions EstimatedDocumentCountOptions",
      "code": [
        {
          "lang": "kotlin",
          "value": "val options = CountOptions().hintString(\"_id_\")\nval numDocuments = collection.countDocuments(BsonDocument(), options)\n"
        },
        {
          "lang": "kotlin",
          "value": "\nimport com.mongodb.MongoException\nimport com.mongodb.client.model.Filters\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\n\n\ndata class Movie(val countries: List<String>)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n\n    val query = Filters.eq(Movie::countries.name, \"Spain\")\n    try {\n        val estimatedCount = collection.estimatedDocumentCount()\n        println(\"Estimated number of documents in the movies collection: $estimatedCount\")\n        val matchingCount = collection.countDocuments(query)\n        println(\"Number of movies from Spain: $matchingCount\")\n    } catch (e: MongoException) {\n        System.err.println(\"An error occurred: $e\")\n    }\n\n    mongoClient.close()\n}\n"
        },
        {
          "lang": "console",
          "value": "Estimated number of documents in the movies collection: 23541\nNumber of movies from Spain: 755"
        }
      ],
      "preview": "There are two instance methods in the MongoCollection class that you can\ncall to count the number of documents in a collection:",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/delete-operations",
      "title": "Delete Operations",
      "headings": [],
      "paragraphs": "Delete a Document Delete Multiple Documents",
      "code": [],
      "preview": null,
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/deleteMany",
      "title": "Delete Multiple Documents",
      "headings": ["Example"],
      "paragraphs": "You can delete multiple documents from a collection in a single operation\nby calling the  deleteMany()  method on a  MongoCollection  object. To specify which documents to delete, pass a query filter that matches\nthe documents you want to delete. If you provide an empty document,\nMongoDB matches all documents in the collection and deletes them. While\nyou can use  deleteMany()  to delete all documents in a collection,\nconsider using the  drop()  method instead for better performance. Upon successful deletion, this method returns an instance of\n DeleteResult . You can retrieve information such as the number of\ndocuments deleted by calling the  getDeletedCount()  method on the\n DeleteResult  instance. If your delete operation fails, the driver raises an exception. For more\ninformation on the types of exceptions raised under specific conditions,\nsee the API documentation for  deleteMany() , linked at the bottom of\nthis page. The following snippet deletes multiple documents from the  movies \ncollection in the  sample_mflix  database. The query filter passed to the  deleteMany()  method matches all\nmovie documents that contain a  rating  of less than  2.9  in the  imdb \nsub-document. When you run the example, you should see output that reports the number of\ndocuments deleted in your call to  deleteMany() . For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . deleteMany() DeleteResult drop()",
      "code": [
        {
          "lang": "kotlin",
          "value": "\nimport com.mongodb.MongoException\nimport com.mongodb.client.model.Filters\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\n\ndata class Movie(val imdb: IMDB){\n    data class IMDB(val rating: Double)\n}\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    val query = Filters.lt(\"${Movie::imdb.name}.${Movie.IMDB::rating.name}\", 2.9)\n    try {\n        val result = collection.deleteMany(query)\n        println(\"Deleted document count: \" + result.deletedCount)\n    } catch (e: MongoException) {\n        System.err.println(\"Unable to delete due to an error: $e\")\n    }\n    mongoClient.close()\n}\n"
        },
        {
          "lang": "console",
          "value": "Deleted document count: 4"
        }
      ],
      "preview": "You can delete multiple documents from a collection in a single operation\nby calling the deleteMany() method on a MongoCollection object.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/deleteOne",
      "title": "Delete a Document",
      "headings": ["Example"],
      "paragraphs": "You can delete a single document from a collection using the  deleteOne() \nmethod on a  MongoCollection  object. The method accepts a query filter\nthat matches the document you want to delete. If you do not specify\na filter, MongoDB matches the first document in the collection. The\n deleteOne()  method only deletes the first document matched. This method returns an instance of  DeleteResult  which contains information\nincluding how many documents were deleted as a result of the operation. If your delete operation fails, the driver raises an exception. For more\ninformation on the types of exceptions raised under specific conditions,\nsee the API documentation for  deleteOne() , linked at the bottom of\nthis page. The following snippet deletes a single document from the  movies \ncollection of the  sample_mflix  database. The example uses the  eq() \nfilter to match movies with the  title  exactly matching the text\n 'The Garbage Pail Kids Movie' . When you run the example, if the query filter you passed in your call to\n deleteOne()  matches a document and removes it, you should see output\nthat looks something like this: If your query filter does not match a document in your collection,\nyour call to  deleteOne()  removes no documents and returns the following: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . deleteOne() DeleteResult eq()",
      "code": [
        {
          "lang": "none",
          "value": "Deleted document count: 1"
        },
        {
          "lang": "none",
          "value": "Deleted document count: 0"
        },
        {
          "lang": "kotlin",
          "value": "\nimport com.mongodb.MongoException\nimport com.mongodb.client.model.Filters\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\n\n\ndata class Movie(val title: String)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    val query = Filters.eq(Movie::title.name, \"The Garbage Pail Kids Movie\")\n\n    try {\n        val result = collection.deleteOne(query)\n        println(\"Deleted document count: \" + result.deletedCount)\n    } catch (e: MongoException) {\n        System.err.println(\"Unable to delete due to an error: $e\")\n    }\n    mongoClient.close()\n}\n"
        }
      ],
      "preview": "You can delete a single document from a collection using the deleteOne()\nmethod on a MongoCollection object. The method accepts a query filter\nthat matches the document you want to delete. If you do not specify\na filter, MongoDB matches the first document in the collection. The\ndeleteOne() method only deletes the first document matched.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/distinct",
      "title": "Retrieve Distinct Values of a Field",
      "headings": ["Example"],
      "paragraphs": "You can retrieve a list of distinct values for a field across a\ncollection by calling the  distinct()  method on a  MongoCollection \nobject. Pass the document field name as the first parameter and the class\nyou want to cast the results to as the type parameter. The following snippets demonstrate the  distinct()  method using the  movies \ncollection in the  sample_mflix  sample database. Documents are modeled\nwith the following Kotlin data class: The following method call returns each distinct value of the  countries \nfield in the  movies  collection: You can specify a field on the document or one within an  embedded document \nusing  dot notation . The following method call returns each distinct\nvalue of the  wins  field in the  awards  embedded document: You can also limit the set of documents from which your MongoDB instance retrieves\ndistinct values with a query filter as a second parameter, as follows: The  distinct()  method returns an object that implements the\n DistinctFlow  class, which contains methods to access, organize, and traverse\nthe results.  DistinctFlow  delegates to the  Flow  interface\nfrom the Kotlin Coroutines library, allowing access to methods such as  first()  and\n firstOrNull() . For more information, see our\n guide on Accessing Data From a Flow . The following example retrieves a list of distinct values for the  year \ndocument field from the  movies  collection. It uses a query filter to\nmatch movies that include \"Carl Franklin\" as one of the values in the\n directors  array. When you run the example, you should see output that reports each distinct\nyear for all the movies that Carl Franklin was included as a director. For additional information on the classes and methods mentioned on this\npage, see the following resources: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . distinct()  API Documentation distinctFlow  API Documentation Dot Notation  Server Manual Entry",
      "code": [
        {
          "lang": "kotlin",
          "value": "data class Movie(\n    val type: String,\n    val languages: List<String>,\n    val countries: List<String>,\n    val awards: Awards){\n        data class Awards(val wins: Int)\n    }\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.distinct<String>(Movie::countries.name)\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.distinct<Int>(\"${Movie::awards.name}.${Movie.Awards::wins.name}\")\n"
        },
        {
          "lang": "kotlin",
          "value": "collection.distinct<String>(Movie::type.name, Filters.eq(Movie::languages.name, \"French\"))\n"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.MongoException\nimport com.mongodb.client.model.Filters\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\n\ndata class Movie(val year: Int, val directors: List<String>)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    try {\n        val resultsFlow = collection.distinct<Int>(\n            Movie::year.name, Filters.eq(Movie::directors.name, \"Carl Franklin\")\n        )\n        resultsFlow.collect { println(it) }\n    } catch (e: MongoException) {\n        System.err.println(\"An error occurred: $e\")\n    }\n\n    mongoClient.close()\n}\n"
        },
        {
          "lang": "console",
          "value": "1992\n1995\n1998\n..."
        }
      ],
      "preview": "You can retrieve a list of distinct values for a field across a\ncollection by calling the distinct() method on a MongoCollection\nobject. Pass the document field name as the first parameter and the class\nyou want to cast the results to as the type parameter.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/find-operations",
      "title": "Find Operations",
      "headings": [],
      "paragraphs": "Find a Document Find Multiple Documents",
      "code": [],
      "preview": null,
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/find",
      "title": "Find Multiple Documents",
      "headings": ["Example"],
      "paragraphs": "You can query for multiple documents in a collection by calling the  find() \nmethod on a  MongoCollection  object. Pass a query filter to the\n find()  method to query for and return documents that match the filter in\nthe collection. If you do not include a filter, MongoDB returns all the\ndocuments in the collection. For more information on querying MongoDB with the Kotlin driver, see our\n guide on Querying Documents . You can also chain methods to the  find()  method such as  sort()  which\norganizes the matched documents in a specified order and\n projection()  which configures the included fields in the\nreturned documents. For more information on the  sort()  method, see our\n guide on Sorting .\nFor more information on the  projection()  method, see our\n guide on Projections The  find()  method returns an instance of  FindFlow , a class\nthat offers several methods to access, organize, and traverse the results. FindFlow  also obtains methods from its delegate interface  Flow  from the\nKotlin Coroutines library.\nYou can call the  collect()  method to iterate through the fetched results.\nYou can also call terminal methods, such as  firstOrNull()  to return either\nthe first document or  null  if there are no results, or  first()  to return\nthe first document in the collection. If no documents match the query,\ncalling  first()  throws a  NoSuchElementException  exception. For more information on accessing data from a flow with the Kotlin driver, see our\n guide on Accessing Data From a Flow . The following snippet finds and prints all documents that match a query on\nthe  movies  collection. It uses the following objects and methods: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: A  query filter  that is passed to the  find()  method. The  lt() \nfilter matches only movies with a runtime of less than 15 minutes. A  sort  that organizes returned documents in descending order by\ntitle (\"Z\" before \"A\"). A  projection  that includes the objects in the  title  and  imdb \nfields and excludes the  _id  field using the helper method\n excludeId() . This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . FindFlow find()",
      "code": [
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Filters.lt\nimport com.mongodb.client.model.Projections\nimport com.mongodb.client.model.Sorts\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\n\ndata class Movie(val title: String, val runtime: Int, val imdb: IMDB){\n    data class IMDB(val rating: Double)\n}\n\ndata class Results(val title: String)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    val projectionFields= Projections.fields(\n        Projections.include(Movie::title.name, Movie::imdb.name),\n        Projections.excludeId()\n    )\n    val resultsFlow = collection.withDocumentClass<Results>()\n        .find(lt(Movie::runtime.name, 15))\n        .projection(projectionFields)\n        .sort(Sorts.descending(Movie::title.name))\n\n    resultsFlow.collect { println(it) }\n\n    mongoClient.close()\n}\n"
        }
      ],
      "preview": "You can query for multiple documents in a collection by calling the find()\nmethod on a MongoCollection object. Pass a query filter to the\nfind() method to query for and return documents that match the filter in\nthe collection. If you do not include a filter, MongoDB returns all the\ndocuments in the collection.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/findOne",
      "title": "Find a Document",
      "headings": ["Example"],
      "paragraphs": "You can retrieve a single document in a collection by chaining together\nthe  find()  and  first()  methods on a  MongoCollection  object.\nYou can pass a query filter to the  find()  method to query for and\nreturn documents that match the filter in the collection. If you do not\ninclude a filter, MongoDB returns all the documents in the collection. For more information on querying MongoDB with the Kotlin driver, see our\n guide on Querying Documents . You can also chain other methods to the  find()  method\nsuch as  sort()  which organizes the matched documents in a specified order, and\n projection()  which configures the fields included in the returned documents. For more information on the  sort()  method, see our\n guide on Sorting .\nFor more information on the  projection()  method, see our\n guide on Projections The  find()  method returns an instance of  FindFlow , a class\nthat offers several methods to access, organize, and traverse the results. FindFlow  also obtains methods from its delegate interface  Flow  from the\nKotlin Coroutines library, such as  first()  and  firstOrNull() .\nThe  firstOrNull()  method returns the first document from the retrieved results\nor  null  if there are no results. The  first()  method returns\nthe first document or throws a  NoSuchElementException  exception if no\ndocuments match the query. For more information on accessing data from a flow with the Kotlin driver, see our\n guide on Accessing Data From a Flow . The following snippet finds a single document from the  movies  collection.\nIt uses the following objects and methods: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: A  query filter  that is passed to the  find()  method. The  eq \nfilter matches only movies with the title exactly matching the text\n \"The Room\" . A  sort  that organizes matched documents in descending order by\nrating, so if our query matches multiple documents the returned\ndocument is the one with the highest rating. A  projection  that includes the objects in the  title  and  imdb \nfields and excludes the  _id  field using the helper method\n excludeId() . This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . FindFlow find()",
      "code": [
        {
          "lang": "kotlin",
          "value": "import com.mongodb.client.model.Filters.eq\nimport com.mongodb.client.model.Filters.lt\nimport com.mongodb.client.model.Projections\nimport com.mongodb.client.model.Sorts\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.flow.firstOrNull\nimport kotlinx.coroutines.runBlocking\nimport usageExamples.find.Results\n\ndata class Movie(val title: String, val runtime: Int, val imdb: IMDB) {\n    data class IMDB(val rating: Double)\n}\n\ndata class Results(val title: String, val imdb: Movie.IMDB)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    val projectionFields= Projections.fields(\n        Projections.include(Movie::title.name, Movie::imdb.name),\n        Projections.excludeId()\n    )\n    val resultsFlow = collection.withDocumentClass<Results>()\n        .find(eq(Movie::title.name, \"The Room\"))\n        .projection(projectionFields)\n        .sort(Sorts.descending(\"${Movie::imdb.name}.${Movie.IMDB::rating.name}\"))\n        .firstOrNull()\n\n    if (resultsFlow == null) {\n        println(\"No results found.\");\n    } else {\n        println(resultsFlow)\n    }\n\n    mongoClient.close()\n}\n"
        }
      ],
      "preview": "You can retrieve a single document in a collection by chaining together\nthe find() and first() methods on a MongoCollection object.\nYou can pass a query filter to the find() method to query for and\nreturn documents that match the filter in the collection. If you do not\ninclude a filter, MongoDB returns all the documents in the collection.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/insert-operations",
      "title": "Insert Operations",
      "headings": [],
      "paragraphs": "Insert a Document Insert Multiple Documents",
      "code": [],
      "preview": null,
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/insertMany",
      "title": "Insert Multiple Documents",
      "headings": ["Example"],
      "paragraphs": "You can insert multiple documents into a collection in a single\noperation by calling the  insertMany()  method on a  MongoCollection \nobject. To insert them, add your  Document  objects to a  List  and pass\nthat  List  as an argument to  insertMany() . If you call the  insertMany()  method\non a collection that does not exist yet, the server creates it for you. Upon successful insertion,  insertMany()  returns an instance of\n InsertManyResult . You can retrieve information such as the  _id \nfields of the documents you inserted by calling the  getInsertedIds() \nmethod on the  InsertManyResult  instance. If your insert operation fails, the driver raises an exception. For more\ninformation on the types of exceptions raised under specific conditions,\nsee the API documentation for  insertMany() , linked at the bottom of\nthis page. The following snippet inserts multiple documents into the  movies \ncollection. When you run the example, you should see output with the inserted documents'\n ObjectId  values in each of the value fields: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . insertMany() Document InsertManyResult",
      "code": [
        {
          "lang": "kotlin",
          "value": "import com.mongodb.MongoException\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\n\ndata class Movie(val title: String)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    val movieList = listOf(\n        Movie(\"Short Circuit 3\"),\n        Movie(\"The Lego Frozen Movie\")\n    )\n\n    try {\n        val result = collection.insertMany(movieList)\n        println(\"Success! Inserted document ids: \" + result.insertedIds)\n    } catch (e: MongoException) {\n        System.err.println(\"Unable to insert due to an error: $e\")\n    }\n    mongoClient.close()\n}\n"
        },
        {
          "lang": "console",
          "value": "Success! Inserted document ids: {0=BsonObjectId{value=...}, 1=BsonObjectId{value=...}}"
        }
      ],
      "preview": "You can insert multiple documents into a collection in a single\noperation by calling the insertMany() method on a MongoCollection\nobject. To insert them, add your Document objects to a List and pass\nthat List as an argument to insertMany(). If you call the insertMany() method\non a collection that does not exist yet, the server creates it for you.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/insertOne",
      "title": "Insert a Document",
      "headings": ["Example"],
      "paragraphs": "You can insert a single document into a collection using the  insertOne() \nmethod on a  MongoCollection  object. To insert a document, construct a\n Document  object that contains the fields and values that you want to\nstore. If you call the  insertOne()  method on a collection that does\nnot exist yet, the server automatically creates it for you. Upon a successful insertion,  insertOne()  returns an instance of\n InsertOneResult . You can retrieve information such as the  _id \nfield of the document you inserted by calling the  getInsertedId() \nmethod on the  InsertOneResult  instance. If your insert operation fails, the driver raises an exception. For more\ninformation on the types of exceptions raised under specific conditions,\nsee the API documentation for  insertOne() , linked at the bottom of\nthis page. The following snippet inserts a single document into the  movies \ncollection. When you run the example, you should see output with the inserted document's\n ObjectId  in the value field: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . insertOne() Document InsertOneResult",
      "code": [
        {
          "lang": "kotlin",
          "value": "import com.mongodb.MongoException\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\nimport org.bson.codecs.pojo.annotations.BsonId\nimport org.bson.types.ObjectId\n\ndata class Movie(@BsonId val id: ObjectId, val title: String, val genres: List<String>)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    try {\n        val result = collection.insertOne(\n            Movie(ObjectId(), \"Ski Bloopers\", listOf(\"Documentary\", \"Comedy\"))\n        )\n        println(\"Success! Inserted document id: \" + result.insertedId)\n    } catch (e: MongoException) {\n        System.err.println(\"Unable to insert due to an error: $e\")\n    }\n    mongoClient.close()\n}\n"
        },
        {
          "lang": "console",
          "value": "Success! Inserted document id: BsonObjectId{value=...}"
        }
      ],
      "preview": "You can insert a single document into a collection using the insertOne()\nmethod on a MongoCollection object. To insert a document, construct a\nDocument object that contains the fields and values that you want to\nstore. If you call the insertOne() method on a collection that does\nnot exist yet, the server automatically creates it for you.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/replaceOne",
      "title": "Replace a Document",
      "headings": ["Example"],
      "paragraphs": "You can replace a single document using the  replaceOne()  method on\na  MongoCollection  object. This method removes all the existing fields\nand values from a document (except the  _id  field) and substitutes it\nwith your replacement document. The  replaceOne()  method accepts a query filter that matches the\ndocument you want to replace and a replacement document that contains the\ndata you want to save in place of the matched document. The  replaceOne() \nmethod only replaces the first document that matches the filter. You can optionally pass an instance of  ReplaceOptions  to the  replaceOne()  method in\norder to specify the method's behavior. For example, if you set the  upsert \nfield of the  ReplaceOptions  object to  true , the operation inserts\na new document from the fields in the replacement document if no documents\nmatch the query filter. See the link to the  ReplaceOptions  API\ndocumentation at the bottom of this page for more information. Upon successful execution, the  replaceOne()  method returns an instance\nof  UpdateResult .  You can retrieve information such as the number of\ndocuments modified by calling the  getModifiedCount()  method. You can also\nretrieve the value of the document's  _id  field by calling the\n getUpsertedId()  method if you set  upsert(true)  in the\n ReplaceOptions  instance and the operation resulted in the insertion of a new document. If your replacement operation fails, the driver raises an exception.\nFor example, if you try to specify a value for the immutable field\n _id  in your replacement document that differs from the original\ndocument, the method throws a  MongoWriteException  with the message: If your replacement document contains a change that violates unique index\nrules, the method throws a  MongoWriteException  with an error\nmessage that should look something like this: For more information on the types of exceptions raised under specific\nconditions, see the API documentation for  replaceOne() , linked at the\nbottom of this page. In this example, we replace the first match of our query filter in the\n movies  collection of the  sample_mflix  database with a replacement\ndocument. All the fields except for the  _id  field are deleted from the\noriginal document and are substituted by the replacement document. Before the  replaceOne()  operation runs, the original document contains\nseveral fields describing the movie. After the operation runs, the resulting\ndocument contains only the fields specified by the replacement document\n( title  and  fullplot ) and the  _id  field. The following snippet uses the following objects and methods: After you run the example, you should see output that looks something like\nthis: Or if the example resulted in an upsert: If you query the replaced document, it should look something like this: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: A  query filter  that is passed to the  replaceOne()  method. The  eq \nfilter matches only movies with the title exactly matching the text\n 'Music of the Heart' . A  replacement document  that contains the document that replaces the\nmatching document if it exists. A  ReplaceOptions  object with the  upsert  option set to  true .\nThis option specifies that the method should insert the data contained in\nthe replacement document if the query filter does not match any documents. This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . ReplaceOne ReplaceOptions UpdateResult eq()",
      "code": [
        {
          "lang": "none",
          "value": "After applying the update, the (immutable) field '_id' was found to have been altered to _id: ObjectId('...)"
        },
        {
          "lang": "none",
          "value": "E11000 duplicate key error collection: ..."
        },
        {
          "lang": "none",
          "value": "Modified document count: 1\nUpserted id: null"
        },
        {
          "lang": "none",
          "value": "Modified document count: 0\nUpserted id: BsonObjectId{value=...}"
        },
        {
          "lang": "none",
          "value": "Movie(title=50 Violins, fullplot= A dramatization of the true story of Roberta Guaspari who co-founded the Opus 118 Harlem School of Music)"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.MongoException\nimport com.mongodb.client.model.Filters\nimport com.mongodb.client.model.ReplaceOptions\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\n\ndata class Movie(val title: String, val fullplot: String)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    try {\n        val query = Filters.eq(\"title\", \"Music of the Heart\")\n        val replaceDocument = Movie( \"50 Violins\", \" A dramatization of the true story of Roberta Guaspari who co-founded the Opus 118 Harlem School of Music\")\n        val options = ReplaceOptions().upsert(true)\n        val result = collection.replaceOne(query, replaceDocument, options)\n        println(\"Modified document count: \" + result.modifiedCount)\n        println(\"Upserted id: \" + result.upsertedId) // only contains a non-null value when an upsert is performed\n    } catch (e: MongoException) {\n        System.err.println(\"Unable to replace due to an error: $e\")\n    }\n    mongoClient.close()\n}\n"
        }
      ],
      "preview": "You can replace a single document using the replaceOne() method on\na MongoCollection object. This method removes all the existing fields\nand values from a document (except the _id field) and substitutes it\nwith your replacement document.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/update-operations",
      "title": "Update & Replace Operations",
      "headings": [],
      "paragraphs": "Update a Document Update Multiple Documents Replace a Document",
      "code": [],
      "preview": null,
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/updateMany",
      "title": "Update Multiple Documents",
      "headings": ["Example"],
      "paragraphs": "You can update multiple documents using the  updateMany()  method on\na  MongoCollection  object. The method accepts a  filter  that matches the\ndocument you want to update and an  update  statement that instructs the\ndriver how to change the matching document. The  updateMany()  method updates\nall the documents in the collection that match the filter. To perform an update with the  updateMany()  method, you must pass\na query filter and an update document. The query filter specifies which\ndocuments in the collection to match and the update document provides\ninstructions on what changes to make to them. You can optionally pass an instance of  UpdateOptions  to the  updateMany()  method in\norder to modify the behavior of the call. For example, if you set the\n upsert  field of the  UpdateOptions  object to  true  and no documents\nmatch the specified query filter, the operation inserts a new document\ncomposed of the fields from both the query and update document. Upon successful execution, the  updateMany()  method returns an instance\nof  UpdateResult . You can retrieve information such as the number of\ndocuments modified by calling the  getModifiedCount()  method. If you\nspecified  upsert(true)  in an  UpdateOptions  object and the\noperation results in an insert, you can retrieve the  _id  field of the\nnew document by calling the  getUpsertedId()  method on the\n UpdateResult  instance. If your update operation fails, the driver raises an exception and does not update\nany of the documents matching the filter. For example, if you try to set\na value for the immutable field  _id  in your update document, the\n updateMany()  method does not update any documents and throws a\n MongoWriteException  with the message: If your update document contains a change that violates unique index\nrules, the method throws a  MongoWriteException  with an error\nmessage that should look something like this: For more information on the types of exceptions raised under specific\nconditions, see the API documentation for  updateMany() , linked at the\nbottom of this page. In this example, we use a  Filter  builder to filter our query for\nmovies in the genre \"Frequently Discussed\". Next, we update documents that match our query in the  movies  collection of the\n sample_mflix  database. We perform the following\nupdates to the matching documents: We use the  Updates  builder, a factory class that contains static\nhelper methods to construct the update document. While you can pass an update\ndocument instead of using the builder, the builder provides type checking and\nsimplified syntax. Read our\n guide on Updates  in the Builders\nsection for more information. After you run the example, you should see a similar output. If you query the updated document or documents, they should look something like\nthis: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: Add  Frequently Discussed  to the array of  genres  only if it does not\nalready exist Set the value of  lastUpdated  to the current time. This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . UpdateMany UpdateOptions combine() addToSet() currentDate() UpdateResult",
      "code": [
        {
          "lang": "none",
          "value": "Performing an update on the path '_id' would modify the immutable field '_id'"
        },
        {
          "lang": "none",
          "value": "E11000 duplicate key error collection: ..."
        },
        {
          "lang": "none",
          "value": "Movie(num_mflix_comments=100, genres=[ ... Frequently Discussed], lastUpdated= ... )"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.MongoException\nimport com.mongodb.client.model.Filters\nimport com.mongodb.client.model.Updates\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\nimport java.time.LocalDateTime\n\ndata class Movie(\n    val num_mflix_comments: Int,\n    val genres: List<String>,\n    val lastUpdated: LocalDateTime\n)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    val query = Filters.gt(Movie::num_mflix_comments.name, 50)\n    val updates = Updates.combine(\n        Updates.addToSet(Movie::genres.name, \"Frequently Discussed\"),\n        Updates.currentDate(Movie::lastUpdated.name)\n    )\n    try {\n        val result = collection.updateMany(query, updates)\n        println(\"Modified document count: \" + result.modifiedCount)\n    } catch (e: MongoException) {\n        System.err.println(\"Unable to update due to an error: $e\")\n    }\n    mongoClient.close()\n}\n"
        },
        {
          "lang": "console",
          "value": "Modified document count: 53"
        }
      ],
      "preview": "You can update multiple documents using the updateMany() method on\na MongoCollection object. The method accepts a filter that matches the\ndocument you want to update and an update statement that instructs the\ndriver how to change the matching document. The updateMany() method updates\nall the documents in the collection that match the filter.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/updateOne",
      "title": "Update a Document",
      "headings": ["Example"],
      "paragraphs": "You can update a single document using the  updateOne()  method on\na  MongoCollection  object. The method accepts a  filter  that matches the\ndocument you want to update and an  update  statement that instructs the\ndriver how to change the matching document. The  updateOne()  method only\nupdates the first document that matches the filter. To perform an update with the  updateOne()  method, you must pass\na query filter and an update document. The query filter specifies the criteria\nfor which document to perform the update on and the update document provides\ninstructions on what changes to make to it. You can optionally pass an instance of  UpdateOptions  to the  updateOne()  method in\norder to specify the method's behavior. For example, if you set the  upsert  field of\nthe  UpdateOptions  object to  true , the operation inserts a new\ndocument from the fields in both the query and update document if no documents\nmatch the query filter. See the link to the  UpdateOptions  API\ndocumentation at the bottom of this page for more information. Upon successful execution, the  updateOne()  method returns an instance\nof  UpdateResult .  You can retrieve information such as the number of\ndocuments modified by calling the  getModifiedCount()  method, or the\nvalue of the  _id  field by calling the  getUpsertedId()  method if you\nspecified  upsert(true)  in an  UpdateOptions  instance. If your update operation fails, the driver raises an exception.\nFor example, if you try to set a value for the immutable field  _id  in\nyour update document, the method throws a  MongoWriteException  with the\nmessage: If your update document contains a change that violates unique index\nrules, the method throws a  MongoWriteException  with an error\nmessage that should look something like this: For more information on the types of exceptions raised under specific\nconditions, see the  updateOne()  API documentation linked at the\nbottom of this page. In this example, we use a  Filter  builder to query the collection for\na movie with the title \"Cool Runnings 2\". Next, we perform the following updates to the first match for our query\nin the  movies  collection of the  sample_mflix  database: We use the  Updates  builder, a factory class that contains static\nhelper methods, to construct the update document. While you can pass an update\ndocument instead of using the builder, the builder provides type checking and\nsimplified syntax. See the  guide on the Updates builder \nfor more information. After you run the example, you should see output that looks something like this: Or if the example resulted in an upsert: If you query the updated document, it should look something like this: For additional information on the classes and methods mentioned on this\npage, see the following API Documentation: Set the value of  runtime  to  99 Add  Sports  to the array of  genres  only if it does not already exist Set the value of  lastUpdated  to the current time This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . UpdateOne UpdateOptions combine() set() addToSet() currentDate() UpdateResult",
      "code": [
        {
          "lang": "none",
          "value": "Performing an update on the path '_id' would modify the immutable field '_id'"
        },
        {
          "lang": "none",
          "value": "E11000 duplicate key error collection: ..."
        },
        {
          "lang": "none",
          "value": "Modified document count: 1\nUpserted id: null"
        },
        {
          "lang": "none",
          "value": "Modified document count: 0\nUpserted id: BsonObjectId{value=...}"
        },
        {
          "lang": "none",
          "value": "Movie(title=Cool Runnings 2, runtime=99, genres=[ ... Sports], lastUpdated= ... )"
        },
        {
          "lang": "kotlin",
          "value": "import com.mongodb.MongoException\nimport com.mongodb.client.model.Filters\nimport com.mongodb.client.model.UpdateOptions\nimport com.mongodb.client.model.Updates\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.runBlocking\nimport java.time.LocalDateTime\n\ndata class Movie(\n    val title: String,\n    val runtime: Int,\n    val genres: List<String>,\n    val lastUpdated: LocalDateTime\n)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n    val query = Filters.eq(Movie::title.name, \"Cool Runnings 2\")\n    val updates = Updates.combine(\n        Updates.set(Movie::runtime.name, 99),\n        Updates.addToSet(Movie::genres.name, \"Sports\"),\n        Updates.currentDate(Movie::lastUpdated.name)\n    )\n    val options = UpdateOptions().upsert(true)\n    try {\n        val result = collection.updateOne(query, updates, options)\n        println(\"Modified document count: \" + result.modifiedCount)\n        println(\"Upserted id: \" + result.upsertedId) // only contains a non-null value when an upsert is performed\n    } catch (e: MongoException) {\n        System.err.println(\"Unable to update due to an error: $e\")\n    }\n    mongoClient.close()\n}\n"
        }
      ],
      "preview": "You can update a single document using the updateOne() method on\na MongoCollection object. The method accepts a filter that matches the\ndocument you want to update and an update statement that instructs the\ndriver how to change the matching document. The updateOne() method only\nupdates the first document that matches the filter.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples/watch",
      "title": "Watch for Changes",
      "headings": ["Process Change Stream Events with .collect()", "Example"],
      "paragraphs": "You can keep track of changes to data in MongoDB, such as changes to a\ncollection, database, or deployment, by opening a  change stream . A change\nstream allows applications to watch for changes to data and react to them. The change stream returns  change event  documents when changes occur. A\nchange event contains information about the updated data. Open a change stream by calling the  watch()  method on a\n MongoCollection ,  MongoDatabase , or  MongoClient  object as shown in\nthe following code example: The  watch()  method optionally takes an  aggregation pipeline   which\nconsists of an array of  stages  as the first parameter to filter and\ntransform the change event output as follows: The  watch()  method returns an instance of  ChangeStreamFlow , a class\nthat offers several methods to access, organize, and traverse the results.\n ChangeStreamFlow  also inherits methods from its parent class  Flow \nfrom the Kotlin Coroutines library. You can call  collect()  on the  ChangeStreamFlow  to handle\nevents as they occur. Alternatively, you can use other methods built in to  Flow \nto work with the results. To configure options for processing the documents returned from the change\nstream, use member methods of the  ChangeStreamFlow  object returned\nby  watch() . See the link to the  ChangeStreamFlow  API\ndocumentation at the bottom of this example for more details on the\navailable methods. To capture events from a change stream, call the  collect()  method\nas shown below: The  .collect()  function triggers when a change event is emitted. You can\nspecify logic in the function to process the event document when it is\nreceived. For update operation change events, change streams only return the modified\nfields by default rather than the entire updated document. You can configure\nyour change stream to also return the most current version of the document\nby calling the  fullDocument()  member method of the  ChangeStreamFlow \nobject with the value  FullDocument.UPDATE_LOOKUP  as follows: The following example application opens a change stream on the  movies  collection\nin the  sample_mflix  database. The application use an aggregation pipeline\nto filter changes based on   operationType  so that it only receives insert and update\nevents. Deletes are excluded by omission. The application uses the  .collect()  method\nto receive and print the filtered change events that occur on the collection. The application launches the  collect()  operation in a separate coroutine job,\nwhich allows the application to continue running while the change stream is open.\nOnce the operations are complete, the application closes the change stream and exits. For additional information on the classes and methods mentioned on this\npage, see the following resources: This example connects to an instance of MongoDB using a connection URI.\nTo learn more about connecting to your MongoDB instance, see the\n connection guide . Change Streams  Server Manual Entry Change Events  Server Manual Entry Aggregation Pipeline  Server Manual Entry Aggregation Stages  Server Manual Entry ChangeStreamFlow  API Documentation MongoCollection.watch()  API Documentation MongoDatabase.watch()  API Documentation MongoClient.watch()  API Documentation",
      "code": [
        {
          "lang": "kotlin",
          "value": "val changeStream = collection.watch()\n"
        },
        {
          "lang": "kotlin",
          "value": "val pipeline = listOf(Aggregates.match(Filters.lt(\"fullDocument.runtime\", 15)))\nval changeStream = collection.watch(pipeline)\n"
        },
        {
          "lang": "kotlin",
          "value": "val changeStream = collection.watch()\nchangeStream.collect {\n    println(\"Change observed: $it\")\n}\n"
        },
        {
          "lang": "kotlin",
          "value": "val changeStream = collection.watch()\n    .fullDocument(FullDocument.UPDATE_LOOKUP)\n"
        },
        {
          "lang": "kotlin",
          "value": "\nimport com.mongodb.client.model.Aggregates\nimport com.mongodb.client.model.Filters\nimport com.mongodb.client.model.Updates\nimport com.mongodb.client.model.changestream.FullDocument\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.runBlocking\nimport java.lang.Thread.sleep\n\ndata class Movie(val title: String, val year: Int)\n\nfun main() = runBlocking {\n    // Replace the uri string with your MongoDB deployment's connection string\n    val uri = \"<connection string uri>\"\n    val mongoClient = MongoClient.create(uri)\n    val database = mongoClient.getDatabase(\"sample_mflix\")\n    val collection = database.getCollection<Movie>(\"movies\")\n\n\n\n    val job = launch {\n        val pipeline = listOf(\n            Aggregates.match(\n                Filters.`in`(\"operationType\", mutableListOf(\"insert\", \"update\"))\n            )\n        )\n        val changeStreamFlow = collection.watch(pipeline)\n            .fullDocument(FullDocument.DEFAULT)\n        changeStreamFlow.collect { event ->\n            println(\"Received a change to the collection: $event\")\n        }\n    }\n\n    // Insert events captured by the change stream watcher\n    collection.insertOne(Movie(\"Back to the Future\", 1985))\n    collection.insertOne(Movie(\"Freaky Friday\", 2003))\n\n    // Update event captured by the change stream watcher\n    collection.updateOne(\n        Filters.eq(Movie::title.name, \"Back to the Future\"),\n        Updates.set(Movie::year.name, 1986)\n    )\n\n    // Delete event not captured by the change stream watcher\n    collection.deleteOne(Filters.eq(Movie::title.name, \"Freaky Friday\"))\n\n    sleep(1000) // Give time for the change stream watcher to process all events\n\n    // Cancel coroutine job to stop the change stream watcher\n    job.cancel()\n    mongoClient.close()\n}\n"
        },
        {
          "lang": "console",
          "value": "Received a change to the collection: ChangeStreamDocument{ operationType=insert, resumeToken={\"_data\": \"82646518C0000000022B022C0100296E5A1004782683FAB5A741B0B0805C207A7FCCED46645F69640064646518C0E6873977DD9059EE0004\"}, namespace=sample_mflix.movies, destinationNamespace=null, fullDocument=Movie(title=Back to the Future, year=1985), fullDocumentBeforeChange=null, documentKey={\"_id\": {\"$oid\": \"646518c0e6873977dd9059ee\"}}, clusterTime=Timestamp{value=7234215589353357314, seconds=1684347072, inc=2}, updateDescription=null, txnNumber=null, lsid=null, wallTime=BsonDateTime{value=1684347072952}}\nReceived a change to the collection: ChangeStreamDocument{ operationType=insert, resumeToken={\"_data\": \"82646518C1000000012B022C0100296E5A1004782683FAB5A741B0B0805C207A7FCCED46645F69640064646518C1E6873977DD9059EF0004\"}, namespace=sample_mflix.movies, destinationNamespace=null, fullDocument=Movie(title=Freaky Friday, year=2003), fullDocumentBeforeChange=null, documentKey={\"_id\": {\"$oid\": \"646518c1e6873977dd9059ef\"}}, clusterTime=Timestamp{value=7234215593648324609, seconds=1684347073, inc=1}, updateDescription=null, txnNumber=null, lsid=null, wallTime=BsonDateTime{value=1684347073112}}\nReceived a change to the collection: ChangeStreamDocument{ operationType=update, resumeToken={\"_data\": \"8264651D4A000000042B022C0100296E5A1004CAEADF0D7376406A8197E3082CDB3D3446645F6964006464651D4A8C2D2556BA204FB40004\"}, namespace=sample_mflix.movies, destinationNamespace=null, fullDocument=null, fullDocumentBeforeChange=null, documentKey={\"_id\": {\"$oid\": \"64651d4a8c2d2556ba204fb4\"}}, clusterTime=Timestamp{value=7234220580105355268, seconds=1684348234, inc=4}, updateDescription=UpdateDescription{removedFields=[], updatedFields={\"year\": 1986}, truncatedArrays=[], disambiguatedPaths=null}, txnNumber=null, lsid=null, wallTime=BsonDateTime{value=1684348234958}}"
        }
      ],
      "preview": "You can keep track of changes to data in MongoDB, such as changes to a\ncollection, database, or deployment, by opening a change stream. A change\nstream allows applications to watch for changes to data and react to them.",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "usage-examples",
      "title": "Usage Examples",
      "headings": ["Overview", "How to Use the Usage Examples"],
      "paragraphs": "Usage examples provide convenient starting points for popular MongoDB\noperations. Each example provides the following information: An explanation of the operation in the example showing the\npurpose and a sample use case for the method An explanation of how to use the operation, including parameters,\nreturn values, and common exceptions you might encounter A full Kotlin file that you can copy and paste to run the example\nin your own environment These examples use the  sample datasets \nprovided by Atlas. You can load them into your database on the free tier of\nMongoDB Atlas by following the\n Get Started with Atlas Guide \nor you can\n import the sample dataset into a local MongoDB instance . Once you have imported the dataset, you can copy and paste a usage\nexample into your development environment of choice. You can follow the\n quick start guide  to learn more about getting\nstarted with the MongoDB Kotlin driver. Once you've copied a usage example,\nyou'll need to edit the connection URI to get the example connected to\nyour MongoDB instance: You can use the  Atlas Connectivity Guide \nto learn how to allow connections to your instance of Atlas and to find the\n connection string  you use to replace the\n uri  variable in usage examples. If your instance uses\n SCRAM authentication , you can replace\n <user>  with your username,  <password>  with your password, and\n <cluster-url>  with the IP address or URL of your instance. For more information about connecting to your MongoDB instance, see our\n Connection Guide .",
      "code": [
        {
          "lang": "kotlin",
          "value": "// Replace the following with your MongoDB deployment's connection string.\nval uri = \"<connection string uri>\""
        }
      ],
      "preview": "Usage examples provide convenient starting points for popular MongoDB\noperations. Each example provides the following information:",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "validate-signatures",
      "title": "Validate Driver Artifact Signatures",
      "headings": [
        "Overview",
        "Procedure",
        "Install Encryption Software",
        "Download and Import the Public Key",
        "Download the Signed File",
        "Download the File Signature",
        "Verify the Signature",
        "Additional Information"
      ],
      "paragraphs": "You can validate the signature of a Kotlin driver artifact published\non Maven. This process can enhance the security of your system or\nnetwork by allowing you to confirm the authenticity of the driver. The following steps describe how you can validate driver artifact\nsignatures. You must first install the  GnuPG  encryption suite to use GPG\non the command line. You can install GnuPG by using  Homebrew . As an alternative, you can install  GPG Suite ,\nwhich provides a GUI to use GPG. There is a  Homebrew installation \nfor GPG Suite. Navigate to the  Releases  page\nin the MongoDB JVM drivers GitHub repository. Each version release contains instructions on\nhow to download and import the public key for verifying signatures. In your terminal, run the  curl  command to download the signed\nfile corresponding to a version of the driver. For example,\nrunning the following command downloads the signed file for the\nv5.1.0 driver: In your terminal, run the  curl  command to download the file\nsignature corresponding to a version of the driver. For example,\nrunning the following command downloads the file signature for the\nv5.1.0 driver: Finally, you can verify the signature by using the encryption package.\nThe following terminal command uses  gpg  to verify the artifact signature of the v5.1.0\ndriver: If you successfully verify the signature, you see a message\nsimilar to the following: To learn more about verifying signatures, see  Verify Integrity\nof MongoDB Packages  in the Server\nmanual.",
      "code": [
        {
          "lang": "sh",
          "value": "curl -LO https://repo.maven.apache.org/maven2/org/mongodb/mongodb-driver-core/5.1.0/mongodb-driver-core-5.1.0.jar"
        },
        {
          "lang": "sh",
          "value": "curl -LO https://repo.maven.apache.org/maven2/org/mongodb/mongodb-driver-core/5.1.0/mongodb-driver-core-5.1.0.jar.asc"
        },
        {
          "lang": "sh",
          "value": "gpg --verify mongodb-driver-core-5.1.0.jar.asc mongodb-driver-core-5.1.0.jar"
        },
        {
          "lang": "none",
          "value": "gpg: Signature made Tue 30 Apr 12:05:34 2024 MDT\ngpg:                using RSA key 76E0008D166740A8\ngpg: Good signature from \"MongoDB Java Driver Release Signing Key <packaging@mongodb.com>\" [unknown]\ngpg: WARNING: This key is not certified with a trusted signature!\ngpg:          There is no indication that the signature belongs to the owner.\nPrimary key fingerprint: 1A75 005E 1421 9222 3D6A  7C3B 76E0 008D 1667 40A8"
        }
      ],
      "preview": "You can validate the signature of a Kotlin driver artifact published\non Maven. This process can enhance the security of your system or\nnetwork by allowing you to confirm the authenticity of the driver.",
      "tags": "java, kotlin, security, SSDLC, encryption",
      "facets": {
        "genre": ["tutorial"],
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    },
    {
      "slug": "whats-new",
      "title": "What's New",
      "headings": [
        "What's New in 5.2",
        "What's New in 5.1.3",
        "What's New in 5.1.2",
        "What's New in 5.1.1",
        "What's New in 5.1",
        "Deprecations in 5.1",
        "Improvements in 5.1",
        "New Features in 5.1",
        "What's New in 5.0",
        "What's New in 4.11",
        "Deprecations in 4.11",
        "New Features in 4.11",
        "What's New in 4.10"
      ],
      "paragraphs": "Learn what's new in: Version 5.2 Version 5.1.3 Version 5.1.2 Version 5.1.1 Version 5.1 Version 5.0 Version 4.11 Version 4.10 New features of the 4.11 driver release include: Atlas Search and Vector Search Indexes  in the Indexes guide Adds the  SearchIndexType  class, which you can pass\nwhen constructing a  SearchIndexModel  instance. This change\nallows you to specify the index type when creating an Atlas\nSearch or Vector Search index. To learn more, see  Atlas Search and Vector Search Indexes  in the Indexes guide . The 5.1.3 driver patch release includes the following changes: Fixes an issue that could cause assertion errors when using  Cursor \ntypes. The 5.1.2 driver patch release includes the following changes: Support for encoding Kotlin data classes with nullable\ngeneric parameter types. For example, you can encode the  Container  class\nin the following code: The 5.1.1 driver patch release includes the following changes: When using the  MONGODB-OIDC  authentication mechanism, you must not\ninclude comma characters in the  authMechanismProperties  connection\nstring value. To learn more about this behavior, see the\n MONGODB-OIDC  section of the Enterprise\nAuthentication guide. This section includes the following information: To avoid breaking changes in future major releases of the driver,\nreplace any application code that depends on deprecated program elements. Deprecations in 5.1 Improvements in 5.1 New Features in 5.1 Support for MongoDB server v3.6 is deprecated and will be removed in the\nnext driver version release. To learn how to upgrade your MongoDB server\ndeployment, see  Release Notes  in the MongoDB server\nmanual. Internal testing of GraalVM native image technology. These tests involve building\nnative applications by using the GraalVM native-image tool. Enhanced support for the  MONGODB-OIDC  authentication mechanism.\nTo learn more about OIDC, see the  MONGODB-OIDC  section of the\nEnterprise Authentication Mechanisms guide. Fixes an issue in which operations used the incorrect codec when using\na polymorphic  MongoCollection  instance. This ensures that\ndiscriminator information is not lost when using  bson-kotlinx . Fixes an issue in which the class discriminator was the first field\nwhen decoding, resulting in field type errors when using a polymorphic\n MongoCollection  instance. Support for polymorphic serialization. To learn more, see the\n Polymorphic Serialization  section of the Kotlin Serialization guide. Introduces the  serverMonitoringMode  connection URI option. To\nlearn more, see the  Connection Options  guide. New features of the 5.0 driver release include: The  KotlinSerializerCodecProvider  constructor now accepts\n serializersModule  and  bsonConfiguration  objects: This makes it easier to customize your configuration. Fixes a Kotlin reflection bug that resulted in container type erasure. This section includes the following information: Deprecations in 4.11 New Features in 4.11 The 4.11 driver release deprecates the following items: To avoid breaking changes in future major releases of the driver,\nreplace any application code that depends on deprecated methods and types. The following network address-related methods are deprecated and will be removed\nin v5.0: The  ServerAddress \nmethods  getSocketAddress()  and  getSocketAddresses() . Instead of  getSocketAddress() , use the  getByName()  instance\nmethod of  java.net.InetAddress . Instead of  getSocketAddresses() , use the  getAllByName()  instance\nmethod of  java.net.InetAddress . The  UnixServerAddress \nmethod  getUnixSocketAddress() . Instead of  getUnixSocketAddress() , construct an instance of\n jnr.unixsocket.UnixSocketAddress . Pass the full path of the UNIX\nsocket file to the constructor. By default, MongoDB creates a UNIX\nsocket file located at  \"/tmp/mongodb-27017.sock\" . To learn more\nabout the  UnixSocketAddress , see the  UnixSocketAddress  API documentation. The following methods and types related to the\n StreamFactory \ninterface are deprecated and scheduled for removal in v5.0: If you configure Netty by using\n MongoClientSettings.Builder.streamFactoryFactory() , your code might resemble\nthe following: Replace this code with the  TransportSettings.nettyBuilder() \nas shown in the following example: streamFactoryFactory()  method from  MongoClientSettings.Builder getStreamFactoryFactory()  method from  MongoClientSettings NettyStreamFactoryFactory  class NettyStreamFactory  class AsynchronousSocketChannelStreamFactory  class AsynchronousSocketChannelStreamFactoryFactory  class BufferProvider  class SocketStreamFactory  class Stream  class StreamFactory  class StreamFactoryFactory  class TlsChannelStreamFactoryFactory  class New features of the 4.11 driver release include: Support for connecting to MongoDB by using a SOCKS5 proxy. Added the  getSplitEvent()  method to the  ChangeStreamDocument  class\nto identify fragments of a change stream event that exceeds 16MB. You must\nuse the aggregation stage  $changeStreamSplitLargeEvent  in your change\nstream to handle events that exceed 16MB. Added an aggregation stage builder for  $vectorSearch . Added Atlas Search index management helpers. Updated Snappy and Zstd compression library dependency versions. To learn\nmore about the current dependency versions, see  Network Compression . Added  getElapsedTime()  methods to the following classes to monitor the\nduration of connection pool events: ConnectionCheckOutFailedEvent ConnectionCheckedOutEvent ConnectionReadyEvent Support for Java 21 virtual threads and structured concurrency. The driver\ninternals were updated to avoid unnecessary pinning of virtual threads\nand to preserve interrupted status of a thread, as the latter matters for\nstructured concurrency where it is used for cancellation. To learn more about virtual threads, see the  Virtual Threads \nJDK enhancement proposal. To learn more about structured concurrency, see the\n Structured Concurrency \nJDK enhancement proposal. Updated API documentation for the following types: ClusterListener ServerListener ServerMonitorListener Starting in version 4.10.1 of the Kotlin driver, you must add\nthe  bson-kotlinx  library as an explicit dependency to use the\n kotlinx-serialization  library. Support for Kotlin server-side usage, both for coroutines and for synchronous applications. Codec support for Kotlin data classes. Support for the  kotlinx.serialization  library",
      "code": [
        {
          "lang": "kotlin",
          "value": "@Serializable\ndata class Box<T>(\n    val boxed: T\n)\n\n@Serializable\ndata class Container(\n    val box: Box<String?>\n)"
        },
        {
          "lang": "kotlin",
          "value": "KotlinSerializerCodec.create(clazz.kotlin, serializersModule=serializersModule, bsonConfiguration=bsonConfiguration)"
        },
        {
          "lang": "java",
          "value": "import com.mongodb.connection.netty.NettyStreamFactoryFactory;\n\n// ...\n\nMongoClientSettings settings = MongoClientSettings.builder()\n        .streamFactoryFactory(NettyStreamFactoryFactory.builder().build())\n        .build();"
        },
        {
          "lang": "java",
          "value": "import com.mongodb.connection.TransportSettings;\n\n// ...\n\nMongoClientSettings settings = MongoClientSettings.builder()\n        .transportSettings(TransportSettings.nettyBuilder().build())\n        .build();"
        }
      ],
      "preview": "Learn what's new in:",
      "tags": null,
      "facets": {
        "target_product": ["drivers"],
        "programming_language": ["kotlin"]
      }
    }
  ]
}
